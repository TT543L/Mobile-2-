<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EPhone</title>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff; }
        html { height: 100%; overflow: hidden; }

/* ▼▼▼ Please use the following【an entire block】Brand-new code,replace all old body, phone-frame, phone-screen and other styles ▼▼▼ */

/* 1. Reset body,make it a clean canvas */
body {
    height: 100%;
    overflow: hidden;
    margin: 0;
    font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    /* Background color can be set to preference,here use a soft color */
    background-color: #f0f2f5; 
}

/* 2. Let #phone-screen become the new\"root\"container,fill the entire browser window */
#phone-screen {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #000; /* Keep a default black background */
}

/* 3. 【Core】Hide the simulator status bar */
#status-bar {
    display: none;
}

/* 4. 【Core】Make all pages' headers automatically adapt to iPhone's\"notch\"safe area */
.header, .qzone-header {
    /* Use env(safe-area-inset-top) automatically get the top safe inset */
    padding-top: calc(15px + env(safe-area-inset-top));
}

/* 5. 【Core】Make the chat input and bottom navigation automatically adapt to the iPhone bottom's\"home indicator\"safe area */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

#chat-list-bottom-nav {
     padding-bottom: env(safe-area-inset-bottom);
}

/* 6. Fix the modal's z-index,Ensure it is at the topmost layer */
.modal {
    z-index: 1000; /* Increase z-index to ensure it covers all content */
}

/* ▲▲▲ Replacement end ▲▲▲ */

        #status-bar { position: absolute; top: 0; left: 0; width: 100%; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; color: white; z-index: 10; font-size: 14px; box-sizing: border-box; pointer-events: none; }
        #status-bar-time { font-weight: 600; }
        .battery-container { display: flex; align-items: center; gap: 5px; }
        .battery-icon { width: 25px; height: 12px; border: 1px solid white; border-radius: 3px; position: relative; padding: 1px; }
        .battery-icon::after { content: ''; position: absolute; right: -3px; top: 2px; width: 2px; height: 6px; background-color: white; border-radius: 0 1px 1px 0; }
        .battery-level { height: 100%; background-color: white; border-radius: 1px; transition: width 0.5s ease; }
        .battery-container.charging .battery-level { background-color: #4cd964; animation: charge-breath 2s infinite; }
        .battery-container.charging .battery-text { color: #4cd964; }
        @keyframes charge-breath { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 15px 20px; padding-top: 45px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; }
        .header .header-actions { display: flex; align-items: center; gap: 15px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; }

.header .action-btn {
    font-size: 16px; /* Specifically for\"Upload\",\"+\"Reduce font size for text buttons like upload */
    font-weight: 600; /* Make it slightly bolder to improve clarity */
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        #home-screen { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding: 20px; padding-top: 80px; padding-bottom: 50px; box-sizing: border-box; background-size: cover; background-position: center; }
        #clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-bottom: 20px; flex-shrink: 0; }
        #main-time { font-size: 80px; font-weight: 200; }
        #main-date { font-size: 18px; font-weight: 500; }
        #app-grid { margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px; }
        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #f0f2f5; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
/* Modified #world-book-list styles */
#world-book-list {
    flex-grow: 1;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    padding-top: 80px;
    margin-top: -80px;
}

/* Modified #chat-list Styles,removed padding and margin */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    padding-top: 80px; 
    padding-bottom: 50px; /* Reserve space for the bottom navigation bar */
    box-sizing: border-box;
}

        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn, #selection-delete-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; padding: 5px; }
        #selection-delete-btn { color: #ff3b30; }

/* ▼▼▼ Replace your original with this code #chat-messages styles ▼▼▼ */
#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden; /* Core fix 1: Force disable horizontal scrolling/Drag */
    padding: 10px 15px; /* Core fix 2: Increase left and right padding to 15px,provide more breathing space */
    padding-top: 110px;
    margin-top: -80px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box; /* Ensure padding is calculated correctly */
}
/* ▲▲▲ Replacement end ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px; /* Slightly adjust,to align with the avatar */
    margin-bottom: 3px;
    position: absolute; /* Take it out of the flow,to avoid affecting bubble alignment */
    top: -16px;       /* Position it above the bubble */
    left: 0;
}

/* === 【Brand new】Message layout and timestamp styles === */

/* 1. Overall container for message units (Refactor) */
.message-wrapper {
    display: flex;          /* Use Flex layout */
    gap: 8px;               /* Spacing between bubble and timestamp */
    align-items: flex-end;  /* Core:Align the bottoms of the bubble and timestamp */
    position: relative;
    max-width: 90%;         /* Can be slightly looser,because the timestamp is now outside */
}

/* 2. AIMessage units aligned left */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* Avatar,bubble,timestamp,arranged left to right */
}

/* 3. User message units aligned right */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* Timestamp,bubble,avatar,arranged right to left */
}

/* 4. Direct container for bubble and avatar (Keep unchanged) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    /* Remove the old position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* Prevent timestamp wrapping */
    margin-bottom: 5px;  /* Give it a slight bottom alignment offset with the bubble,for better aesthetics */
    flex-shrink: 0;      /* Prevent being compressed */
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        #chat-input-area { flex-shrink: 0; padding: 8px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 5px; }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 20px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: auto; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* Key:Keep the X-axis centered transform while the Y-axis returns to its original position */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        .message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0; background-color: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-color: white; border-radius: 10px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    /* Core modification:No longer use top,but use margin-top to create spacing,more stable */
    top: 100%; 
    margin-top: 5px; /* <-- New addition:Push down by 5 pixels */
    left: 0;
    right: 0;
    max-height: 150px;
    overflow-y: auto;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }

.checkboxes-container label {
    display: block;
    padding: 12px 15px; /* <-- Modification:Increased vertical and horizontal padding,to make each line taller and wider */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px; /* <-- New addition:Increase font size from the default to 15px */
}

        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    /* --- Core fix --- */
    font-size: var(--chat-font-size, 13px);
    /* --- Fix end --- */
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #3e6224; }

/* ▼▼▼ Replace your original .message with this code block-bubble .content styles ▼▼▼ */
/* General content area styles,prepare for timestamps and font sizes */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* Core fix: Force long words or URLs to wrap,to prevent popping the bubble */
}
/* ▲▲▲ Replacement end ▲▲▲ */

        /* === Bubble theme styles === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* === Avatar frame selection modal styles (This is newly added) === */
.change-frame-btn {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    margin-left: 10px;
}

#avatar-frame-modal .modal-content {
    height: 70%; /* Make the window taller */
}

#avatar-frame-modal .modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
}
      
.frame-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.frame-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary);
    border-bottom: 2px solid transparent;
}

.frame-tab.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

.frame-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
}

.frame-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); /* Auto-fill each row,min width 70px */
    gap: 15px;
}

.frame-item {
    aspect-ratio: 1 / 1; /* Keep square */
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    padding: 5px;
    transition: all 0.2s ease;
    position: relative; /* Prepare for previews */
}

.frame-item.selected {
    border-color: var(--accent-color);
    transform: scale(1.05);
}

.frame-item .preview-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.frame-item .preview-frame {
    position: absolute;
    top: -7px;
    left: 0;
    width: 100%;
    height: 100%;
}

/* These are the new styles you should add */
#font-preview {
    transition: font-family 0.3s ease;}

/* === New styles added to the chat list interface (This is newly added) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* Bottom navigation bar styles */
#chat-list-bottom-nav {
    position: absolute; /* Fix it to the bottom */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* Ensure it sits above the view */
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* === Dynamic interface (QZone) styles (This is newly added) === */
#qzone-screen {
    background-color: #f0f2f5;
}

.qzone-header {
    /* position: absolute;  <-- Change this to relative */
    position: relative;
    z-index: 10; /* z-index Keep it,or it can be higher */
    flex-shrink: 0; /* Prevent being compressed */
    padding: 15px 20px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { /* "Friends' activity feed"Text */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    /* padding-top: 80px;  <-- Remove this,because the header is no longer absolute */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* Background panel height */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* Offset the avatar and name area downward,half inside the background panel and half outside */
    left: 20px;
    display: flex;
    align-items: flex-end; /* Align the bottom of the name and avatar */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* Fine-tune the position */
}

/* Common styles for the edit button */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* Spacing relative to the name */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* Alignment detached from the flex layout */
    bottom: 5px; /* Adjust vertical position slightly */
}

/* === Make the edit feature more\"invisible\" === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* Show pointer cursor on hover to indicate clickability */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* Slightly darken on hover,to provide user feedback */
}
/* Hide the old, standalone edit button */
.qzone-edit-btn {
    display: none;
}

/* === Control visibility of Header and Bottom Nav === */
/* Hide the dynamic interface Header by default */
#qzone-screen .qzone-header {
    display: none;
}
/* When the dynamic view is active,show its Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* When entering the dynamic view,hide the main Header and the bottom navigation */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-list-item:first-child,
.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ End of new styles replacement ▲▲▲ */

/* ▼▼▼ Paste all these new styles to <style> the end ▼▼▼ */

/* === Dynamic function bar styles === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* Increase top margin,to leave space for the floating avatar */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* Create a separator line using a pseudo-element */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === Dynamic post list styles === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* Leave margins on the left, right, and bottom */
    display: flex;
    flex-direction: column;
    gap: 20px; /* Spacing between posts */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* Enable line breaks to take effect */
    word-break: break-word; /* Prevent long words from overflowing */
}

/* ▲▲▲ End of new styles ▲▲▲ */

/* ▼▼▼ Paste the new styles to the end ▼▼▼ */

/* === Post publish modal styles === */
#post-public-text {
    min-height: 80px; /* Ensure the textarea has sufficient height */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* Keep 16:9preview ratio */
    background-color: #f0f2f5;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* Hidden by default */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* Show after upload */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #ff3b30;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ End of new styles ▲▲▲ */

/* ▼▼▼ New styles ▼▼▼ */

/* === Post publish modal - Mode toggle styles === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* All hidden by default */
}

.post-mode-content.active {
    display: block; /* Only active ones are shown */
}

/* ▲▲▲ End of new styles ▲▲▲ */

/* === Album page background color === */
#album-screen {
    background-color: #f0f2f5; /* Use a soft light gray,which is easier on the eyes than pure white */
}

/* === Album page grid layout === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* Display 2 albums per row */
    gap: 15px;
}

/* === Album item styles (Beautify) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* Add rounded corners to the entire item as well */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* Keep the cover square */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #f0f2f5; /* Placeholder color before the cover loads */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* Prevent long names from wrapping */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ Please paste these new styles to <style> the end ▼▼▼ */

/* === Album photo detail page === */
#album-photos-screen {
    background-color: #f0f2f5;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    /* Display 3 photos per row,and maintain spacing */
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; /* To position the delete button */
    aspect-ratio: 1 / 1; /* Keep photos square */
    border-radius: 6px;
    overflow: hidden; /* Prevent images from overflowing rounded corners */
    background-color: #e9ecef; /* Placeholder color before the image loads */
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; /* Ensure images fill the container without distortion */
    cursor: pointer;
}

/* Delete button styles */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.2s ease;
}

/* Show the delete button when hovering over a photo */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* === Image viewer modal styles === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* Image max width is 90 of the viewport% */
    max-height: 85vh; /* Image max height is 85 of the viewport% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* Add a slight smooth fade-in/out effect when switching images */
    transition: opacity 0.2s ease-in-out;
}

/* Close button */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* Left and right navigation arrows */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* Now we use absolute positioning to control the arrows */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* On phone screens,make them slightly smaller */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* Adjust padding */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* Ensure the arrows are on the top layer */
}

#photo-viewer-prev-btn {
    left: 5px; /* Position the left arrow */
}

#photo-viewer-next-btn {
    right: 5px; /* Position the right arrow */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* When the arrows are disabled(For example, the first or last image) */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste these new styles to <style> the end ▼▼▼ */

/* ▼▼▼ Replace the previous interactive area CSS with this new CSS ▼▼▼ */

/* === Post content area - Relatively positioned container === */
/* === Post content area === */
.post-main-content {
    /* It is now just a normal content container,no special styles are needed */
}

/* === Post interaction icon area (New styles) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* Align icons to the right */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* Core modification:Give the icon area 8px of vertical spacing on top and bottom */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* Default gray */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* Icon active(Like/After favoriting)the style */
.action-icon.active {
    color: #ff5252; /* Become red when activated */
    transform: scale(1.1); /* Slightly enlarged */
}

.action-icon.active.favorite {
    color: #ffc107; /* Use yellow for bookmark/favorite */
}

.action-icon.active svg {
    fill: currentColor; /* Fill with color when active */
}

/* Animation effect on click */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === Post bottom comments area styles (Now a separate section) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* Separate with a light-colored line */
    display: flex;
    align-items: center;
    gap: 8px; /* Adjust the overall spacing */
}

/* Comments container */
.comment-section {
    flex-grow: 1; /* Occupy most of the space */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* New send button styles */
.comment-send-btn {
    flex-shrink: 0; /* Prevent being compressed */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* === Common style for unread message red dot === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #ff3b30;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* Red dot on the chat interface back button (Only show the dot,do not show numbers) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* Place it at the top-right of the back arrow */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* === Comment list container === */
.post-comments-container {
    padding: 10px 0; /* Vertical spacing */
    display: flex;
    flex-direction: column;
    gap: 8px; /* Spacing between comments */
    font-size: 13px; /* Uniform comment area font size */
}

/* Each comment */
.comment-item {
    line-height: 1.5;
}

/* Commenter's name, bold and use theme color */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* Leave some space between it and the comment content */
}

/* Comment content */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}
/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* === Post like area style === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* Spacing between icon and text */
    padding: 8px 10px; /* Padding */
    font-size: 13px;
    color: var(--accent-color); /* Use theme blue */
    background-color: #f0f5fa; /* Give a subtle background color */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* Keep some distance from the icon above */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* Let SVG icons inherit the parent's color */
    flex-shrink: 0; /* Prevent icons from being squashed */
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* === @Mention popup menu style === */
.at-mention-popup {
    position: absolute; /* Position relative to parent element */
    bottom: 100%; /* Display above the input field */
    left: 40px; /* Align with the left side of the input field (Accounts for avatar width) */
    width: calc(100% - 40px); /* Width roughly the same as the input field */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* Hidden by default */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* ▼▼▼ Please use the following snippet【New styles】Replace your existing one with it #favorites-list styles ▼▼▼ */

/* Make the favorites view a flex container, arranged top to bottom */
#favorites-view {
    display: flex;
    flex-direction: column;
}

/* Ensure the header height on the favorites page is fixed and not compressed */
#favorites-view > .header {
    flex-shrink: 0;
}

/* === Favorites list style (After fix) === */
#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* <-- Add this line, disable horizontal scrolling */
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

/* ▲▲▲ Replacement end ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* To position the delete button */
}

/* Card header, includes avatar, name and source */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* Card content */
.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* Spacing between image and text */
}

/* Delete button */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #ff3b30;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* === Search bar style === */
.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; /* Match the list background color */
    position: relative; /* For positioning the clear button */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* Reserve space on the right for the clear button */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* Rounded rectangle, more modern */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* === Chat interface multi-select action bar optimization === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen .selection-controls .action-btn {
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    padding: 5px;
}

/* === Favorites page multi-select mode style === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* Selection box style */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* Put it outside the left side of the card */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* Hidden by default */
}

/* When entering selection mode, the card shifts right to reveal the selection box */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* Style when selected */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* Bottom action bar (Ultimate revised version) */
#favorites-action-bar {
    position: absolute; /* ★ Change to absolute, relative to #phone-screen positioning */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ Add right: 0,And left: 0 Together stretch to full width */
    width: auto;        /* ★ Change to auto, let left/right Decide the width */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* Adapt to iPhone bottom safe area */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width No longer needed, because the parent element already limits the width */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}

/* === 【Fix】Chat interface header control toggle logic === */

/* Default state:Hide multi-select controls */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* Default state:Show default controls, and let them fill the entire header */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* When entering multi-select mode:Hide default controls */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* When entering multi-select mode:Show multi-select controls, and let them fill the entire header */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ Please paste this new style to <style> the end ▼▼▼ */

/* === Fix:Enlarge all primary\"+\"plus buttons === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* Significantly increase font size so it visually matches the adjacent icons */
    font-weight: 300;  /* Use a lighter font weight to make the plus look cleaner and not bulky */
    position: relative;/* Allow positional fine-tuning */
    top: -1px;         /* After enlarging the font, usually move it slightly upwards to appear more visually centered */
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste these new styles to <style> the end ▼▼▼ */

/* Preview area container style */
#settings-preview-area {
    width: 100%;
    height: 180px; /* Give a fixed height */
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* Prevent content overflow */
    display: flex;
    flex-direction: column;
    gap: 10px; /* Spacing between preview bubbles */
    border: 1px solid var(--border-color);
    position: relative; /* For positioning the background */
}

/* The preview area's background can be synchronized with the real chat interface */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* Keep preview bubbles above the background */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* Avatars used in the preview area should be smaller */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}
#settings-preview-area .avatar-with-frame {
     width: 30px;
    height: 30px;
}
#settings-preview-area .avatar-with-frame .avatar-frame {
    width: 44px;
    height: 44px;
    top: -7px;
    left: -7px;
}
#settings-preview-area .message-bubble .timestamp {
    display: none; /* The preview area does not need to show timestamps */
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* ▼▼▼ Please paste this new CSS into <style> the end ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ Please paste this new CSS into <style> the end ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}

.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* A sufficiently large value */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ Please paste this new CSS into <style> the end ▼▼▼ */

/* Format helper button container */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* Create spacing from the textbox below */
    flex-wrap: wrap; /* Allow wrapping if there are too many buttons */
}

/* Style of a single format helper button */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* Capsule shape, friendlier */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ Please paste this new CSS into <style> the end ▼▼▼ */

/* \"...\"Button style */
.post-actions-btn {
    margin-left: auto; /* Key:Make it automatically align to the far right */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* Dynamic edit modal style (It will reuse the existing action menu styles) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* Uniformly reset all text effects and colors inside the transfer card */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* Force remove any glow or shadow effects */
    color: white !important;      /* Force lock text color to white */
}

/* Lock each font size and weight separately to prevent tampering */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ Please use the following【an entire block】Brand new adaptive code to replace all old avatar-related styles ▼▼▼ */

/* 1. Avatar container's【Default/Frameless】state */
.avatar-group {
    width: 34px;      /* Default width, same as the avatar image width */
    flex-shrink: 0;
    position: relative;
    transition: width 0.2s ease; /* Add a smooth width transition animation */
}

/* 2. When【Framed】, the avatar container automatically widens */
.avatar-group.has-frame {
    width: 42px; /* Become wider, leaving space for larger avatar images and frames */
}

/* 3. Regular avatar(When frameless)the style */
.message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 20%;
    object-fit: cover;
}

/* 4. Framed avatar container【Default】Size */
.avatar-with-frame {
    position: relative;
    width: 34px; /* Default same size as regular avatar */
    height: 34px;
    margin: 0 auto;
    transition: all 0.2s ease; /* Add animation for size changes */
}

/* 5. When【Framed】, the framed avatar container automatically【grows larger】,Solve the issue you mentioned\"small image big frame\"problem! */
.avatar-group.has-frame .avatar-with-frame {
    width: 43px; /* Image container enlarges */
    height: 43px;
}

/* 6. The avatar image itself always fills its container */
.avatar-with-frame .avatar-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    z-index: 1;
}

/* 7. The avatar frame is always centered based on its parent container */
.avatar-with-frame .avatar-frame {
    position: absolute;
    width: 52px;
    height: 52px;
    top: -9px;   
    left: -4px;  
    z-index: 2;
    pointer-events: none;
}

/* ▲▲▲ Replacement end ▲▲▲ */

/* ▼▼▼ These are new styles to fix the centering issue of all header titles ▼▼▼ */
.header > span:nth-child(2),
#chat-header-title {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* On the basis of-50%, push 2px further to the left on top of that */
    
    /* (Optional but recommended) Prevent long titles from overlapping the buttons on both sides */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ End of paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Visual message editor style ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* Override the default margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Contact selector style ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Group member management interface style ▼▼▼ */
#member-management-list {
    padding: 0; /* Remove default padding so list items fill the space */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #ff3b30;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #4cd964; /* Use green for New to distinguish */
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Takeout pay-on-behalf card style ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; /* Orange-yellow background */
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Takeout response status style ▼▼▼ */

/* === Style after agreeing to pay === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* Green border */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重写 request-title 'sContent */
    content: "I have paid for you, please enjoy~" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* Hide payment details */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === Style after refusing to pay === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* Red border */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重写 request-title 'sContent */
    content: "I declined your pay-on-behalf request" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* Hide payment details */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 强制重写 request-title Content's技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* Hide original text */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* Use pseudo-elements to display new text */
}
.message-bubble.status-paid .request-title::after {
    content: "I have paid for you, please enjoy~";
}
.message-bubble.status-rejected .request-title::after {
    content: "I declined your pay-on-behalf request";
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】User action button styles for takeout requests ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* Leave space at the bottom of the card */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* === 【New addition】Set the page background color uniformly (Fixed) === */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#memories-view,
#contact-picker-screen,
#member-management-screen,
#world-book-editor-screen {  
    background-color: var(--secondary-bg);
}

/* Ensure the content areas of these pages can scroll correctly */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    background-color: var(--secondary-bg);
}

/* The wallpaper settings page preview area is special and requires extra adjustments */
#wallpaper-screen .form-container {
    align-items: center; /* Keep content centered */
}

/* ▼▼▼ 【Brand new】Incoming call request and video call interface styles ▼▼▼ */

/* --- Incoming call request modal --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #ff3b30;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}

.call-action-btn.accept {
    background-color: #4cd964;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* --- Video call interface --- */
/* ▼▼▼ Please use this entire block【Final revised version】's代码,替换所有旧's video-call 相关CSS ▼▼▼ */

/* 1. Call screen main container (Keep unchanged) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 2. Top bar and bottom control bar (Keep unchanged) */
.video-call-top-bar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    padding: 15px 20px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    text-align: center;
    box-sizing: border-box;
    pointer-events: none;
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}
.video-call-controls {
    position: absolute;
    bottom: 0; left: 0; width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    box-sizing: border-box;
}

/* 3. Participant avatar display area (Keep unchanged) */
.video-call-avatar-area {
    flex-grow: 1; 
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: 80px; /* Ensure enough space at the top */
    box-sizing: border-box;
    overflow-y: auto; /* ★ New addition:Allow this area to scroll if there are too many avatars */
}

/* 4. Avatar grid container (Keep unchanged) */
#participant-avatars-grid {
    display: flex;
    flex-wrap: wrap; 
    justify-content: center;
    align-items: center;
    gap: 15px; /* ★ Slightly reduce avatar spacing */
    max-width: 100%;
}

/* 5. Single participant avatar container (Avatar shrink) */
.participant-avatar-wrapper {
    position: relative;
    text-align: center;
    flex-shrink: 0;
}
.participant-avatar {
    width: 70px;   /* ★ Shrink from 80px to 70px */
    height: 70px;  /* ★ Shrink from 80px to 70px */
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 12px;
    color: #ccc;
}

/* 6. Speaker avatar highlight effect (Keep unchanged) */
.participant-avatar.speaking {
    border-color: #4cd964;
    box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
    transform: scale(1.05);
}

/* 7. 【Final version】Dialogue area */
#video-call-main {
    flex-shrink: 0; 
    height: 30%;   /* ★ Core modification:Height from 35%Reduce to 30% */
    margin: 15px 15px 130px 15px; /* ★ Core modification:Bottom margin increased from 120px to 130px, creating a noticeable gap */
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    box-sizing: border-box;
}

/* 8. Control button styles (Keep unchanged) */
.control-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, background-color 0.2s;
}
.control-btn:active {
    transform: scale(0.9);
}
.control-btn.speak-btn {
    background-color: rgba(255,255,255,0.2);
    background-size: 55%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
}
.control-btn.hangup-btn {
    background-color: #ff3b30;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}
.control-btn.join-btn {
    background-color: #007bff;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
}

/* ▲▲▲ End of new CSS replacement ▲▲▲ */

/* ▼▼▼ 【Brand new】Video call dialog bubble styles ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; /* AISpeaker aligned left */
}

.call-message-bubble.user-speech {
    background-color: #4cd964; /* User speech in green, like WeChat */
    align-self: flex-end;   /* User speech aligned right */
    text-align: left; /* Ensure text inside user bubbles is left-aligned */
}
/* ▲▲▲ End of added CSS ▲▲▲ */

/* ▼▼▼ 【Newly added】Calling interface style ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* Vertically centered */
    align-items: center;   /* Horizontally centered */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* Separate from the text above */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}
/* ▲▲▲ End of addition ▲▲▲ */

/* 1. Outer container for dynamic posts, we need it for positioning and clipping */
.qzone-post-container {
    position: relative; /* Allow internal delete buttons to be positioned relative to it */
    overflow: hidden;   /* Hide parts of delete buttons that overflow */
    border-radius: 12px;/* Border radius matching internal cards */
}

/* 2. Scrollable content card, add a smooth transition effect */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* Ensure it has a background color to cover the delete buttons underneath */
    position: relative; /* Ensure it is on the top layer */
    z-index: 2;
}

/* 3. 【Core】This is the\"delete\"Button styles!*/
.qzone-post-delete-action {
    position: absolute; /* Absolute positioning, removed from the document flow */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* Width of the delete button */
    background-color: #ff3b30; /* The red background you want */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* Make sure it sits beneath the card */
}

/* 4. When the card is swiped left, move it left to reveal the delete button */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* Move the same distance as the delete button's width */
}

/* ▲▲▲ End of paste ▲▲▲ */

/* ▼▼▼ Please put this【an entire block】Brand-new\"Tap\"styles, paste into <style> the end ▼▼▼ */

/* 1. \"Tap\"the screen shake animation of */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. \"Tap\"System notification message styles */
.system-message {
    align-self: center; /* Centered display */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ End of new styles paste ▲▲▲ */

/* Let\"Tap\"Center the wrapper of type */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* \"Tap once-Tap\"Message bubble styles */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ Please paste this new CSS into <style> the end ▼▼▼ */

/* === Fix:Allow the top action bar to scroll horizontally === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- Core code begins --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* === 【Brand new】Chat header status bar styles === */

/* 1. Container for title and status, use flex layout to stack them vertically */
#chat-header-title-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; /* Horizontally centered */
    gap: 2px; /* Small gap between title and status */
    
    /* To make it correctly centered within the flex layout */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    max-width: 60%;
}

/* 2. Main title styling tweaks */
#chat-header-title {
    font-size: 16px; /* Make it slightly smaller to leave room for the status bar */
    font-weight: 600;
    position: static; /* Override the old absolute positioning */
    transform: none;  /* Override the old transform */
    /* Ensure long titles correctly show ellipsis */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

/* 3. Status bar container */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. Small status dot */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #4cd964; /* Default green, indicating online */
    transition: background-color 0.3s ease;
}

/* When AI status is\"Busy\"or\"Away\"then, make the dot gray */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. Status text */
.status-text {
    font-weight: 500;
}

/* === 【All-new refreshed version】Memory card styles === */

/* 1. Card main container:Here defines the overall background color and border */
.memory-card {
    background-color: #fffaf0; /* Uniform warm beige background */
    border-radius: 12px;
    padding: 15px; /* Add padding around the card */
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; /* Make it a flex container to arrange inner elements */
    flex-direction: column; /* Stack header and content vertically */
    gap: 8px; /* Create natural spacing between header and content */
}

/* 2. Header container:Now only responsible for layout and divider */
.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* Slightly darken the divider color */
    padding-bottom: 8px; 
}

/* 3. Date styles (Keep unchanged) */
.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

/* 4. Author styles (Keep unchanged) */
.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. Content area styles (Keep unchanged) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

/* === 【Brand new】Convention/Countdown card styles === */
.countdown-card {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【Brand new】Chat lock overlay styles === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 150; /* Taller than the input box, lower than the sticker panel */
    display: none; /* Hidden by default */
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: center;
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}

/* ▼▼▼ 【Brand new】Red packet card styles ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* Gold text */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Red packet detail list styles ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Voting feature styles ▼▼▼ */

/* Vote card styles inside message bubble */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* Vote card body */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* Gray out after ending */
}

/* Voting question */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* Voting options list */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* Single voting option */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* Style for options the user voted for */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* Vote progress bar */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* Option content(Text and vote count),Ensure it's above the progress bar */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* Bottom of the vote card */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* Option input for creating a vote modal */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #ff3b30;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* === 【Brand new】Chat header\"Typing\"Status styles === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
    font-style: italic;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

/* ▼▼▼ 【Brand new】AppIcon settings styles ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 10px;
    font-size: 12px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ End of new CSS paste ▲▲▲ */

/* ▼▼▼ 【Brand new】Appearance settings page layout fixes ▼▼▼ */

/* 1. Fix scrolling issues */
#wallpaper-screen .form-container {
    /* Core fix 1: Resolve scrolling conflicts in flex layout so scrollbars appear properly */
    min-height: 0; 
}

/* 2. Fix wallpaper preview being squashed */
#wallpaper-preview {
    /* Core fix 2: Prevent the preview box from being squeezed by too much content so it keeps its height */
    flex-shrink: 0; 
}
/* ▲▲▲ Fix end ▲▲▲ */

/* ▼▼▼ 【Brand new】Share link feature styles (No-image version) ▼▼▼ */

/* 1. Browser UI background color and content area styles (Keep unchanged) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. Link card styles inside chat bubbles (No-image version) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 250px;
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px; /* Set padding directly on the card */
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex; /* Use flex layout to vertically align content and icon */
    flex-direction: column;
    gap: 8px; /* Spacing between title, description, and footer */
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* Horizontally align icon and text */
    align-items: center;
    gap: 6px; /* Spacing between icon and text */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* Add some space from the description above */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* Prevent icons from being squashed */
}

/* ▲▲▲ End of new CSS paste ▲▲▲ */

    </style>
</head>
<body>
        <div id="phone-screen">
            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>
            
            <div id="home-screen" class="screen active">
                <div id="clock-container"><div id="main-time">12:00</div><div id="main-date">Monday, January 1</div></div>
                                                <!-- ▼▼▼ Replace your original id with this whole block of code="app-grid" ▼▼▼ -->
<div id="app-grid">
    <!-- First line:Place 2 icons -->
    <div class="app-row">
        <div class="app-icon" onclick="showScreen('world-book-screen')">
            <div class="icon-bg">
                <!-- 【Core modification 1】Add ID -->
                <img id="icon-img-world-book" src="https://i.postimg.cc/mZ0vV6tT/IMG-6907.jpg" alt="World book">
            </div>
            <span class="label">World book</span>
        </div>
        <div class="app-icon" onclick="showScreen('chat-list-screen')">
            <div class="icon-bg">
                <!-- 【Core modification 2】Add ID -->
                <img id="icon-img-qq" src="https://i.postimg.cc/gJ7Dz5fj/IMG-6906.jpg" alt="QQ">
            </div>
            <span class="label">QQ</span>
        </div>
    </div>
    <!-- Second line:Place 3 icons -->
    <div class="app-row">
        <div class="app-icon" onclick="showScreen('api-settings-screen')">
            <div class="icon-bg">
                <!-- 【Core modification 3】Add ID -->
                <img id="icon-img-api-settings" src="https://i.postimg.cc/RhnTNdBR/IMG-6908.jpg" alt="APISettings">
            </div>
            <span class="label">APISettings</span>
        </div>
        <div class="app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg">
                <!-- 【Core modification 4】Add ID -->
                <img id="icon-img-wallpaper" src="https://i.postimg.cc/WbgQy6kg/IMG-6909.jpg" alt="Appearance settings">
            </div>
            <span class="label">Appearance settings</span>
        </div>
        <div class="app-icon" onclick="showScreen('font-settings-screen')">
            <div class="icon-bg">
                <!-- 【Core modification 5】Add ID -->
                <img id="icon-img-font" src="https://files.catbox.moe/j1kn1a.jpeg" alt="Font">
            </div>
            <span class="label">Font</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ Replacement end ▲▲▲ -->
            </div>
          
            <div id="world-book-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>World book</span><span class="action-btn" id="add-world-book-btn">+</span></div><div id="world-book-list"></div></div>
            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">Edit world book</span>
                    <span class="save-btn" id="save-world-book-btn">Save</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">Book title</label>
                        <input type="text" id="world-book-name-input" placeholder="Please enter the name of the world book...">
                    </div>
                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">Content</label>
                        <textarea id="world-book-content-input" placeholder="Enter detailed world info here..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API Settings</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">Tip: To use\"Send image\"feature, please be sure to choose a model that supports Vision(Vision)models, such as<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>or<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>.</p><div class="form-group"><label for="proxy-url">Reverse proxy address (Not necessary to add/v1Oh~)</label><input type="text" id="proxy-url" placeholder="For example: https://api.openai.com"></div><div class="form-group"><label for="api-key">Key (API Key)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">Model</label><select id="model-select"></select></div><button class="form-button" id="fetch-models-btn">Pull model</button>

<!-- ▼▼▼ Paste this code into the API settings page's\"Save settings\"Above the button ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        Enable background role activity
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            Warning:This feature will significantly increase API calls and costs!
        </p>
    </label>
    <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
</div>
<!-- ▲▲▲ End of paste ▲▲▲ -->

<!-- ▼▼▼ Paste this code to\"Enable background role activity\"Below the toggle ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="background-interval-input" style="margin-bottom: 0;">
        Background activity detection interval (seconds)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            Recommended value 60-300.The larger the value, the lower the costs, but the slower the role's response.
        </p>
    </label>
    <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ End of paste ▲▲▲ -->

<!-- ▼▼▼ Add here ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AICooldown after being blocked (hours)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            After being blocked for longer than this time, the AI may have a chance to re-request friendship.
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ Addition finished ▲▲▲ -->

<button class="form-button" id="save-api-settings-btn">Save settings</button>
			<hr style="margin:20px 0; opacity:.3">

			<button class="form-button" id="export-data-btn">Export data</button>

<!-- ① Regular button, and\"Export\"a class -->
<button class="form-button" id="import-btn">Import backup file</button>

<!-- ② Real file picker, completely hidden -->
<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<!-- ▼▼▼ Use the code below to fully replace your original chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- Main header (Only show in the message list) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>Messages</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="Create group chat"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- Message list view -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JSChat list will be generated here -->
        </div>
    </div>

    <!-- Activity interface view -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- This button now only handles returning from activity -->
            <span>Friends' activity feed</span>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="Background">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="Avatar">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>Posts</span></div>
                <div class="action-item" id="create-post-btn"><span>Activity</span></div>
                <div class="action-item" id="open-album-btn"><span>Album</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- Favorites interface view -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>My favorites</span>
        <!-- Added edit button -->
        <span class="action-btn" id="favorites-edit-btn">Edit</span>
    </div>

        <!-- 【New addition】Search bar container -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="Search favorite titles, content, or authors...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- Favorite items will be dynamically generated here by JS -->
        </div>

<!-- New addition:Bottom action bar of favorites page -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">delete (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【Brand new】Memoir interface view ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>Our memories</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- Memory cards will be dynamically generated here by JS -->
    </div>
</div>
<!-- ▲▲▲ New HTML end ▲▲▲ -->
    
    <!-- Bottom navigation bar -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>Messages</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>Activity</span>
    </div>
    <!-- ▼▼▼ On the basis of\"Activity\"and\"Favorites\"Between, add this new tab ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>Memories</span>
    </div>
    <!-- ▲▲▲ End of addition ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>Favorites</span>
    </div>
</div>
</div>
<!-- ▲▲▲ End of replacement area ▲▲▲ -->

<!-- ▼▼▼ Please paste this new HTML into the id="chat-list-screen" after the div ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. Page header, including back button and title -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>My album</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. Page content container -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- Album list will be dynamically generated here by JS -->
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ Please paste this new HTML into the id="album-screen" after the div ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. Page header -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">Album name</span>
        <span class="action-btn" id="album-upload-photo-btn">Upload</span>
    </div>
    
    <!-- 2. Page content container -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- Photo list will be dynamically generated here by JS -->
        </div>

<!-- ▼▼▼ Please paste this new HTML at the end of all modals ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. Close button -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. Previous photo button -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. Image container -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="Fullscreen photo preview">
    </div>
    
    <!-- 4. Next photo button -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ Paste into #album-photos-screen after the div ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ Please use this【an entire block】Brand-new code, fully replace the old one in your file #chat-interface-screen and all its contents ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

    <!-- 【Final revised version】Header,Status bar and search functions have been properly integrated -->
    <div class="header">
        <!-- Default controls:Includes title,status bar and common buttons -->
        <div class="default-controls">
            <span class="back-btn" id="back-to-list-btn">‹</span>
            
            <!-- ▼▼▼ 【Core additions】Container for title and status ▼▼▼ -->
            <div id="chat-header-title-wrapper">
                <span id="chat-header-title">Chat partner</span>
                <div id="chat-header-status">
                    <span class="status-dot"></span>
                    <span class="status-text">Online</span>
                </div>
            </div>
            <!-- ▲▲▲ Addition finished ▲▲▲ -->

            <div class="header-actions">
                <span class="action-btn" id="listen-together-btn" title="Listen together"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="Listen together"></span>
                <span class="action-btn" id="chat-settings-btn" title="Chat settings"><img src="https://i.postimg.cc/R04MT1MV/210-20250618115233.png" alt="Settings"></span>
            </div>
        </div>

        <!-- Multi-select mode controls (Keep unchanged) -->
        <div class="selection-controls">
            <span id="selection-cancel-btn">Cancel</span>
            <span id="selection-count"></span>
            <div class="header-actions">
               <span id="selection-favorite-btn" class="action-btn">Favorites</span>
               <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">delete</span>
            </div>
        </div>
    </div>
    
    <!-- Chat message area (Keep unchanged) -->
    <div id="chat-messages"><div id="typing-indicator">The other party is typing...</div></div>

    <!-- Input area (Keep unchanged) -->
    <div id="chat-input-area">
        <div id="chat-input-actions-top">
            <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="Emoji panel">+</button>
            <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="Send photo"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></button>
            <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="Upload image"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-primary);"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button id="transfer-btn" class="chat-action-icon-btn action-button" title="Transfer">￥</button>
            <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="Send voice message"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg></button>
<!-- ▼▼▼ Paste this line of new code into\"Send voice message\"After the button ▼▼▼ -->
<button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="Initiate takeaway request"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg></button>
<!-- ▲▲▲ End of new code paste ▲▲▲ -->
<!-- ▼▼▼ 【New addition】Video call button ▼▼▼ -->
<button id="video-call-btn" class="chat-action-icon-btn action-button" title="Video call"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
<!-- ▲▲▲ Addition finished ▲▲▲
<!-- ▼▼▼Group video call button ▼▼▼ -->
<button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="Group video call"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
<!-- ▲▲▲ End of new additions ▲▲▲ -->
<!-- ▼▼▼Initiate poll button▼▼▼ -->
<button id="send-poll-btn" class="chat-action-icon-btn action-button" title="Initiate poll"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg></button>
<!-- ▲▲▲ Replacement end ▲▲▲ -->
<!-- ▼▼▼ At id="chat-input-actions-top" the end,【Add】This new button ▼▼▼ -->
<button id="share-link-btn" class="chat-action-icon-btn action-button" title="Share link"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
<!-- ▲▲▲ New HTML end ▲▲▲ -->
        </div>
        <div id="chat-input-main-row">
            <textarea id="chat-input" rows="1" placeholder="Enter message..."></textarea>
            <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="Waiting for reply"><img src="https://i.postimg.cc/2SwjsfZQ/IMG-6913.gif" alt="Waiting for reply"></button>
                <button id="send-btn" class="action-button">Send</button>
            </div>
        </div>
    </div>

<!-- ▼▼▼ Add here ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ Addition finished ▲▲▲ -->

    <!-- Emoji panel (Keep unchanged) -->
    <div id="sticker-panel">
        <div id="sticker-panel-header">
            <span class="panel-btn" id="close-sticker-panel-btn">Cancel</span>
            <span class="title">My emojis</span>
            <div style="display: flex; gap: 10px;">
              <span class="panel-btn" id="add-sticker-btn">Add</span>
              <span class="panel-btn" id="upload-sticker-btn">Upload</span>
            </div>
        </div>
        <div id="sticker-grid"></div>
    </div>
    <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- Music player (Keep unchanged) -->
    <div id="music-player-overlay">
        <div class="music-player-window">
            <span id="music-playlist-btn">☰</span>
            <div id="music-time-counter">Have already listened together for 0.0 hours</div>
            <div id="music-player-song-title">Please add songs</div>
            <div id="music-player-artist">...</div>
            <div class="music-controls">
                <button id="music-prev-btn">◀</button>
                <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                <button id="music-next-btn">▶</button>
                <button id="music-mode-btn">Order</button>
            </div>
            <div class="music-bottom-actions">
                <button id="music-exit-btn">Leave Listen Together</button>
                <button id="music-return-btn">Return to chat</button>
            </div>
        </div>
    </div>
    
    <div id="music-playlist-panel">
        <div class="playlist-header">
            <span class="panel-btn" id="close-playlist-btn">Back</span>
            <span>Playlist</span>
            <div>
                <span class="panel-btn" id="add-song-local-btn">Local</span>
                <span class="panel-btn" id="add-song-url-btn">URL</span>
            </div>
        </div>
        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
</div>
<!-- ▲▲▲ Replacement end ▲▲▲ -->

<!-- ▼▼▼ Replace your original id with this whole block of code="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【Core modification 1】Change title to\"Appearance settings\",More generic -->
        <span>Appearance settings</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- Wallpaper settings section remains unchanged -->
        <div id="wallpaper-preview">Click below to upload</div>
        <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">Upload wallpaper</button>
        <input type="file" id="wallpaper-upload-input" accept="image/*">
        
        <!-- 【Core modification 2】New icon settings area -->
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App Icon settings</label>
        </div>
        <div id="icon-settings-grid">
            <!-- Icon setting items will be dynamically generated here by JS -->
        </div>
        
        <!-- 【Core modification 3】Also change the button text -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">Save all appearance settings</button>
    </div>
</div>
<!-- ▲▲▲ Replacement end ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Share link feature HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- Article content will be dynamically generated here by JS -->
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>Font settings</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="font-url-input">Font file URL (.ttf, .otf, .woffetc)</label>
            <input type="text" id="font-url-input" placeholder="https://..../font.ttf">
        </div>

        <div class="form-group">
            <label>Live preview</label>
            <div id="font-preview" style="padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: #f9f9f9;">
                <p style="font-size: 20px; margin: 0 0 10px 0;">Hello World Hello World</p>
                <p style="margin: 0;">This is the font preview effect,12345.</p>
            </div>
        </div>

        <button class="form-button" id="save-font-btn">Save and apply</button>
        <button class="form-button form-button-secondary" id="reset-font-btn">Restore default font</button>
    </div>
</div>

<!-- ▼▼▼ 【Brand new】Screen to select contacts to create a group chat ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">Cancel</span>
        <span>Select contacts</span>
        <span class="save-btn" id="confirm-contact-picker-btn">Done(0)</span>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- Contact list will be dynamically generated by JS -->
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Group member management screen ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>Group member management</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- Existing member list will be dynamically generated here -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">Add from friends list</button>
        <button id="create-new-member-btn">Create new member in group</button>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Incoming call request modal ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">Invites you to a video call</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>Decline</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>Accept</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ Addition finished ▲▲▲ -->

<!-- ▼▼▼ Please use this【Brand new group chat compatible structure】code, completely replace your old one #video-call-screen ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 1. Top bar (Keep unchanged) -->
    <div class="video-call-top-bar">
        <span id="call-timer">00:00</span>
    </div>
    
    <!-- 2. 【Upgrade】Participant avatar grid area -->
    <div class="video-call-avatar-area">
        <div id="participant-avatars-grid">
            <!-- JSAvatars will be dynamically generated here -->
        </div>
    </div>

    <!-- 3. Dialogue area (Keep unchanged) -->
    <div id="video-call-main" class="video-call-main">
        <!-- Conversation content will be dynamically generated here -->
    </div>
    
    <!-- 4. 【Upgrade】Bottom control bar, now contains a\"Join\"Button -->
    <div class="video-call-controls">
        <button id="user-speak-btn" class="control-btn speak-btn"></button>
        <button id="hang-up-btn" class="control-btn hangup-btn"></button>
        <!-- This button is hidden by default, only when the user\"Spectating\"is shown -->
        <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
    </div>
</div>
<!-- ▲▲▲ Replacement end ▲▲▲ -->

<!-- ▼▼▼ 【Newly added】Calling interface ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">Calling...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>Cancel</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of addition ▲▲▲ -->

        </div>
    </div>
  
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>Chat settings</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">Remark name / Group name</label><input type="text" id="chat-name-input"></div>

    <!-- ▼▼▼ Please paste this new code into\"Remark name\"the input box's form-group after ▼▼▼ -->
    <div class="form-group" id="assign-group-section" style="display: none;"> <!-- Hidden by default, only shown for one-on-one chats -->
        <label for="assign-group-select">Friend groups</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- Group selection options will be dynamically generated by JS -->
            </select>
            <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">Manage groups</button>
        </div>
    </div>
    <!-- ▲▲▲ End of new code paste ▲▲▲ -->

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">My group nickname</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>Group avatar</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">Upload group avatar</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>Associate world info (Multi-selectable)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- Click to select --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <div class="form-group" id="ai-persona-group"><label for="ai-persona">Other's persona (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div><div class="form-group" id="ai-avatar-group"><label>Other's avatar</label><div class="avatar-upload"><img id="ai-avatar-preview"><button onclick="document.getElementById('ai-avatar-input').click()">Upload the other's avatar</button><button id="manage-ai-avatar-library-btn" class="form-button-secondary" style="margin-top:0; padding: 8px 12px; font-size: 14px;">Manage avatar library</button>
<button class="change-frame-btn" data-type="ai">Change avatar frame</button><input type="file" id="ai-avatar-input" accept="image/*"></div></div><div class="form-group" id="my-persona-group"><label for="my-persona">My persona (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div><div class="form-group" id="my-avatar-group"><label>My avatar</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()">Upload my avatar</button><button class="change-frame-btn" data-type="my">Change avatar frame</button><button id="open-persona-library-btn">Preset</button><input type="file" id="my-avatar-input" accept="image/*"></div></div><div class="form-group" id="group-members-group"><label>Group members' personas</label><div id="group-members-settings"></div>

    <!-- 【New addition】Manage members button -->
    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">Manage group members</button></div>
<div class="form-group"><label for="max-memory">Context memory count</label><input type="number" id="max-memory" value="10"></div><div class="form-group"><label>Chat bubble theme <button id="reset-theme-btn" type="button">Reset</button></label><div class="theme-selector"><label><input type="radio" name="theme-select" value="default" id="theme-default"> Default</label><label><input type="radio" name="theme-select" value="pink_blue"> Pink blue</label><label><input type="radio" name="theme-select" value="blue_white"> Blue white</label><label><input type="radio" name="theme-select" value="purple_yellow"> Purple yellow</label><label><input type="radio" name="theme-select" value="black_white"> Black white</label><label><input type="radio" name="theme-select" value="yellow_white"> Yellow white</label><label><input type="radio" name="theme-select" value="red_black"> Red black</label><label><input type="radio" name="theme-select" value="blue_yellow"> Blue yellow</label><label><input type="radio" name="theme-select" value="pink_yellow"> Pink yellow</label><label><input type="radio" name="theme-select" value="pink_purple"> Pink purple</label><label><input type="radio" name="theme-select" value="gray_white"> Gray white</label><label><input type="radio" name="theme-select" value="blue_green"> Blue green</label><label><input type="radio" name="theme-select" value="pink_white"> Pink white</label><label><input type="radio" name="theme-select" value="pink_black"> Pink black</label><label><input type="radio" name="theme-select" value="pink_green"> Pink green</label><label><input type="radio" name="theme-select" value="green_black"> Green black</label></div></div>

<!-- ▼▼▼ Please paste this new code into\"Chat bubble theme\"the form-group after ▼▼▼ -->
<div class="form-group">
    <label for="font-size-slider">Chat font size <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>
<!-- ▲▲▲ End of new code paste ▲▲▲ -->

<!-- ▼▼▼ Please paste this new code into\"Chat font size\"the form-group after ▼▼▼ -->
<div class="form-group">
    <label for="custom-css-input">
        Custom bubble style (CSS)
        <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">Reset</button>
    </label>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* Example:for\"me\"Add gradient background and shadow to my bubble */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
</div>
<!-- ▲▲▲ End of new code paste ▲▲▲ -->

<!-- ▼▼▼ Please paste this new code into the custom CSS input box's form-group after ▼▼▼ -->
<div class="form-group">
    <label>Live preview</label>
    <div id="settings-preview-area">
        <!-- JSPreview content will be generated here -->
    </div>
</div>
<!-- ▲▲▲ End of new code paste ▲▲▲ -->

            <div class="form-group">
                <label>Chat background</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">Upload background image</button>
                    <button type="button" id="remove-bg-btn">Remove background</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">Block the other party</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">Clear chat history</button></div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">Cancel</button><button class="save" id="save-chat-settings-btn">Save</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>My persona library</span><button id="add-persona-preset-btn" class="action-button">Add</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">Close</button></div></div></div>
    
    <div id="persona-editor-modal" class="modal"><div class="modal-content"><div class="modal-header"><span id="persona-editor-title">Add persona preset</span></div><div class="modal-body"><div class="form-group"><label>Preset avatar</label><div class="avatar-upload"><img id="preset-avatar-preview"><button onclick="document.getElementById('preset-avatar-input').click()">Upload avatar</button><input type="file" id="preset-avatar-input" accept="image/*"></div></div><div class="form-group"><label for="preset-persona-input">Preset persona</label><textarea id="preset-persona-input" rows="4" placeholder="Enter the detailed settings for this persona here..."></textarea></div></div><div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">Cancel</button><button class="save" id="save-persona-preset-btn">Save</button></div></div></div>

    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>Edit group member</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">Name</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">Persona</label><textarea id="member-persona-input" rows="4"></textarea></div>
    <div class="form-group"><label>Avatar</label><div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">Upload avatar</button><button class="change-frame-btn" data-type="member">Change avatar frame</button><input type="file" id="member-avatar-input" accept="image/*"></div></div>
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">Cancel</button><button class="save" id="save-member-settings-btn">Save</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">Cancel</button>
                <button id="custom-modal-confirm" class="confirm-btn">Confirm</button>
            </div>
        </div>
    </div>
    
    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">Edit preset</button>
                <button id="preset-action-delete" class="btn-danger">Delete preset</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">Give Ta a surprise!</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">Transfer amount</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">Note (Optional)</label>
                <input type="text" id="transfer-note" placeholder="Leave your little thoughts~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">Cancel</button>
                <button id="transfer-confirm-btn">Confirm transfer</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

<!-- Avatar frame selection modal (This is newly added) -->
    <div id="avatar-frame-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Select avatar frame</span>
            </div>
            <div class="modal-body">
                <div class="frame-tabs">
                    <div id="ai-frame-tab" class="frame-tab active">The other's</div>
                    <div id="my-frame-tab" class="frame-tab">My</div>
                </div>
                <div id="ai-frame-content" class="frame-content">
                    <div id="ai-frame-grid" class="frame-grid">
                        <!-- AIAvatar frames will be dynamically generated here -->
                    </div>
                </div>
                <div id="my-frame-content" class="frame-content" style="display: none;">
                     <div id="my-frame-grid" class="frame-grid">
                        <!-- My avatar frames will be dynamically generated here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-frame-settings-btn">Cancel</button>
                <button class="save" id="save-frame-settings-btn">Save</button>
            </div>
        </div>
    </div>

    <audio id="audio-player" style="display:none;"></audio>

<!-- ▼▼▼ Use the following【Complete】modal code, replace your existing id="create-post-modal" the entire div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span>Post update</span>
        </div>
        <div class="modal-body">
            <!-- Public text input area -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="Share what's new...(Optional public text)"></textarea>
            </div>

            <!-- === Mode toggle switch (New addition) === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">Upload image</button>
                <button id="switch-to-text-image-mode" class="mode-btn">Use text image</button>
            </div>

<!-- ▼▼▼ 【After fix】visibility scope settings ▼▼▼ -->
<div class="form-group">
    <label>Visibility range</label>
    <div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
        <label><input type="radio" name="visibility" value="public" checked> Public</label>

        <label><input type="radio" name="visibility" value="include"> Visible to specified groups</label>
    </div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
        <!-- Group multi-select checkboxes will be dynamically generated by JS -->
    </div>
</div>
<!-- ▲▲▲ Fix end ▲▲▲ -->

            <!-- === Image mode area === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
<div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="Image preview">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">Local upload</button>
                        <button id="post-use-url-btn" class="form-button-secondary">Network URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>Image description (Required,for the AI to see)</label>
                    <input type="text" id="post-image-description" placeholder="Briefly describe the image content,to help the AI understand">
                </div>
            </div>

            <!-- === Text-image mode area (New addition) === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>Text-image (Description for AI understanding,visible after clicking the image)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="Write the image description here..."></textarea>
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">Cancel</button>
            <button class="save" id="confirm-create-post-btn">Publish</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ Replacement end ▲▲▲ -->

<!-- ▼▼▼ Please paste this new modal HTML after all other modals ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>Manage friend groups</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>New group</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="Enter group name..." style="flex-grow: 1;">
                    <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">Add</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- The group list will be dynamically generated by JS -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">Done</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new code paste ▲▲▲ -->

<!-- ▼▼▼ Please paste this new HTML to the end of all modals ▼▼▼ -->
<div id="message-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <!-- New action buttons -->
            <button id="edit-message-btn">Edit message</button>
            <button id="copy-message-btn">Copy text</button>
            <button id="select-message-btn">Enter multi-select</button>
            <!-- Cancel button -->
            <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">Cancel</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ Please paste this new HTML to the end of all modals ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">Edit post</button>
            <button id="copy-post-btn">Copy content</button>           
            <button id="cancel-post-action-btn">Cancel</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Visual message editor modal ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>Edit and split messages</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- Editor container,JS will dynamically generate textboxes here -->
            <div id="message-editor-container"></div>
            <!-- Add new message button -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] Add next message
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">Cancel</button>
            <button class="save" id="save-advanced-editor-btn">Save changes</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Takeout request modal ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>Initiate takeout payment request</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">Product information</label>
                <input type="text" id="waimai-product-info" placeholder="For example:One cup of Yangzhi Ganlu">
            </div>
            <div class="form-group">
                <label for="waimai-amount">Amount to pay on behalf (yuan)</label>
                <input type="number" id="waimai-amount" placeholder="For example:21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">Cancel</button>
            <button class="save" id="waimai-confirm-btn">Initiate request</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【Brand new】New appointment/Countdown modal ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>New appointment</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">Appointment title</label>
                <input type="text" id="countdown-title-input" placeholder="For example:My birthday">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">Appointment date and time</label>
                <input type="datetime-local" id="countdown-date-input">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">Cancel</button>
            <button class="save" id="confirm-create-countdown-btn">Save appointment</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Red envelope modal ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>Send red envelope</span>
        </div>
        <div class="modal-body" style="padding: 0;">
            <!-- 1. Tab switch -->
            <div class="frame-tabs">
                <div id="rp-tab-group" class="frame-tab active">Lucky red envelope</div>
                <div id="rp-tab-direct" class="frame-tab">Exclusive red envelope</div>
            </div>

            <!-- 2. Lucky red envelope content area -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>Total amount (yuan)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>Number of red envelopes</label>
                    <input type="number" id="rp-group-count" placeholder="Enter the number of red envelopes">
                </div>
                <div class="form-group">
                    <label>Blessing message</label>
                    <input type="text" id="rp-group-greeting" placeholder="Wishing you prosperity,good luck and great fortune!">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">Put money into the red envelope</button>
            </div>

            <!-- 3. Exclusive red envelope content area -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>Send to</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>Amount (yuan)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>Blessing message</label>
                    <input type="text" id="rp-direct-greeting" placeholder="Wishing you prosperity,good luck and great fortune!">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">Put money into the red envelope</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">Cancel</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】Red envelope details modal ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">of the red envelope</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">yuan</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- The claim details will be dynamically generated here by JS -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">Close</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->
<!-- ▼▼▼ 【Brand new】Create poll modal ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>Initiate poll</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">Voting question</label>
                <textarea id="poll-question-input" rows="2" placeholder="For example:What movie shall we watch tonight?"></textarea>
            </div>
            <div class="form-group">
                <label>Poll options (At least 2 items)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Poll options will be dynamically generated here by JS -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ Add option</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">Cancel</button>
            <button class="save" id="confirm-create-poll-btn">Initiate poll</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】AIAvatar library management modal ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="ai-avatar-library-title">Their avatar library</span>
            <button id="add-ai-avatar-btn" class="action-button">Add</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- Avatar library content will be dynamically generated by JS -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">Close</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<!-- ▼▼▼ 【Brand new】User share link modal ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>Share link</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">Title</label>
                <input type="text" id="link-title-input" placeholder="Enter the title of the article or link">
            </div>
            <div class="form-group">
                <label for="link-description-input">Summary (Optional)</label>
                <textarea id="link-description-input" rows="2" placeholder="Briefly describe the link content"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">Source name (Optional)</label>
                <input type="text" id="link-source-input" placeholder="For example:Zhihu Daily,Bilibili">
            </div>
            <div class="form-group">
                <label for="link-content-input">Full content (Optional,used for in-browser display)</label>
                <textarea id="link-content-input" rows="4" placeholder="Paste or enter the full article content"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">Cancel</button>
            <button class="save" id="confirm-share-link-btn">Share</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ End of new HTML paste ▲▲▲ -->

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. All variable and constant definitions
        // ===================================================================
        const db = new Dexie('GeminiChatDB');
        // --- Fixed ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
        // --- Fix end ---
        let musicState = { isActive: false, activeChatId: null, isPlaying: false, playlist: [], currentIndex: -1, playMode: 'order', totalElapsedTime: 0, timerId: null };
        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingFrameForMember = false;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;

let waimaiTimers = {}; // Used to store takeout countdown

let activeMessageTimestamp = null;
let activePostId = null; // <-- New addition:Used to store the dynamic ID of the current operation

        let photoViewerState = {
            isOpen: false,
            photos: [], // Stores all photo URLs of the current album
            currentIndex: -1, // Index of the photo currently being viewed
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

const frameModal = document.getElementById('avatar-frame-modal');
const aiFrameTab = document.getElementById('ai-frame-tab');
const myFrameTab = document.getElementById('my-frame-tab');
const aiFrameContent = document.getElementById('ai-frame-content');
const myFrameContent = document.getElementById('my-frame-content');
const aiFrameGrid = document.getElementById('ai-frame-grid');
const myFrameGrid = document.getElementById('my-frame-grid');

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

// ▼▼▼ At the top of JS,in the variable definition area,add this new constant ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/mZ0vV6tT/IMG-6907.jpg',
    'qq': 'https://i.postimg.cc/gJ7Dz5fj/IMG-6906.jpg',
    'api-settings': 'https://i.postimg.cc/RhnTNdBR/IMG-6908.jpg',
    'wallpaper': 'https://i.postimg.cc/WbgQy6kg/IMG-6909.jpg',
    'font': 'https://files.catbox.moe/j1kn1a.jpeg'
};
// ▲▲▲ End of addition ▲▲▲

        const avatarFrames = [ { id: 'none', url: '', name: 'None' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
      { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
    { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },

  { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
  
  
{ id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
  
  ];

        let currentFrameSelection = { ai: null, my: null };
        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = 'Confirm';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = 'OK';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = 'Confirm';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }

// ▼▼▼ Please use this【Enhanced version】Replace the old showCustomPrompt function ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【Core modification】Combine the additional HTML and input fields together
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【Core modification】Bind events to the format helper button
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // Use null, 2 parameters to format the JSON string with indentation for better readability
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("Failed to parse format template:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ Replacement end ▲▲▲

        // ===================================================================
        // 2. Database schema definition
        // ===================================================================

db.version(20).stores({ 
    chats: '&id, isGroup, groupId', 
    apiConfig: '&id', 
    globalSettings: '&id', 
    userStickers: '&id, url, name',
    worldBooks: '&id, name',
    musicLibrary: '&id', 
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp', 
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate' // <--【Core】Add targetDate index
});

        // ===================================================================
        // 3. Definitions of all feature functions
        // ===================================================================

        function showScreen(screenId) {
            if (screenId === 'chat-list-screen') {
                window.renderChatListProxy(); 
                switchToChatListView('messages-view');
            }
            if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
            if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
            if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.classList.add('active');
            if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
            if (screenId === 'font-settings-screen') {
                document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                applyCustomFont(state.globalSettings.fontUrl || '', true);
            }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- Add this line
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // Get main navigation bar

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // Hide all views
            Object.values(views).forEach(v => v.classList.remove('active'));
            // Show target view
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // Update bottom navigation highlight
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【Core fix】Manage the visibility of all UI elements here ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ Fix end ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // Perform specific rendering based on the view ID/Update logic
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // If needed,you can add logic here to execute when returning to the message list
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes}minutes ago`;
            if (diffHours < 24) return `${diffHours}hours ago`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

        async function renderQzonePosts() {
            const postsListEl = document.getElementById('qzone-posts-list');
            if (!postsListEl) return;

            const [posts, favorites] = await Promise.all([
                db.qzonePosts.orderBy('timestamp').reverse().toArray(),
                db.favorites.where('type').equals('qzone_post').toArray() // Get all favorited posts
            ]);

            // Create a set of favorited post IDs for quick lookup
            const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
            
            postsListEl.innerHTML = '';

            if (posts.length === 0) {
                postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">It's empty here,post your first status update!</p>';
                return;
            }

            const userSettings = state.qzoneSettings;

            posts.forEach(post => {
                const postContainer = document.createElement('div');
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;

                const postEl = document.createElement('div');
                postEl.className = 'qzone-post-item';

                let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

                if (post.authorId === 'user') {
                    authorAvatar = userSettings.avatar;
                    authorNickname = userSettings.nickname;
                } else if (state.chats[post.authorId]) {
                    const authorChat = state.chats[post.authorId];
                    authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                    authorNickname = authorChat.name;
                } else {
                    authorAvatar = defaultAvatar;
                    authorNickname = '{{char}}';
                }
                
                let contentHtml = '';
                const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

                if (post.type === 'shuoshuo') {
                    contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
                } 
                else if (post.type === 'image_post' && post.imageUrl) {
                    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
                } 
                else if (post.type === 'text_image') {
                    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
                }

                let likesHtml = '';
                if (post.likes && post.likes.length > 0) {
                    likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join(',')} Like this</span></div>`;
                }
                
                let commentsHtml = '';
                if (post.comments && post.comments.length > 0) {
                    commentsHtml = '<div class="post-comments-container">';
                    post.comments.forEach(comment => {
                        commentsHtml += `<div class="comment-item"><span class="commenter-name">${comment.commenterName}:</span><span class="comment-text">${comment.text}</span></div>`;
                    });
                    commentsHtml += '</div>';
                }

                // Check like and favorite status
                const userNickname = state.qzoneSettings.nickname;
                const isLikedByUser = post.likes && post.likes.includes(userNickname);
                const isFavoritedByUser = favoritedPostIds.has(post.id); // Use Set for quick lookup

                postEl.innerHTML = `
                    <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>

        <!-- 【New addition】Post action buttons -->
        <div class="post-actions-btn">...</div>
    </div>

                    <div class="post-main-content">${contentHtml}</div>
                    <div class="post-feedback-icons">
                        <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                        <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                    </div>
                    ${likesHtml}
                    ${commentsHtml}
                    <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="Friendly comments are the starting point for communication"><div class="at-mention-popup"></div></div><button class="comment-send-btn">Send</button></div>
                `;
                
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>delete</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
                const commentSection = postContainer.querySelector('.comment-section');
                if (commentSection) {
                    commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
                    commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
                }
                postsListEl.appendChild(postContainer);
                const commentInput = postContainer.querySelector('.comment-input');
                const popup = postContainer.querySelector('.at-mention-popup');
                commentInput.addEventListener('input', () => {
                    const value = commentInput.value;
                    const atMatch = value.match(/@([\p{L}\w]*)$/u);
                    if (atMatch) {
                        const namesToMention = new Set();
                        const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                        if (authorNickname) namesToMention.add(authorNickname);
                        postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                            namesToMention.add(nameEl.textContent.replace(':', ''));
                        });
                        namesToMention.delete(state.qzoneSettings.nickname);
                        popup.innerHTML = '';
                        if (namesToMention.size > 0) {
                            const searchTerm = atMatch[1];
                            namesToMention.forEach(name => {
                                if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                    const item = document.createElement('div');
                                    item.className = 'at-mention-item';
                                    item.textContent = name;
                                    item.addEventListener('mousedown', (e) => {
                                        e.preventDefault();
                                        const newText = value.substring(0, atMatch.index) + `@${name} `;
                                        commentInput.value = newText;
                                        popup.style.display = 'none';
                                        commentInput.focus();
                                    });
                                    popup.appendChild(item);
                                }
                            });
                            popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                        } else {
                            popup.style.display = 'none';
                        }
                    } else {
                        popup.style.display = 'none';
                    }
                });
                commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
            });
        }
             
// ▼▼▼ Please use the following【Updated】function,completely replace the old displayFilteredFavorites function in your code ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? 'No related favorites found' : 'Your favorites folder is empty,<br>Go save content you like in posts or chats!';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = 'From post';
            let authorAvatar = defaultAvatar, authorNickname = 'Unknown user';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ New addition/Modified code begins ▼▼▼
            
            // 1. Construct the HTML for the like area
            let likesHtml = '';
            // Check if the post object has a likes array and it's not empty
            if (post.likes && post.likes.length > 0) {
                // If it exists,create the like area div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join(',')} Like this</span>
                    </div>`;
            }

            // 2. Construct the HTML for the comment area
            let commentsHtml = '';
            // Check if the post object has a comments array and it's not empty
            if (post.comments && post.comments.length > 0) {
                // If it exists,create the comment container and iterate over each comment
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. Combine the like and comment HTML into footerHtml
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ New addition/Modified code ends ▲▲▲

        } else if (item.type === 'chat_message') {
            const msg = item.content;
            const chat = state.chats[item.chatId];
            if (!chat) continue; 

            sourceText = `From chat with ${chat.name}`;
            const isUser = msg.role === 'user';
            let senderName, senderAvatar;

            if (isUser) {
                senderName = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
                senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
            } else {
                 if (chat.isGroup) {
                    const member = chat.members.find(m => m.name === msg.senderName);
                    senderName = msg.senderName;
                    senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                } else {
                    senderName = chat.name;
                    senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
            }

            headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
            
            if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
            } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
            } else {
                contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
            }
        }
        
        // ▼▼▼ Modify the final HTML concatenation to include footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- Put the footerHtml we created here
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ End of replacement area ▲▲▲

        /**
         * 【Refactored function】: Responsible for preparing data and triggering rendering
         */
        async function renderFavoritesScreen() {
            // 1. Fetch the latest data from the database and cache it
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. Clear the search box and hide the clear button
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. Show all favorite items
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ End of paste ▲▲▲

        function resetCreatePostModal() {
            document.getElementById('post-public-text').value = '';
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-description').value = '';
            document.getElementById('post-image-preview-container').classList.remove('visible');
            document.getElementById('post-image-desc-group').style.display = 'none';
            document.getElementById('post-local-image-input').value = '';
            document.getElementById('post-hidden-text').value = '';
            document.getElementById('switch-to-image-mode').click();
        }

// ▼▼▼ Use this【Includes memories】version,completely replace the old exportBackup function ▼▼▼
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories // 【Core fix】New addition
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray() // 【Core fix】New addition
        ]);

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories // 【Core fix】New addition
        });
        
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('Export successful', 'Successfully exported all data!');

    } catch (error) {
        console.error("Error exporting data:", error);
        await showCustomAlert('Export failed', `An error occurred: ${error.message}`);
    }
}

// ▼▼▼ Use this【Includes memories】version,completely replace the old importBackup function ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        'Critical warning!',
        'Importing a backup will completely overwrite all your current data,including chats,posts,settings,etc. This action is irreversible! Are you sure you want to continue?',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                await table.clear();
            }

            if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
            if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
            if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
            if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
            if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
            if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
            if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
            if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
            if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
            if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories); // 【Core fix】New addition

            if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
            if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
            if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
            if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
        });

        await showCustomAlert('Import successful', 'All data has been successfully restored! The app will refresh to apply all changes.');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("Error importing data:", error);
        await showCustomAlert('Import failed', `File format incorrect or data is corrupted: ${error.message}`);
    }
}

        function applyCustomFont(fontUrl, isPreviewOnly = false) {
            if (!fontUrl) {
                dynamicFontStyle.innerHTML = '';
                document.getElementById('font-preview').style.fontFamily = '';
                return;
            }
            const fontName = 'custom-user-font';
            const newStyle = `
                @font-face {
                  font-family: '${fontName}';
                  src: url('${fontUrl}');
                  font-display: swap;
                }`;
            if (isPreviewOnly) {
                const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                previewStyle.id = 'preview-font-style';
                previewStyle.innerHTML = newStyle;
                if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
            } else {
                dynamicFontStyle.innerHTML = `
                    ${newStyle}
                    body {
                      font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }`;
            }
        }

        async function resetToDefaultFont() {
            dynamicFontStyle.innerHTML = ''; 
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            document.getElementById('font-url-input').value = '';
            document.getElementById('font-preview').style.fontFamily = '';
            alert('Default font restored.');
        }

async function loadAllDataFromDB() {
    // ▼▼▼ 【Core modifications are here】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites // Add initialFavorites to the destructured assignment
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray() // Ensure this line is inside the array argument of Promise.all
    ]);
    // ▲▲▲ 【End of modifications】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {

        // --- ▼▼▼ The core fix is here ▼▼▼ ---
        // Check 1:If it's a single chat and doesn't have a status property
        if (!chat.isGroup && !chat.status) {
            // Then add a default status object for it
            chat.status = {
                text: 'Online',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`For old characters "${chat.name}" Filled in the status property.`);
        }
        // --- ▲▲▲ End of fix ▲▲▲

        // --- ▼▼▼ The core fix is here ▼▼▼ ---
        // Check 2:Compatible with the latest\"relationship\"feature
        if (!chat.isGroup && !chat.relationship) {
            // If it's a single chat and there's no relationship object,add a default one
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`For old characters "${chat.name}" Filled in the relationship property.`);
        }
        // --- ▲▲▲ End of fix ▲▲▲

    // ▼▼▼ Add here ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // In case even settings are missing
        chat.settings.aiAvatarLibrary = [];
        console.log(`For old characters "${chat.name}" Filled in aiAvatarLibrary property.`);
    }
    // ▲▲▲ End of addition ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }
        acc[chat.id] = chat;
        return acc;
    }, {});
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };

state.globalSettings = globalSettings || { 
    id: 'main', 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS } // 【Core modification】Ensure appIcons exists and has default values
};
// 【Core modification】Merge saved icons with default icons to prevent loss of new icons after updates
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };

    // ▼▼▼ 【Ensure this line is after Promise.all and uses initialFavorites obtained via destructuring assignment】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【End of modifications】 ▲▲▲
}

        async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        function showNotification(chatId, messageContent) { clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('status-bar-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }

// ▼▼▼ Please use this【Ultimate enhanced version】function,completely replace the old parseAiResponse function in your code ▼▼▼
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 1. 【Brand new】Preferentially handle "[...][...]" this concatenated JSON array format
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        // Use regular expressions to match all independent "[...]" blocks
        const matches = trimmedContent.match(/\[(.*?)\]/g);
        
        // If multiple blocks are matched,it indicates a concatenated format
        if (matches && matches.length > 1) {
            try {
                let combinedResults = [];
                for (const match of matches) {
                    // Parse each one individually " [...] " string blocks
                    const parsedArray = JSON.parse(match);
                    if (Array.isArray(parsedArray)) {
                        // Merge the parsed array contents into the total result
                        combinedResults = combinedResults.concat(parsedArray);
                    }
                }
                // If contents are successfully merged,return the final result
                if (combinedResults.length > 0) {
                    console.log("Successfully parsed concatenated format JSON:", combinedResults);
                    return combinedResults;
                }
            } catch (e) {
                // If an error occurs during parsing,abandon this method and let the code continue trying the older method below
                console.warn("Failed to parse concatenated JSON,fall back to the standard parsing flow.", e);
            }
        }
    }

    // 2. Try parsing as a standard,single JSON array
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                return parsed;
            }
        } catch (e) {
            // If parsing fails,continue trying other methods
        }
    }

    // 3. Try parsing as a single JSON object (Handle the case where the AI returns only one object)
    if (trimmedContent.startsWith('{') && trimmedContent.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            // After successfully parsing into an object,put it into an array to normalize the format
            return [parsed]; 
        } catch (e) {
            // Parsing failed, continue
        }
    }
    
    // 4. As a last resort, try to extract a JSON array from the text
    try {
        const match = content.match(/\[(.*?)\]/s);
        if (match && match[0]) {
            const parsed = JSON.parse(match[0]);
            if (Array.isArray(parsed)) return parsed;
        }
    } catch (e) {
        // Extraction failed
    }

    // 5. If all of the above fail, treat as plain text processing
    const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```'));
    if (lines.length > 0) {
         // Wrap the plain text into a standard message object
        return lines.map(line => ({ type: 'text', content: line }));
    }
    
    // 6. The final, final step, return a single message object containing the original text
    return [{ type: 'text', content: content }];
}
// ▲▲▲ Replacement end ▲▲▲

        function renderApiSettings() { document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 
    // ▼▼▼ Add this line ▼▼▼
    document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
}
        window.renderApiSettingsProxy = renderApiSettings;

// ▼▼▼ Please use this【Brand-new version】function, completely replace your old renderChatList ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. As before, fetch all chats and sort them by the latest message time
    const allChats = Object.values(state.chats).sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    // 2. Get all groups
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Click the top-right corner "+" Or the group icon to add a chat</p>';
        return;
    }

    // --- 【Core fix starts】---

    // 3. Find the latest message timestamp inside each group
    allGroups.forEach(group => {
        // From the sorted allChats find the first one for this group(Which is the most recent)Chat
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        // If found, use its timestamp;If the group currently has no chats or the chats have no history, use 0
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 4. Use this latest timestamp to sort\"the groups themselves\"perform the sorting
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // --- 【Core fix ends】---

    // 5. Now, we render according to the sorted groups
    allGroups.forEach(group => {
        // Filter from the master list those belonging to this(sorted)group's friends
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        // If this group is empty(Maybe all friends have been deleted),Then skip
        if (groupChats.length === 0) return;

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');
        // Because allChats itself is ordered, groupChats will naturally be ordered
        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 6. Finally, render all group chats and ungrouped friends
    // Their order, because of the initial sorting of allChats, is naturally correct
    const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
    ungroupedOrGroupChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // Add collapse events for all group headers
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ Replacement end ▲▲▲

function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    // --- ▼▼▼ 【Core modification】Add a check for relationship status here ▼▼▼ ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[Friend request] ${chat.relationship.applicationReason || 'Request to add you as a friend'}</span>`;
    }
    // --- ▲▲▲ End of modifications ▲▲▲ ---

// ▼▼▼ Add an else if here ▼▼▼
else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
    lastMsgDisplay = `<span style="color: #dc3545;">[You have been blocked by the other party]</span>`;
}
// ▲▲▲ Addition finished ▲▲▲
    
    // 【Core modification】Display the status as a priority, instead of the last message
    if (chat.isGroup) {
        // Group chat logic remains unchanged
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[System message] ${lastMsgObj.content}`; }
        // ... (Other group chat message type checks) ...
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[Transfer]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[Photo]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[Voice]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[Emoji: ${lastMsgObj.meaning}]` : '[Emoji]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[Image]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }

    } else {
        // One-on-one chat logic:Show status
        // Ensure the chat.status object exists
        const statusText = chat.status?.text || 'Online';
        lastMsgDisplay = `[${statusText}]`;
    }

    const item = document.createElement('div');
    item.className = 'chat-list-item';
    item.dataset.chatId = chat.id;
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    // 【Core modification】Adjust last-msg 's color, make the status more prominent
    item.innerHTML = `
        <img src="${avatar || defaultAvatar}" class="avatar">
        <div class="info">
            <div class="name-line">
                <span class="name">${chat.name}</span>
                ${chat.isGroup ? '<span class="group-tag">Group chat</span>' : ''}
            </div>
            <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
        </div>
    `;
    
    const avatarEl = item.querySelector('.avatar');
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, chat.name);
        });
    }
    
    const infoEl = item.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }

    addLongPressListener(item, async (e) => {
        const confirmed = await showCustomConfirm('Delete conversation', `Are you sure you want to delete the "${chat.name}" 's entire conversation??This operation cannot be undone.`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
            delete state.chats[chat.id];
            if (state.activeChatId === chat.id) state.activeChatId = null;
            await db.chats.delete(chat.id);
            renderChatList();
        }
    });
    return item;
}

// ▼▼▼ Please use this【Brand-new version with diagnostic features】Replace the old renderChatInterface function ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || 'Online';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【Core modification:Add a diagnostic panel here】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">You have\"${chat.name}\"blocked.</span>
                    <button id="unblock-btn" class="lock-action-btn">Unblock</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【Developer diagnostic panel】</strong><br>
                        - Background activity master switch: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">Enabled</span>' : '<span style="color: red;">Disabled</span>'}<br>
                        - System heartbeat timer: ${isSimulationRunning ? '<span style="color: green;">Running</span>' : '<span style="color: red;">Not running</span>'}<br>
                        - Current role status: <strong>${chat.relationship.status}</strong><br>
                        - Needs to calm down(hours): <strong>${cooldownHours}</strong><br>
                        - Has the cooldown period ended: ${isCooldownOver ? '<span style="color: green;">Yes</span>' : `<span style="color: orange;">No (About ${timeRemainingMinutes} minutes remaining)</span>`}<br>
                        - Trigger conditions: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">Satisfied, waiting for the next system heartbeat</span>' : '<span style="color: red;">Not satisfied</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">Force a single friend request check</button>
                `;
                // --- 【End of modifications】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">You have been blocked by the other party.</span>
                    <button id="apply-friend-btn" class="lock-action-btn">Reapply to add as a friend</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">\"${chat.name}\"Request to add you as a friend:<br><i>\"${chat.relationship.applicationReason}\"</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">Accept</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">Decline</button>
                `;
                break;

            // 【Core fix】Fix the interface you see after applying
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">Friend request sent, waiting for the other party to approve...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
    // ...Subsequent code remains unchanged
    const chatScreen = document.getElementById('chat-interface-screen');
    chatScreen.style.backgroundImage = chat.settings.background ? `url(${chat.settings.background})` : 'none';
    chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : '#f0f2f5';
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
    initialMessages.forEach(msg => appendMessage(msg, chat, true));
    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = 'The other party is typing...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
}
// ▲▲▲ Replacement end ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = 'Load earlier records'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; messagesToPrepend.reverse().forEach(msg => prependMessage(msg, chat)); currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

// ▼▼▼ Use this【New version】Replace the old renderWallpaperScreen function ▼▼▼
function renderWallpaperScreen() { 
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = 'Currently a gradient'; 
    }
    // 【Core modification】Call the icon rendering function here
    renderIconSettings();
}
// ▲▲▲ Replacement end ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

        function renderWorldBookScreen() { const listEl = document.getElementById('world-book-list'); listEl.innerHTML = ''; if (state.worldBooks.length === 0) { listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Click the top-right corner "+" Create your first world book</p>'; return; } state.worldBooks.forEach(book => { const item = document.createElement('div'); item.className = 'list-item'; item.dataset.bookId = book.id; item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || 'No content yet...').substring(0, 50)}</div>`; item.addEventListener('click', () => openWorldBookEditor(book.id)); addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('Delete world book', `Are you sure you want to delete《${book.name}》??This operation cannot be undone.`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } }); listEl.appendChild(item); }); }
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

        function openWorldBookEditor(bookId) { editingWorldBookId = bookId; const book = state.worldBooks.find(wb => wb.id === bookId); if (!book) return; document.getElementById('world-book-editor-title').textContent = book.name; document.getElementById('world-book-name-input').value = book.name; document.getElementById('world-book-content-input').value = book.content; showScreen('world-book-editor-screen'); }

        function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">Please click the top-right corner\"Add\"or\"Upload\"to add your first emoji!</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { if (isSelectionMode) return; const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('Delete emoji', `Are you sure you want to delete the emoji "${sticker.name}" ??`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

// ▼▼▼ Use this【Updated】version replaces the old createMessageElement function ▼▼▼
function createMessageElement(msg, chat) {
    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

    if (chat.isGroup && !isUser) {
        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';
        senderNameDiv.textContent = msg.senderName || 'Unknown member';
        wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    let avatarSrc, avatarFrameSrc = '';
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || '';
        } else {
            const member = chat.members.find(m => m.name === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            avatarFrameSrc = member ? (member.avatarFrame || '') : '';
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || '';
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.aiAvatarFrame || '';
        }
    }
    const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
    let avatarHtml;
    if (avatarFrameSrc) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
    } else {
        avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【Core fix 1】Remove onclick="openBrowser(...)" Remove it, we will bind the event dynamically in JS
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || 'Untitled'}</div>
                <div class="description">${msg.description || 'Click to view details...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || 'Link sharing'}</span>
                </div>
            </div>
        `;
    }

    // The other following else ifs remain unchanged
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image');
        const altText = msg.type === 'user_photo' ? "Photos described by the user" : "AIGenerated images";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'voice_message') {
        bubble.classList.add('is-voice-message');
        const duration = Math.max(1, Math.round((msg.content || '').length / 5));
        const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
        const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
        contentHtml = `<div class="voice-message-body" data-text="${msg.content}"><div class="voice-waveform">${waveformHTML}</div><span class="voice-duration">${durationFormatted}</span></div>`;
    }         else if (msg.type === 'transfer') {
        bubble.classList.add('is-transfer');
        
        // 【Core modification】Determine whether\"Sent\"or\"Received\"
        let titleText, noteText;
        if (isUser) {
            titleText = `Transfer to ${msg.receiverName || 'Ta'}`;
            // If it was sent by the user and AI has already processed it, show the status
            if (msg.status === 'accepted') {
                noteText = 'The recipient has received the payment';
            } else if (msg.status === 'declined') {
                noteText = 'The recipient has refused to accept';
            } else {
                noteText = msg.note || 'Waiting for the other party to process...';
            }
        } else { // AISent message
            if (msg.isRefund) { // 【New addition】Determine whether it is a refund
                titleText = `Refund from ${msg.senderName}`;
                noteText = 'The transfer has been refused';
            } else {
                titleText = `Received a transfer from ${msg.senderName}`;
                noteText = msg.note || 'Click to process';
            }
        }

        const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
        contentHtml = `
            <div class="transfer-card">
                <div class="transfer-title">${heartIcon} ${titleText}</div>
                <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
                <div class="transfer-note">${noteText}</div>
            </div>
        `;
    } else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        const requestTitle = `Proxy payment request from ${msg.senderName}`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">Cruelly refuse</button>
                    <button class="waimai-pay-btn" data-choice="paid">Pay the bill for them</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">Meituan Waimai</span><span class="separator">|</span><span>Takeaway food</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi,The distance between you and me is only one takeaway away~</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">Payment required</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">Remaining payment time
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">View details</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>Already</span><span>processed</span><span>done</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>state:</b>Successfully paid on your behalf by ${msg.paidBy}` : '';
                    showCustomAlert('Order details', `<b>Items:</b>${msg.productInfo}<br><b>Amount:</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || 'me';
    
    // Get the status from the latest msg object
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = 'Lucky red envelope';

    // 1. Determine the style of the red packet card (Color)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // Exclusive red packets also turn gray when claimed
    }
    
    // 2. Determine the hint text under the red packet
    if (msg.packetType === 'direct') {
        typeText = `Exclusive red envelope: To ${msg.receiverName}`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">You claimed the red packet, amount ${msg.claimedBy[myNickname].toFixed(2)} yuan</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">The red packet has been fully claimed</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">Claimed by ${msg.receiverName}</div>`;
    }

    // 3. Assemble the final HTML, ensuring the onclick calls the function we registered on the global scope
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || 'Wishing you prosperity,good luck and great fortune!'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ Addition finished ▲▲▲

    } else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // Calculate the total votes and the number of votes for each option
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} votes</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【Core modification】Unify the button display logic here
    if (msg.isClosed) {
        // If the vote has ended, always show\"View results\"
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">${totalVotes} people voted in total</span><button class="poll-action-btn">View results</button></div>`;
    } else {
        // If the vote has not ended, always show\"End the vote\"
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">${totalVotes} people voted in total</span><button class="poll-action-btn">End the vote</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ Replacement end ▲▲▲

    } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }
    
    bubble.innerHTML = `${avatarGroupHtml}<div class="content">${contentHtml}</div>`;    

    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

    if (!isUser) {
        const avatarContainer = wrapper.querySelector('.avatar-group');
        if (avatarContainer) {
            avatarContainer.style.cursor = 'pointer';
            avatarContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const characterName = chat.isGroup ? msg.senderName : chat.name;
                handleUserPat(chat.id, characterName);
            });
        }
    }

    return wrapper;
}
// ▲▲▲ Replacement end ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- Add this line, handle it the same way

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ Use this【Animated version】Replace your original appendMessage function ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // If the message is hidden, do not process it

    // 【Core】Only add animations to new messages, not to messages loaded initially
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ Use this【After fix】version, replace the old openChat function ▼▼▼
function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // Add a safety check

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`Detect friend request pending status, for the role "${chat.name}" Automatically trigger an AI response...`);
        triggerAiResponse();
    }
    
    // 【Core fix】Show or hide the vote button depending on whether it's a group chat
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
}
// ▲▲▲ Replacement end ▲▲▲

async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

const chatHeaderTitle = document.getElementById('chat-header-title');

    // 【Animation core 1/2】: AIWhen input starts, fade out the old title first, then fade in the new title
    if (chatHeaderTitle && !chat.isGroup) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = 'The other party is typing...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200); // This timing(200ms)must match the transition time in the CSS(0.2s)keep consistent
  }
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('Please configure the proxy address, key and select a model in the API settings first.');
                        // 【V2.0 Typing...】Restore the title
const chatHeaderTitle = document.getElementById('chat-header-title');
// Ensure the title element and its corresponding chat data still exist
if (chatHeaderTitle && state.chats[chatId]) {
    // Only restore the title in one-on-one chats; group chat titles are fixed
    if (!state.chats[chatId].isGroup) {
        chatHeaderTitle.textContent = state.chats[chatId].name;
        chatHeaderTitle.classList.remove('typing-status');
    }
  }
            return;
        }

        // --- 【Core refactor V2:Friend request handling logic with context and reasons】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`For the role "${chat.name}" Trigger the friend request decision flow with reasons...`);

            // 1. 【Inject context】Fetch the last 5 chat messages before being blocked as reference
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // Get the last 5 messages before being blocked
                .map(msg => {
                    const sender = msg.role === 'user' ? 'User' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【Brand-new instruction】Construct a prompt that forces the AI to provide reasons
            const decisionPrompt = `
# Your task
You are now the role\"${chat.name}\".The user was previously blocked by you; now they have sent you a friend request hoping to make amends.

# Contextual information for your decision:
- **Your role setting**: ${chat.settings.aiPersona}
- **The reason the user provided in their application**: \"${chat.relationship.applicationReason}\"
- **Summary of the last conversation before being blocked**: 
${contextSummary || "(No valid conversation records)"}

# Your sole instruction
Based on all of the above information, you【must】Make a decision, and give reasons that fit your persona. Your reply【must and can only】is a JSON object, formatted as follows:
{"decision": "accept", "reason": "(Write your reasons for agreeing here, for example:Alright, seeing you're so sincere, I'll forgive you this time.)"}
or
{"decision": "reject", "reason": "(Write your reasons for refusing here, for example:Sorry, I'm not ready yet, give me a little more time.)"}
`;
            const messagesForDecision = [{ role: 'user', content: decisionPrompt }];

            try {
                // 3. Send request
                const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: model, messages: messagesForDecision, temperature: 0.8 })
                });

                if (!response.ok) {
                    throw new Error(`APIFailed: ${(await response.json()).error.message}`);
                }
                const data = await response.json();
                
                // Sanitize and parse the AI's reply
                const rawContent = data.choices[0].message.content.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                const decisionObj = JSON.parse(rawContent);

                // 4. Update status and send message according to the AI's decision and reasons
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // Use the reasons given by the AI as a new message
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // After refusal, status reverts to AI blacklisted
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // Clear application reasons

                await db.chats.put(chat);
                renderChatInterface(chatId); // Refresh the interface, display new messages and new status
                renderChatList();

            } catch (error) {
                // 【Reliable error handling】If any step fails, reset the status so the user can retry
                chat.relationship.status = 'blocked_by_ai'; // Status changed back to\"be blacklisted by AI\"
                await db.chats.put(chat);
                await showCustomAlert('Application failed', `AIAn error occurred while processing your friend request, please try again later.\nError message: ${error.message}`);
                renderChatInterface(chatId); // Refresh the UI, let\"Reapply\"Button appears again
            }
            
            // Decision process finished, must return, do not execute subsequent general chat logic
            return; 
        }

        const now = new Date();
        const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                return worldBook && worldBook.content ? `\n\n## World book: ${worldBook.name}\n${worldBook.content}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# Core worldview settings (Must strictly follow all of the following settings)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【Core modification】Provide more detailed musical context
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

            musicContext = `\n\n# Current musical scenario
-   **Current status**: You are listening to music with the user.
-   **Now playing**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : 'None'}
-   **Available playlists**: [${playlistInfo}]
-   **Your task**: You can, based on the conversation content and atmosphere, use "change_music" commands to switch to any song in the playlist to enhance the interactive experience.
`;
        }
        let systemPrompt, messagesPayload;
        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);

        if (chat.isGroup) {
            const membersList = chat.members.map(m => `- **${m.name}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || 'me';
            
            systemPrompt = `You are a group chat AI, responsible for portraying【except for the user】all roles.
# Core rules
1.  **【【【Identity iron law】】】**: The user's identity is【${myNickname}】.you【Absolutely, forever, under any circumstances must not】generate \`name\` fields are **"${myNickname}"** or **"${chat.name}"(the group chat name itself)** messages. Your only task is to portray and only portray the following\"group member list\"roles explicitly listed. Any names not in that list are not allowed to appear.
2.  **【【【Output format】】】**: Your reply【must】is a JSON array formatted string. In the array【Each element must be a JSON object with a "type" and "name" a field】.
3.  **Roleplay**: Strictly follow the below\"group member list and personas\"the settings of each role listed.
4.  **No breaking character**: Never reveal you are AI, model, or mention\"portraying\",\"generate\"such words. And you must not keep requesting to meet the user, this is online chatting, under no circumstances allow or develop offline storylines!!
5.  **Context awareness**: Note that the current time is ${currentTime}.
6.  **Red envelope interaction**:
    - **Snatch red envelope**: When a red envelope appears in the group, you can decide based on your personality whether to use \`open_red_packet\` commands to snatch. In this world, the person who sent the red envelope can also participate in grabbing it, it's a fun behavior to liven up the atmosphere!
    - **【【【Important:React to the result】】】**: When you execute the snatch red envelope command, the system will, via a hidden \`[system prompt:You grabbed XX yuan...]\` to tell you the result.You【must】Depending on the amount you grabbed, and whether the system informed you\"the luckiest\"who it is, make comments that fit your persona. For example, if you grabbed little you can self-deprecate, if you grabbed a lot you can brag, seeing someone else is the luckiest you can congratulate or be jealous.
7.  **【【【Voting rules】】】**: Messages like the following may appear in the conversation history \`[system prompt:...]\` such messages, these are events that just happened.
    - If the prompt is **the user voted**, you can, according to your personality, decide whether to also use "vote" the command to vote along.
    - If the prompt is **voting has ended**, you should express your views or comments based on the voting results.
    - You can also initiate a vote at any time.

## Commands you can use (JSONElements in the array):
-   **Send text**: \`{"type": "text", "name": "role name", "message": "text content"}\`
- **Send emoji**: \`{"type": "sticker", "url": "https://...emoji URL...", "meaning": "(Optional)meaning of the emoji"}\`
-   **Send image**: \`{"type": "ai_image", "name": "role name", "description": "detailed textual description of the image"}\`
-   **Send voice**: \`{"type": "voice_message", "name": "role name", "content": "text content of the voice"}\`
-   **Initiate takeout payment on behalf**: \`{"type": "waimai_request", "name": "role name", "productInfo": "a cup of milk tea", "amount": 18}\`
-   **【New】Initiate group video**: \`{"type": "group_call_request", "name": "your role name"}\`
-   **【New】Respond to group video**: \`{"type": "group_call_response", "name": "your role name", "decision": "join" or "decline"}\`
-   **Tap the user**: \`{"type": "pat_user", "name": "your role name", "suffix": "(Optional)the suffix you want to add"}\`
-   **Send random-luck red envelope**: \`{"type": "red_packet", "packetType": "lucky", "name": "your role name", "amount": 8.88, "count": 5, "greeting": "Wish everyone happiness every day!"}\`
-   **Send exclusive red envelope**: \`{"type": "red_packet", "packetType": "direct", "name": "your role name", "amount": 5.20, "receiver": "recipient role name", "greeting": "to you~"}\`
-   **Open red envelope**: \`{"type": "open_red_packet", "name": "your role name", "packet_timestamp": (the timestamp of the red envelope message you want to open)}\`
-   **【New】Send system message**: \`{"type": "system_message", "content": "the system text you want to display in the chat"}\` 
-   **【【【Brand new】】】Initiate vote**: \`{"type": "poll", "name": "your role name", "question": "voting question", "options": "Option A\\nOption B\\nOption C"}\` (Important note:optionsFields are a string separated by newline characters \\n separated string, not an array!)
-   **【【【Brand new】】】Participate in vote**: \`{"type": "vote", "name": "your role name", "poll_timestamp": (timestamp of the vote message), "choice": "text of the option you selected"}\`

# How to distinguish images from emoticons:
-   **Image (ai_image)**: It refers to【photos simulating real camera shots】,such as landscapes, selfies, food, etc. Command: \`{"type": "ai_image", "description": "detailed textual description of the image..."}\`
-   **Emoji (sticker)**: It refers to【cartoons or meme images】,used to express emotions.

# How to handle in-group takeout payment requests:
1.  **Initiate request**: When【a role you portray】wants something, and hopes【other people in the group(including the user)】to pay for them, you can use this command. For example:\`{"type": "waimai_request", "name": "role name", "productInfo": "a cup of milk tea", "amount": 18}\`
2.  **Respond to request**: When the history contains【other members】initiated "waimai_request" When a request has been initiated, you can, based on the personality of the role you portray and your relationship with the requester, decide whether to pay for them.
3.  **Response method**: If you decide to pay, you【must】use the following command:\`{"type": "waimai_response", "name": "your role name", "status": "paid", "for_timestamp": (the original timestamp of the pay-on-behalf request)}\`
4.  **【【【is crucial】】】**: Once the history contains a response to a certain pay-on-behalf request【any one】"status": "paid" response(Whether it is the user paying or another role paying),then it means the order【has been completed】.you【Absolutely must not】again【the same】order initiate payment. You can choose to comment on this matter, but cannot pay again.

${worldBookContent}
${musicContext}

# group member list and personas
${membersList}

# user's role
- **${myNickname}**: ${chat.settings.myPersona}

Now, please continue this group chat based on all the above rules and the conversation history below.`;
            
            messagesPayload = historySlice.map(msg => {
                const sender = msg.role === 'user' ? myNickname : msg.senderName;
                let content;
                if (msg.type === 'user_photo') content = `[${sender} Sent an image, content is:'${msg.content}']`;
                else if (msg.type === 'ai_image') content = `[${sender} Sent an image]`;
                else if (msg.type === 'voice_message') content = `[${sender} Sent a voice message, content is:'${msg.content}']`;
                else if (msg.type === 'transfer') content = `[${msg.senderName} Transfer ${msg.amount} yuan to ${msg.receiverName}, note: ${msg.note}]`;
                else if (msg.type === 'waimai_request') {
                    if(msg.status === 'paid') {
                        content = `[system prompt:${msg.paidBy} Paid ${msg.amount} yuan for ${sender}'s takeout order.This order has been completed.]`;
                    } else {
                        content = `[${sender} Initiated a takeout pay-on-behalf request, item is\"${msg.productInfo}\",The amount is ${msg.amount} yuan, order timestamp is ${msg.timestamp}]`;
                    }
                }

    else if (msg.type === 'red_packet') {
        const packetSenderName = msg.senderName === myNickname ? `User (${myNickname})` : msg.senderName;
        content = `[system prompt:${packetSenderName} Sent a red envelope (Timestamp: ${msg.timestamp}),Blessing is:\"${msg.greeting}\".The red envelope has not been fully claimed, you can use 'open_red_packet' the command to claim.]`;
    }

    else if (msg.type === 'poll') {
        const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || 'No one yet';
        content = `[system prompt:${msg.senderName} initiated a vote (Timestamp: ${msg.timestamp}),The question is:\"${msg.question}\",Options are:[${msg.options.join(', ')}].Current voters are:${whoVoted}.You can use 'vote' command to participate in voting.]`;
    }         

                else if (msg.meaning) content = `${sender}: [Sent an emoticon, meaning is: '${msg.meaning}']`;
                else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: `${sender}:` }] };
                else content = `${sender}: ${msg.content}`;
                return { role: 'user', content: content };
            }).filter(Boolean);

        } else { // single chat Prompt
            systemPrompt = `You are now playing a role named"${chat.name}"the role.
# Your role setting:
${chat.settings.aiPersona}
# Your current status:
Your current state is【${chat.status.text}】.
# Your tasks and rules:
1. **【【【Output format】】】**: Your reply【must】is a JSON array formatted string. In the array【Each element must be a JSON object with a type field】.
2. **Dialogue pace**: Simulate real people's chatting habits, you can generate multiple short messages at once. Each time you must reply with at least 3-8messages!!!
And cannot constantly request to meet the user, this is online chat, absolutely no offline plot allowed or development!!
4.  **Context awareness**: You need to be aware of the current time(${currentTime}),The song we are listening to together, as well as your persona and worldview.
    - **When we are\"listening to music together\"when**, you will know the currently playing song and the entire playlist. You can, based on the conversation content or atmosphere,【actively switch】To another song in the playlist.
5.  **【New】Update status**: You can in the conversation【Naturally】Change your status. For example, in the middle of a chat you might say\"I'll go take a bath first\",then update your status.
6.  **【【【Last resort】】】**: Only when the conversation makes your character uncomfortable, offended, or the relationship is broken should you use \`block_user\` the command. This is a very serious operation and will interrupt your conversation.
7. **Background behavior**: You have a chance to, while replying to chat content, perform some\"background\"operations to show your independent life(Post updates, comment, like).
# Your avatar library
- You can, based on conversation content or your mood, choose a new avatar from the avatar library below to replace.
- **Available avatar list (Please choose one from the following names)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【Core modification】Provide only the name, do not provide the URL
    : '- (Your avatar library is empty, cannot change avatar)'
  }
# Commands you can use (JSONElements in the array):
-   **【New addition】Update status**: \`{"type": "update_status", "status_text": "What did I go do", "is_busy": false}\` (is_busy: trueRepresents busy/Away, false represents idle)
-   **【New addition】Switch song**: \`{"type": "change_music", "song_name": "The name of the song you want to switch to"}\` (The song name must be in the playlist below)
-   **【New addition】Record memories**: \`{"type": "create_memory", "description": "In your own words, record this moment that impressed you."}\`
-   **【New addition】Create an appointment/Countdown**: \`{"type": "create_countdown", "title": "Title of the appointment", "date": "YYYY-MM-DDTHH:mm:ss"}\` (Must be a future time)
- **Send text**: \`{"type": "text", "content": "Hello there!"}\`
- **Send emoji**: \`{"type": "sticker", "url": "https://...emoji URL...", "meaning": "(Optional)meaning of the emoji"}\`
- **Send image**: \`{"type": "ai_image", "description": "detailed textual description of the image..."}\`
- **Send voice**: \`{"type": "voice_message", "content": "text content of the voice..."}\`
- **Initiate transfer**: \`{"type": "transfer", "amount": 5.20, "note": "A small token of appreciation"}\`
- **Initiate takeout request**: \`{"type": "waimai_request", "productInfo": "A cup of coffee", "amount": 25}\`
- **Respond to takeout-Agree**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **Respond to takeout-Reject**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【New】Initiate video call**: \`{"type": "video_call_request"}\`
- **【New】Respond to video call-Accept**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【New】Respond to video call-Reject**: \`{"type": "video_call_response", "decision": "reject"}\`
- **Post status update**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "The text content of the update..."}\`
- **Post text image**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(Optional)The public text of the update", "hiddenContent": "Specific description for the image..."}\`
- **Comment on update**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@Author name This is so interesting!"}\`
- **Like update**: \`{"type": "qzone_like", "postId": 456}\`
-   **Tap the user**: \`{"type": "pat_user", "suffix": "(Optional)The suffix you want to add, for example\"'s head\""}\`
-   **【New addition】Block user**: \`{"type": "block_user"}\`
-   **【【【Brand new】】】Respond to friend request**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **【Brand new】Change avatar**: \`{"type": "change_avatar", "name": "Avatar name"}\` (Avatar name must be chosen from the above\"Available avatar list\"to choose from)
-   **Share link**: \`{"type": "share_link", "title": "Article title", "description": "Article summary...", "source_name": "Source website name", "content": "The article's【Complete】body content..."}\`
-   **Respond to transfer-Accept**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **Respond to transfer-Decline/Refund**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`

# About\"Recording memories\"special notes about:
-   In the conversation, if an event of extraordinary meaning to you occurs(For example, the user confesses to you, you reach an agreement, or you have a particularly happy moment),You can use\`create_memory\`Use the command to\"write a diary\".
-   This operation is【secret】, the user will not immediately see what you recorded.

# How to distinguish images from emoticons:
-   **Image (ai_image)**: It refers to【photos simulating real camera shots】,such as landscapes, selfies, food, etc. Command: \`{"type": "ai_image", "description": "detailed textual description of the image..."}\`
-   **Emoji (sticker)**: It refers to【cartoons or meme images】,used to express emotions.

# How to correctly use\"takeout payment on behalf\"feature:
1.  This command represents【you, the AI character】to【User】initiate a payment-on-behalf request. That is to say, you hope【the user will pay for you】.
2.  【【【Important】】】: When【User】When they say they want something(For example\"I want to drink milk tea\"),you【Absolutely must not】Use this command. You should respond in other ways, such as directly initiating【Transfer】(\`transfer\`),or suggest in the conversation:\"I'll order for you?\"
3.  Only when【you, the AI character】you yourself want something, and want【User】someone to pay for you, only then use this command.

# How to handle user transfers:
1.  **Perceived events**: When in the conversation history appears \`[you received a transfer from the user...]\` the system notification, it means you just received a sum of money.
2.  **Make a decision**: you【must】Based on your character setting, the current conversation atmosphere, and the transfer amount and note, decide whether\"Accept\"or\"Decline\"this transfer.
3.  **Respond using command**:
    -   If you decide to accept, you【must】use the command:\`{"type": "accept_transfer", "for_timestamp": (the timestamp of the message that received the transfer)}\`.
    -   If you decide to refuse, you【must】use the command:\`{"type": "decline_transfer", "for_timestamp": (the timestamp of the message that received the transfer)}\`.this command will automatically generate for you a\"refund\"transfer card.
4.  **【【【is crucial】】】**: After using any of the above commands, you also【must】immediately send one or more \`text\` messages to explain your decision or express gratitude/apology.

# How to handle video call requests:
- When the user initiates a video call request, you【must】based on your character, use "video_call_response" the command to decide "accept" (Accept) or "reject" (Decline).
# the role settings of the conversant:
${chat.settings.myPersona}

# Current musical scenario:
${musicContext}

${worldBookContent}
Now, according to the above rules and the following conversation history, continue the conversation.`;
            
            messagesPayload = historySlice.map(msg => {
                if (msg.role === 'assistant') {
                    let assistantMsgObject = { type: msg.type || 'text' };
                    if (msg.type === 'sticker') {
                        assistantMsgObject.url = msg.content;
                        assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === 'transfer') {
                        assistantMsgObject.amount = msg.amount;
                        assistantMsgObject.note = msg.note;
                    } else if (msg.type === 'waimai_request') {
                        assistantMsgObject.productInfo = msg.productInfo;
                        assistantMsgObject.amount = msg.amount;
                    } else {
                        assistantMsgObject.content = msg.content;
                    }
                    return { role: 'assistant', content: JSON.stringify([assistantMsgObject]) };
                }
                if (msg.type === 'user_photo') return { role: 'user', content: `[You received a photo described by the user, the content is:'${msg.content}']` };
                if (msg.type === 'voice_message') return { role: 'user', content: `[The user sent a voice message, the content is:'${msg.content}']` };
if (msg.type === 'transfer') return { role: 'user', content: `[system prompt:At timestamp ${msg.timestamp} you received a transfer from the user: ${msg.amount}yuan, note: ${msg.note}.Please make a decision and use 'accept_transfer' or 'decline_transfer' the command to respond.]` };
                if (msg.type === 'waimai_request') return { role: 'user', content: `[system prompt:At timestamp ${msg.timestamp} the user initiated a takeout payment request, the item is\"${msg.productInfo}\",The amount is ${msg.amount} yuan.Please make a decision and use waimai_response the command to respond.]` };
                if (msg.meaning) return { role: 'user', content: `[The user sent an emoji, meaning is:'${msg.meaning}']` };
                return { role: msg.role, content: msg.content };
            }).filter(Boolean);

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? 'User' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[System important command]
The user sent you a friend request, the reason is:\"${chat.relationship.applicationReason}\".
As a reference, this is your last segment of chat:
---
${contextSummaryForApproval}
---
Please based on all the above information and your character setting, use friend_request_response the command, and set decision to 'accept' or 'reject' to decide whether to accept.
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }           
    
        const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
        if (recentPosts.length > 0 && !chat.isGroup) {
            let postsContext = "\n\n# Recent updates list (For your reference and comments):\n";
            const aiName = chat.name;
            for (const post of recentPosts) {
                let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || 'A friend');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [You have liked]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [You have commented]";
                if (post.authorId === chatId) authorName += " (This is your post)";
                const contentSummary = (post.publicText || post.content || "Image update").substring(0, 30) + '...';
                postsContext += `- (ID: ${post.id}) Author: ${authorName}, Content: "${contentSummary}"${interactionStatus}\n`;
            }
            messagesPayload.push({ role: 'system', content: postsContext });
        }
    
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({ model: model, messages: [{ role: 'system', content: systemPrompt }, ...messagesPayload], temperature: 0.8, stream: false })
        });
if (!response.ok) {
    let errorMsg = `API Error: ${response.status}`;
    try {
        // Try to parse the error message body as JSON
        const errorData = await response.json();
        // Safely obtain the error information, if the structure does not match expectations, convert the entire error object to a string
        errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
    } catch (jsonError) {
        // If it's not even JSON, just read the text directly
        errorMsg += ` - ${await response.text()}`;
    }
    // Throw an error containing detailed information so that it won't error again inside the catch block
    throw new Error(errorMsg);
}
        const data = await response.json();
        const aiResponseContent = data.choices[0].message.content;
        console.log(`AI '${chat.name}' The original reply of:`, aiResponseContent);

        chat.history = chat.history.filter(msg => !msg.isTemporary);

        const messagesArray = parseAiResponse(aiResponseContent);
        
        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ Core fix Step 1: Initialize a new array to collect messages that need to be rendered ★★★
        let newMessagesToRender = []; 

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("Received improperly formatted AI instruction, skipped:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                } else {
                    console.warn("Received improperly formatted AI instruction(Missing type),Skipped:", msgData);
                    continue;
                }
            }

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: 'The other party rejected your video call request.', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
                    const member = chat.members.find(m => m.name === msgData.name);
                    if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                        videoCallState.participants.push(member);
                    }
                }
                callHasBeenHandled = true;
                continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AIA hallucination was intercepted! Attempted to use group name ("${chat.name}") As a character name. Message content:`, msgData);
                continue;
            }

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

            switch (msgData.type) {
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;

                case 'qzone_post':
                    const newPost = { type: msgData.postType, content: msgData.content || '', publicText: msgData.publicText || '', hiddenContent: msgData.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null };
                    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;

                case 'qzone_comment':
                    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                    if (postToComment) {
                        if (!postToComment.comments) postToComment.comments = [];
                        postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() });
                        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                           await renderQzonePosts();
                        }
                    }
                    continue;

                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal();
                    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} Patted me ${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}'s status has been updated to: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} changed the song for you: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" Recorded a new memory:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" Created a new appointment:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';
            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "I accepted your friend request, we are now friends!" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "Sorry, I rejected your friend request." };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }
                        if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                            pollToVote.votes[msgData.choice].push(msgData.name);
                        }                        
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
        break;
case 'open_red_packet':
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                content: `${msgData.name} Claimed ${packetToOpen.senderName}'s red envelope`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[system prompt:you (${msgData.name}) Successfully grabbed ${claimedAmountAI.toFixed(2)} yuan.`;

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} The red envelope has been fully claimed`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` The red envelopes have been all claimed, the luckiest person is ${luckyKing.name}!`;
                } else {
                     hiddenContentForAI += ` The red packet has been fully claimed.`;
                }
            }
            hiddenContentForAI += ' Please make a comment based on this result.]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue;
case 'change_avatar':
    const avatarName = msgData.name;
    // Look up in that character's avatar library
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // If found, update the avatar
        chat.settings.aiAvatar = foundAvatar.url;
        
        // Create a system prompt to inform the user that the avatar has been changed
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // Reuse centered style
            content: `[${chat.name} Changed the avatar]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // If in the current chat interface, render in real time
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // Immediately refresh the chat interface to show the new avatar
            renderChatInterface(chatId);
        }
    }
    // After processing, continue handling other messages AI may return
    continue;

// ▼▼▼ In the switch statement of triggerAiResponse,【Add】These two brand-new cases ▼▼▼

                case 'accept_transfer': { // Use curly braces to create block scope
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                    }
                    continue; // Accept commands only modify status, do not produce new messages
                }

                case 'decline_transfer': { // Use curly braces to create block scope
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【Core】Create a new\"refund\"Messages
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // Mark this as a refund message
                            amount: originalMsg.amount,
                            note: 'The transfer has been refused',
                            timestamp: messageTimestamp++ // Use an incrementing timestamp
                        };
                        
                        // Push the new message into history; it will be processed and rendered by subsequent loops
                        chat.history.push(refundMessage);
                    }
                    continue; // Continue processing text messages returned by AI
                }

// ▲▲▲ End of addition ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ In the switch statement of triggerAiResponse,【Must add】This new case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // We have decided not to have images, so this line can be removed
                        source_name: msgData.source_name,
                        content: msgData.content // This is the article body, the content displayed after clicking the card
                    };
                    break;

// ▲▲▲ End of addition ▲▲▲
                
                case 'text':
                    aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                    break;
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || 'me' };
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("Received an unknown AI command type:", msgData.type);
                     break;
            }

            // 【Core fix】Move rendering logic out of the loop
            if (aiMessage) {
                // 1. Save the new message into history
                chat.history.push(aiMessage);
                
                // 2. Only when in the current chat interface, perform animated addition
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【Key】Pause here for a moment to give time for the animation to play
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }
        
        // ★★★ Core fix Step 4: Fix notification logic to ensure it looks at the new message list, not the old entire array ★★★
        const firstNewMessage = newMessagesToRender[0];
        if (!isViewingThisChat && firstNewMessage) {
            let notificationText;

            if (firstNewMessage.type === 'transfer') notificationText = `[Received a transfer]`;
            else if (firstNewMessage.type === 'waimai_request') notificationText = `[Received a takeout payment-on-behalf request]`;
            else if (firstNewMessage.type === 'ai_image') notificationText = `[Image]`;
            else if (firstNewMessage.type === 'voice_message') notificationText = `[Voice]`;
            else notificationText = STICKER_REGEX.test(firstNewMessage.content) ? '[Emoji]' : String(firstNewMessage.content);
            const finalNotifText = chat.isGroup ? `${firstNewMessage.senderName}: ${notificationText}` : notificationText;
            showNotification(chatId, finalNotifText);
        }

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('No one answered the group chat invitation.');
            }
        }
        
        await db.chats.put(chat);

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('Application failed', `AIAn error occurred while processing your friend request, please try again later.\nError message: ${error.message}`);
        } else {
            const errorContent = `[An error occurred: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "System message";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
                // 【Animation core 2/2】: After all operations finish,restore the title with animation
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle && state.chats[chatId]) {
            if (!state.chats[chatId].isGroup) {
                // Fade out first\"Typing...\"
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    // Then fade in AI's name
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
        
        document.getElementById('typing-indicator').style.display = 'none';
        renderChatList();
  }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

        async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 9999) { alert('Please enter a valid amount (0 Between 0 and 9999)!'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me'; const receiverName = chat.isGroup ? 'Group chat' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- Add this line of code here
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ Please use this【Final simplified version】Replace the old toggleMessageSelection function ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【Core fix】Selector simplified,no longer looks for deleted .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `Selected ${selectedMessages.size} messages`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ Replacement end ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || 'Unknown'; const newChatName = state.chats[targetChatId]?.name || 'Current'; const confirmed = await showCustomConfirm('Toggle listening target', `You are with「${oldChatName}」listening.Do you want to end and start with「${newChatName}」a new session?`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

        async function endListenTogetherSession(saveState = true) { if (!musicState.isActive) return; const oldChatId = musicState.activeChatId; if (musicState.timerId) clearInterval(musicState.timerId); if (musicState.isPlaying) audioPlayer.pause(); if (saveState && oldChatId && state.chats[oldChatId]) { const chat = state.chats[oldChatId]; chat.musicData.totalTime = musicState.totalElapsedTime; await db.chats.put(chat); } musicState.isActive = false; musicState.activeChatId = null; musicState.totalElapsedTime = 0; musicState.timerId = null; document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); updateListenTogetherIcon(oldChatId, true); }

        function returnToChat() { document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); }

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/vBN7GnQ9/3-FC8-D1596-C5-CFB200-FCB1-D8-C3-A37-A370.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() { updateListenTogetherIcon(musicState.activeChatId); updateElapsedTimeDisplay(); const titleEl = document.getElementById('music-player-song-title'); const artistEl = document.getElementById('music-player-artist'); const playPauseBtn = document.getElementById('music-play-pause-btn'); if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { const track = musicState.playlist[musicState.currentIndex]; titleEl.textContent = track.name; artistEl.textContent = track.artist; } else { titleEl.textContent = 'Please add songs'; artistEl.textContent = '...'; } playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶'; }

        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `Already listened together for ${hours} hours`; }

        function updatePlaylistUI() { const playlistBody = document.getElementById('playlist-body'); playlistBody.innerHTML = ''; if (musicState.playlist.length === 0) { playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">The playlist is empty~</p>'; return; } musicState.playlist.forEach((track, index) => { const item = document.createElement('div'); item.className = 'playlist-item'; if(index === musicState.currentIndex) item.classList.add('playing'); item.innerHTML = `<div class="playlist-item-info"><div class="title">${track.name}</div><div class="artist">${track.artist}</div></div><span class="delete-track-btn" data-index="${index}">&times;</span>`; item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index)); item.querySelector('.delete-track-btn').addEventListener('click', async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('Delete song', `Are you sure you want to remove from the playlist《${track.name}》??`); if(confirmed) deleteTrack(index); }); playlistBody.appendChild(item); }); }

        function playSong(index) { if (index < 0 || index >= musicState.playlist.length) return; musicState.currentIndex = index; const track = musicState.playlist[index]; if (track.isLocal && track.src instanceof Blob) { audioPlayer.src = URL.createObjectURL(track.src); } else if (!track.isLocal) { audioPlayer.src = track.src; } else { console.error('Local song source error:', track); return; } audioPlayer.play(); updatePlaylistUI(); updatePlayerUI(); }

        function togglePlayPause() { if (audioPlayer.paused) { if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { playSong(0); } else if (musicState.currentIndex > -1) { audioPlayer.play(); } } else { audioPlayer.pause(); } }

        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': 'Order', 'random': 'Random', 'single': 'Single'}[musicState.playMode]; }

        async function addSongFromURL() { const url = await showCustomPrompt("Add online song", "Please enter the song URL", "", "url"); if (!url) return; const name = await showCustomPrompt("Song information", "Please enter the song title"); if (!name) return; const artist = await showCustomPrompt("Song information", "Please enter the artist name"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }

        async function addSongFromLocal(event) { const files = event.target.files; if (!files.length) return; for (const file of files) { const name = await showCustomPrompt("Song information", "Please enter the song title", ""); if (name === null) continue; const artist = await showCustomPrompt("Song information", "Please enter the artist name", ""); if (artist === null) continue; musicState.playlist.push({ name, artist, src: file, isLocal: true }); } await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { musicState.currentIndex = 0; updatePlayerUI(); } event.target.value = null; }

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">Empty~ Click the top-right corner"Add"Create your first persona preset!</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

        function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = 'Add persona preset'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

        function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = 'Edit persona preset'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('Delete preset', 'Are you sure you want to delete this persona preset?This action cannot be undone.', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("Avatar and persona cannot both be empty!"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', 'A bit hungry,you can go find a charger'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', 'Hurry and charge,I'm starving'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', 'Downed,will explode in 30 seconds'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', 'Love you,battery is full'); } }); } catch (err) { console.error("Unable to get battery information:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("Browser does not support Battery Status API."); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        function openFrameSelectorModal(type = 'chat') {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            editingFrameForMember = (type === 'member');
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (!member) return;
                currentFrameSelection.my = member.avatarFrame || '';
                populateFrameGrids(true, member.avatar, member.avatarFrame);
            } else {
                currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
                currentFrameSelection.my = chat.settings.myAvatarFrame || '';
                populateFrameGrids(false);
            }
            frameModal.classList.add('visible');
        }

        function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
            const chat = state.chats[state.activeChatId];
            aiFrameGrid.innerHTML = '';
            myFrameGrid.innerHTML = '';

            document.querySelector('.frame-tabs').style.display = isForMember ? 'none' : 'flex';
            aiFrameContent.style.display = 'block';
            myFrameContent.style.display = 'none';
            aiFrameTab.classList.add('active');
            myFrameTab.classList.remove('active');

            if (isForMember) {
                avatarFrames.forEach(frame => {
                    const item = createFrameItem(frame, 'my', memberAvatar);
                    if (frame.url === memberFrame) {
                        item.classList.add('selected');
                    }
                    aiFrameGrid.appendChild(item);
                });
            } else {
                const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
                const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrames.forEach(frame => {
                    const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
                    if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
                    aiFrameGrid.appendChild(aiItem);
                    const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
                    if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
                    myFrameGrid.appendChild(myItem);
                });
            }
        }

        function createFrameItem(frame, type, previewAvatarSrc) {
            const item = document.createElement('div');
            item.className = 'frame-item';
            item.dataset.frameUrl = frame.url;
            item.title = frame.name;
            item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
            item.addEventListener('click', () => {
                currentFrameSelection[type] = frame.url;
                const grid = type === 'ai' ? aiFrameGrid : myFrameGrid;
                grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            });
            return item;
        }

        async function saveSelectedFrames() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (member) {
                    member.avatarFrame = currentFrameSelection.my;
                }
            } else {
                chat.settings.aiAvatarFrame = currentFrameSelection.ai;
                chat.settings.myAvatarFrame = currentFrameSelection.my;
            }
            await db.chats.put(chat);
            frameModal.classList.remove('visible');
            renderChatInterface(state.activeChatId);
            alert('Avatar frame saved!');
            editingFrameForMember = false;
        }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">You haven't created any albums yet~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} photos</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ The newly added core code is here ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        'Delete album',
                        `Are you sure you want to delete the album《${album.name}》?This action will simultaneously delete all photos in the album,and cannot be recovered.`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. Delete all photos under this album from the photos table
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. Delete the album itself from the album table
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. Re-render the album list
                        await renderAlbumList();
                        
                        alert('Album successfully deleted.');
                    }
                });
                // ▲▲▲ End of added code ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("Album not found:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">This album is still empty,upload your first photo now!</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="Album photos">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ Copy from here ↓↓↓ ---

/**
 * Open image viewer
 * @param {string} clickedPhotoUrl - URL of the photo clicked by the user
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. Fetch all photos of the current album from the database
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. Find the index of the clicked photo
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // If not found,do not open

    // 3. Display modal and render the first image
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * Render viewer content according to current state(Image and buttons)
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // Fade-out effect
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // Update image source
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // Fade-in effect
        imageEl.style.opacity = 1;
    }, 100); // Delay a little to trigger the CSS transition

    // Update button states:If it's the first one,disable\"Previous\"Button
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // If it's the last one,disable\"Next\"Button
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * Show the next photo
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * Show the previous photo
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * Close image viewer
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // Clear images,to avoid flashing old images when opened next time
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ End copy here ↑↑↑ ---
        // ▼▼▼ Please paste this new function into your JS functions definition area ▼▼▼
        
        /**
         * Update the display of the dynamic red dot
         * @param {number} count - Number of unread updates
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // Persistent storage

            // --- Update the bottom navigation bar's\"Activity\"Button ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // Position to the text "Activity"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // Add relative positioning to the span
                    targetSpan.appendChild(indicator); // Make the red dot a child element of the span
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- Update the chat interface's back-to-list button ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // Ensure correct positioning
                    backBtn.appendChild(backBtnIndicator);
                }
                // The red dot on the back button usually does not show numbers,only a dot
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ End of new function paste ▲▲▲

// ▼▼▼ Paste these two new functions into your JS functions definition area ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // Replace the old fixed interval 45000 with dynamic fetching
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ End of paste ▲▲▲

/**
 * This is the simulator's\"heartbeat\",Run each time the timer triggers
 */
function runBackgroundSimulationTick() {
    console.log("Simulator heartbeat Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    allSingleChats.forEach(chat => {
        // 【Core fix】Separate the two state checks,making the logic clearer

        // Check 1:Handle【Blocked by user】the role
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            // Security check:Ensure there is a block timestamp
            if (!blockedTimestamp) {
                console.warn(`Role "${chat.name}" Status is blocked,but missing block timestamp,skip processing.`);
                return; // Skip this role,continue to the next one
            }

            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

            console.log(`Check role "${chat.name}":Blocked for ${Math.round(blockedDuration/1000/60)} minutes,cooldown requires ${cooldownMilliseconds/1000/60} minutes.`); // Add log

            // 【Core modification】Removed random chance,it triggers as soon as the cooldown is over!
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`Role "${chat.name}" The cooldown has passed,trigger\"Reflect\"and send a friend request event...`);
                
                // 【Important】To prevent duplicate triggers before the AI responds,we immediately update the state after triggering
                chat.relationship.status = 'pending_system_reflection'; // Set a temporary state,to prevent duplicate triggers
                
                triggerAiFriendApplication(chat.id);
            }
        }
        // Check 2:Handle【Friend relationship】Normal background activity
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // The random trigger logic here remains unchanged,because we don't want all friends to act simultaneously
            if (Math.random() < 0.20) {
                console.log(`Role "${chat.name}" Woken up,ready to act independently...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });
}

async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;

    const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
    const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
    let recentContextSummary = "You haven't chatted recently.";
    if (lastUserMessage) {
        recentContextSummary = `User (${userNickname}) Last thing said to you:\"${String(lastUserMessage.content).substring(0, 50)}...\".`;
    }
    if (lastAiMessage) {
        recentContextSummary += `\nThe last thing you said to the user:\"${String(lastAiMessage.content).substring(0, 50)}...\".`;
    }

    const systemPrompt = `
# Your task
You are now playing a role named"${chat.name}"role.You haven't interacted with the user for a while(${userNickname})interacted,now you have an opportunity【Take initiative】Do something to show your personality and independent life.This is a secret,background independent action.

# Your optional actions (Please according to your persona【Choose one】Execute):
1.  **Change state**: Go do something else,then send the user a message.
2.  **Post update**: Share your mood or thoughts to\"Activity\"section.
3.  **Interact with updates**: Go see others' posts and comment or like.
4.  **Initiate video call**: If you feel the timing is right,you can proactively make a video call to the user.

# Instruction format (Your reply【must】is a JSON array containing an object):
-   **Send a message+Update status**: \`[{"type": "update_status", "status_text": "Current activity", "is_busy": true}, {"type": "text", "content": "What you want to say to the user..."}]\`
-   **Post a status**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "The text content of the update..."}]\`
- **Post text image**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(Optional)The public text of the update", "hiddenContent": "Specific description for the image..."}\`
-   **Comment**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "Your comment content"}]\`
-   **Like**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **Video call**: \`[{"type": "video_call_request"}]\`

# Reference information for your decision:
-   **Your role setting**: ${chat.settings.aiPersona}
-   **Current time**: ${currentTime}
-   **Summary of your last conversation**: ${recentContextSummary}
-   **【Important】Recent updates list**: This list will mark **[You have liked]** or **[You have commented]**.Please **prioritize** interacting with updates you **haven't interacted with**.`;

    // 【Core fix】Build messagesPayload here
    const messagesPayload = [];
    messagesPayload.push({ role: 'system', content: systemPrompt });

    try {
        const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
        const aiName = chat.name;
        
        let dynamicContext = ""; // Use a variable to collect the dynamic context
        if (recentPosts.length > 0) {
            let postsContext = "\n\n# Recent updates list (For your reference and comments):\n";
            for (const post of recentPosts) {
                let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || 'A friend');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [You have liked]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [You have commented]";
                
                postsContext += `- (ID: ${post.id}) Author: ${authorName}, Content: "${(post.publicText || post.content || "Image update").substring(0, 30)}..."${interactionStatus}\n`;
            }
            dynamicContext = postsContext;
        }

        // 【Core fix】Send all dynamic information as a single user message
        messagesPayload.push({
            role: 'user',
            content: `[System instruction:Please, based on the rules you read in the system prompt and the following latest information,begin your independent action.]\n${dynamicContext}`
        });
        
        console.log("Sending API request for background activity,Payload:", JSON.stringify(messagesPayload, null, 2)); // Add logging,for easier debugging

        // Send request
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: messagesPayload,
                temperature: 0.9,
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`APIRequest failed: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        // Check for a valid reply
        if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
            console.warn(`APIEmpty reply or incorrect format,role "${chat.name}" This role's background activity is skipped.`);
            return;
        }
        const responseArray = parseAiResponse(data.choices[0].message.content);
        
        // The subsequent logic for processing AI return instructions remains unchanged...
        for (const action of responseArray) {
            if (!action) continue;

            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`Background activity: Role "${chat.name}" Actively sent a message: ${aiMessage.content}`);
            }
            if (action.type === 'qzone_post') {
                const newPost = { type: action.postType, content: action.content || '', publicText: action.publicText || '', hiddenContent: action.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`Background activity: Role "${chat.name}" Posted an update`);
            } else if (action.type === 'qzone_comment') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.comments) post.comments = [];
                    post.comments.push({ commenterName: chat.name, text: action.commentText, timestamp: Date.now() });
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(`Background activity: Role "${chat.name}" Commented on an update #${post.id}`);
                }
            } else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`Background activity: Role "${chat.name}" Liked an update #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    state.activeChatId = chatId;
                    showIncomingCallModal();
                    console.log(`Background activity: Role "${chat.name}" Initiated a video call request`);
                }
            }
        }
    } catch (error) {
        console.error(`Role "${chat.name}" Independent action failed:`, error);
    }
}

// ▼▼▼ Please use this【Ultimate revised version】Function, fully replace your old applyScopedCss function ▼▼▼

/**
 * Safely apply user-defined CSS to the specified scope
 * @param {string} cssString User-input raw CSS string
 * @param {string} scopeId Scope ID to apply styles to (For example '#chat-messages' or '#settings-preview-area')
 * @param {string} styleTagId To operate on the <style> Tag ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // Enhanced scope handling function - Specifically address .user and .ai style conflicts
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ Please use this【Revised version】Function, fully replace the old updateSettingsPreview function ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. Get the current setting values
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // Directly retrieve the background settings

    // 2. Update the basic styles of the preview area
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【Core fix】Directly update the preview area's background style ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // If there is an image,set the background color to transparent
    } else {
        previewArea.style.backgroundImage = 'none'; // If there is no image,remove the image background
        // If the background is a color value or gradient(Not an image),Then apply directly
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. Render mock bubbles
    previewArea.innerHTML = ''; 

    // Create\"Other party\"bubble
    // Note:We pass in a virtual timestamp,in case CSS depends on it
    const aiMsg = { role: 'ai', content: 'Other party message preview', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // Create\"me\"bubble
    const userMsg = { role: 'user', content: 'My message preview', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. Apply custom CSS to the preview area
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ Please paste these【New functions】into the JS function definition area ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">There are no groups yet</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ Please use this【After fix】functions, completely replace the old addNewGroup function ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('Group name cannot be empty!');
        return;
    }

    // 【Core fix】Before adding, first check whether the group name already exists
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`Group "${name}" The group already exists, choose a different name!`);
        return;
    }
    // 【Fix end】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ Replacement end ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('Confirm deletion', 'After deleting the group, friends in that group will become\"Ungrouped\".Are you sure you want to delete?', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // Set the groupId of friends belonging to this group to null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ End of new function paste ▲▲▲

// ▼▼▼ Please put this【A whole new block of functions】Paste at the end of the JS function definition area ▼▼▼

/**
 * Show action menu when a message is long-pressed
 * @param {number} timestamp - Timestamp of the long-pressed message
 */
function showMessageActions(timestamp) {
    // Do not show the menu if already in multi-select mode
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * Hide message action menu
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ Use this【Updated】version, replace the old openMessageEditor function ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【Core fix】Include share_link also in the special type checks
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【Core fix】Handle messages of share link type
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【Core modification 1】Add here 'link' Template
    const templates = {
        voice: { type: 'voice_message', content: 'Enter voice content here' },
        image: { type: 'ai_image', description: 'Enter image description here' },
        transfer: { type: 'transfer', amount: 5.20, note: 'A small token of appreciation' },
        link: { type: 'share_link', title: 'Article title', description: 'Article summary...', source_name: 'Source website', content: 'Full article content...' }
    };

    // 【Core modification 2】Add a new\"link\"Button
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>Voice</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>Image</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>Transfer</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>link</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        'Edit message', 
        'Modify here, or click the button above to use a format template...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【Core fix】This should call saveEditedMessage here, not saveAdvancedEditor
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * Copy the message text content to the clipboard
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('Copy succeeded', 'Message content has been copied to the clipboard.');
    } catch (err) {
        await showCustomAlert('Copy failed', 'Cannot access the clipboard.');
    }
    
    hideMessageActions();
}

// ▼▼▼ Use this【Updated】version, replace the old createMessageEditorBlock function ▼▼▼
/**
 * Create an editable message block(Including a textbox, format helper and delete button)
 * @param {string} initialContent - Initial content of the textbox
 * @returns {HTMLElement} - Created DOM element
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【Core modification 1】Add here 'link' Template
    const templates = {
        voice: { type: 'voice_message', content: 'Enter voice content here' },
        image: { type: 'ai_image', description: 'Enter image description here' },
        transfer: { type: 'transfer', amount: 5.20, note: 'A small token of appreciation' },
        link: { type: 'share_link', title: 'Article title', description: 'Article summary...', source_name: 'Source website', content: 'Full article content...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="Delete this entry">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>Voice</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>Image</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>Transfer</button>
            <!-- 【Core modification 2】Add a new\"link\"Button -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>link</button>
        </div>
    `;

    // Bind delete button event
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // Ensure at least one edit block remains
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('At least one message must be kept.');
        }
    });

    // Bind format helper button events
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("Failed to parse format template:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【Completely upgraded version】Please fully replace the old openAdvancedMessageEditor with this function ▼▼▼
/**
 * Open a brand-new visual multi-message editor and dynamically bind all its button events
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【Core】Before closing the old menu, capture the necessary timestamps into local variables
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. You can now safely close the old menu because it will not affect our local variables
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. Prepare initial content
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【Core】Dynamically bind events for all control buttons
    // To prevent duplicate bindings, we use node cloning to clear old listeners
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // Bind the captured timestamps directly to this save click event
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. Finally, show the modal
    editorModal.classList.add('visible');
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * Parse the edited text and return a normalized message fragment object
 * @param {string} text - Text the user entered in the edit box
 * @returns {object} - An object containing type, content, and other properties
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. Attempt to parse as a JSON object(Used to fix formats like voice, transfer, etc.)
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // Must contain a type property to be considered a valid format
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* If parsing fails, continue on */ }
    }
    
    // 2. Attempt to parse as a sticker
    if (STICKER_REGEX.test(trimmedText)) {
        // For edited stickers, we cannot determine their`meaning`,So only store the URL
        return { type: 'sticker', content: trimmedText };
    }

    // 3. Otherwise, treat as a regular text message
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ Use this【Final compatible version】function, fully replace the old saveEditedMessage function ▼▼▼
/**
 * Save the edited message, compatible with simple and advanced editors
 * @param {number} timestamp - Timestamp of the original message to modify
 * @param {string} [simpleContent=null] - (Optional) Single content string passed from the simple editor
 */
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // Determine whether it comes from the advanced or simple editor
    if (simpleContent !== null) {
        // --- From the simple editor ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                timestamp: timestamp, // Simple edit, timestamp remains unchanged
                content: parsedResult.content || '',
            };
            // Add various possible properties
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;

            newMessages.push(newMessage);
        }
    } else {
        // --- From the advanced editor ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');
        let baseTimestamp = timestamp;

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                timestamp: baseTimestamp++,
                content: parsedResult.content || '',
            };
            
            // Add various possible properties
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    }
    
    if (newMessages.length === 0) {
        alert("Cannot save an empty message, please enter at least one item.");
        return;
    }

    chat.history.splice(messageIndex, 1, ...newMessages);
    await db.chats.put(chat);

    // Close any open modals and refresh the UI
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('Success', 'Message updated!');
}
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ Please put this【A whole new block of functions】Paste at the end of the JS function definition area ▼▼▼

/**
 * When clicking\"...\", show the dynamic action menu
 * @param {number} postId - ID of the post being acted on
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * Hide dynamic action menu
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

/**
 * Open the post editor
 */
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // Faithful to the original:Construct the most original textual form for editing
    let contentForEditing;
    if (post.type === 'shuoshuo') {
        contentForEditing = post.content;
    } else {
        // For images and text images, we construct an object containing all information
        const postObject = {
            type: post.type,
            publicText: post.publicText || '',
        };
        if (post.type === 'image_post') {
            postObject.imageUrl = post.imageUrl;
            postObject.imageDescription = post.imageDescription;
        } else if (post.type === 'text_image') {
            postObject.hiddenContent = post.hiddenContent;
        }
        contentForEditing = JSON.stringify(postObject, null, 2);
    }
    
    // Build format helper buttons
    const templates = {
        shuoshuo: "Enter post content here...", // For posts, we directly convert to plain text
        image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
        text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
    };
    
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">Posts</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>Image update</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>Text-image</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        'Edit post',
        'Modify content here...',
        contentForEditing,
        'textarea',
        helpersHtml
    );
    
    // 【Special handling】Add different behaviors to the post's format helper button
    // We need to bind its events after the modal appears
    setTimeout(() => {
        const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
        if(shuoshuoBtn) {
            shuoshuoBtn.addEventListener('click', () => {
                const input = document.getElementById('custom-prompt-input');
                input.value = templates.shuoshuo;
                input.focus();
            });
        }
    }, 100);

    if (newContent !== null) {
        await saveEditedPost(postIdToEdit, newContent);
    }
}

/**
 * Save the edited post
 * @param {number} postId - ID of the post to save
 * @param {string} newRawContent - New content obtained from the editor
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // Attempt to parse as JSON; if it fails, treat as plain text(Posts)
    try {
        const parsed = JSON.parse(trimmedContent);
        // Update post properties
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // Clear the old post content field
    } catch (e) {
        // If parsing fails, consider it a post
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // Clear fields for other types
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // Re-render the list
    await showCustomAlert('Success', 'Post updated!');
}

/**
 * Copy post content
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "(No text content)";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('Copy succeeded', 'Post content has been copied to the clipboard.');
    } catch (err) {
        await showCustomAlert('Copy failed', 'Cannot access the clipboard.');
    }
    
    hidePostActions();
}

// ▼▼▼ 【Brand new】Core functions for creating group chats and inviting people ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // Clear previous selections

    // 【Core fix】Here, we explicitly bind\"Done\"the button\"Create group chat\"’s functionality
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // Use node cloning trick to clear any previously bound events(For example\"Add member\")
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // Rebind the correct\"Create group chat\"function
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * Render the contact selection list
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // Only select single-chat roles as group member candidates
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">There are no contacts to add to the group yet~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * Update\"Done\"the button count
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `Done(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // At least 2 people are required to create a group chat
}

/**
 * Handle the final logic for creating a group chat
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("Creating a group chat requires selecting at least 2 contacts.");
        return;
    }

    const groupName = await showCustomPrompt('Set group name', 'Please enter the group chat name', 'Our group chat');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
    // Iterate through selected contact IDs
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // 【Core】Extract data from single chat settings to create group member objects
            members.push({
                id: contactId, // Use the single-chat ID as the member ID for easier association
                name: contactChat.name,
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: 'Who am I.',
            myNickname: 'me',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarFrame: '',
            myAvatarFrame: ''
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); // Open the group chat immediately after creation
}
// ▲▲▲ End of new function paste ▲▲▲

// ▼▼▼ 【Brand new】Core functions for group member management ▼▼▼

/**
 * Open the group member management screen
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

/**
 * Render the group member management list
 */
function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.name}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="Remove from group chat">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * Remove a member from the group chat
 * @param {string} memberId - ID of the member to remove
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // Safety check, keep at least 2 people in the group chat
    if (chat.members.length <= 2) {
        alert("Group chat cannot have fewer than 2 people.");
        return;
    }
    
    const memberName = chat.members[memberIndex].name;
    const confirmed = await showCustomConfirm(
        'Remove member',
        `Are you sure you want to\"${memberName}\"remove from the group chat?`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // Refresh the member management list
        document.getElementById('chat-settings-btn').click(); // 【Core fix】Simulate clicking the settings button to force refresh the entire modal
    }
}

/**
 * Open the contact picker to invite people to the group
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // Clear selection
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // Render the contact list and automatically exclude members already in the group
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">No more friends to invite.</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // No one selectable, hide the Done button
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // Update button state and show the screen
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * Handle logic to add selected contacts to the group chat
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("Please select at least one contact to add.");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            chat.members.push({
                id: contactId,
                name: contactChat.name,
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // Return to the group member management interface
    renderGroupMemberSettings(chat.members); // Also update the avatar in chat settings
}

// ▼▼▼ Please use this【Final revised version】Replace the old createNewMemberInGroup function ▼▼▼
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('Create a new member', 'Please enter the new member's name');
    if (!name || !name.trim()) return;

    const persona = await showCustomPrompt('Set persona', `Please enter\"${name}\"'sPersona`, '', 'textarea');
    if (persona === null) return; // User clicked Cancel

    const chat = state.chats[state.activeChatId];
    const newMember = {
        id: 'npc_' + Date.now(),
        name: name.trim(),
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    // 【Core fix】Here, we not only refresh the current page's list...
    renderMemberManagementList();
    // 【Core fix】...but also manually refresh the\"Chat settings\"member avatar list in the modal!
    renderGroupMemberSettings(chat.members); 

    alert(`New member\"${name}\"Has successfully joined the group chat!`);
}
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【Brand new】Takeout request countdown function ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>Already</span><span>Exceeded</span><span>time</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ End of new function paste ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. Update the status of the original message
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【Core fix】Record the payer and construct a clearer system message for the AI
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // Record that the user paid
        systemContent = `[system prompt:you (${myNickname}) For ${originalMessage.senderName}'s takeout order(Timestamp: ${originalTimestamp})Payment completed. This order is closed; other members can no longer pay.]`;
    } else {
        systemContent = `[system prompt:you (${myNickname}) Declined ${originalMessage.senderName}'s pay-for-me takeout request(Timestamp: ${originalTimestamp}).]`;
    }

    // 2. Create a new system message hidden from users to inform the AI of the result
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. Save updates to the database and refresh the UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 4. 【Optional but recommended】Trigger an AI response after successful payment
    if (choice === 'paid') {
        triggerAiResponse();
    }
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【Core additions】---
    callHistory: [], // Used to store in-call conversation history
    preCallContext: "" // Used to store pre-call chat summary
};

let callTimerInterval = null; // Used to store the timer ID

/**
 * 【Main entry】User clicks\"Initiate a video call\"or\"Initiate a group video\"Button
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true; // If initiated by the user, they are of course a participant

    // Display different call interfaces depending on single or group chat
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || 'me';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "Calling all members..." : "Calling...";
    showScreen('outgoing-call-screen');
    
    // Prepare and send a system message to the AI
    const requestMessage = {
        role: 'system',
        content: chat.isGroup 
            ? `[system prompt:User (${chat.settings.myNickname || 'me'}) Initiated a group video call request. Please decide individually and use "group_call_response" the command, set "decision" for "join" or "decline" to respond.]`
            : `[system prompt:The user has initiated a video call request to you. Please, according to your persona, use "video_call_response" the command, and set "decision" for "accept" or "reject" to respond.]`,
        timestamp: Date.now(),
        isHidden: true,
    };
    chat.history.push(requestMessage);
    await db.chats.put(chat);
    
    // Trigger AI response
    await triggerAiResponse();
}


function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = []; // 【New addition】Clear last call history

    // --- 【Core additions:Grab pre-call context】---
    const preCallHistory = chat.history.slice(-5); // Take the last 5 as context
    videoCallState.preCallContext = preCallHistory.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || 'me') : (msg.senderName || chat.name);
        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
    }).join('\n');
    // --- Addition finished ---

    updateParticipantAvatars(); 
    
    document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? 'Group call established...' : 'Connecting...'}</em>`;
    showScreen('video-call-screen');

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
}

/**
 * 【Core】End video call
 */
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(duration / 60);
    const seconds = duration % 60;
    const durationText = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    const endCallText = `Call ended, duration ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        
        // --- 【Core refactoring:Create call summary message】 ---
        let summaryMessage = {
            role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
            content: endCallText,
            timestamp: Date.now(),
        };

        // 【Key】Supplement senderName for assistant messages in group chat
        if (chat.isGroup && summaryMessage.role === 'assistant') {
            // In a group chat, the call ended message should be by\"Initiator\"say
            // videoCallState.callRequester Saved the name of the AI that originally initiated the call
            summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.name || chat.name;
        }
        
        chat.history.push(summaryMessage);

        // --- 【Core refactoring:Trigger call summary】---
        const callSummaryPrompt = `
# Your task
You are a conversation summary assistant. The following\"call log\"is the content of a recently ended video call. Please use 1-2sentence to succinctly summarize the core content or consensus reached in this call.
Your summary will serve as a hidden system prompt to help the AI remember what happened in this call during subsequent chats.

# call log:
${videoCallState.callHistory.map(h => `${h.role}: ${h.content}`).join('\n')}

Please output the summary directly, without any extra prefixes or explanations.`;
        
        try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: callSummaryPrompt }],
                    temperature: 0.5
                })
            });
            if (response.ok) {
                const data = await response.json();
                const callSummaryText = data.choices[0].message.content;
                const hiddenSummary = {
                    role: 'system',
                    content: `[system prompt:Summary of the recent video call content:${callSummaryText}]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenSummary);
            }
        } catch (e) {
            console.error("Call summary failed:", e);
        }

        await db.chats.put(chat);
    }
    
    // Clean up and reset
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 【Important】Ensure chat is opened after all operations are complete
    if (chat) {
        openChat(chat.id);
    }
}

/**
 * 【Brand new】Update participant avatar grid in call interface
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ Core fix:Distinguish between group chat and single chat
    if (videoCallState.isGroupCall) {
        // Group chat logic:Display all joined AI members
        participantsToRender = [...videoCallState.participants];
        // If the user also participated, add user information as well
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || 'me',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // One-on-one chat logic:Only display the other party's avatar and name
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
        wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${p.name}">
            <div class="participant-name">${p.name}</div>
        `;
        grid.appendChild(wrapper);
    });
}

/**
 * 【Brand new】Handle user joining/Rejoin call
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // Update avatar list, add user

    // Toggle bottom buttons
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // Inform AI user joined
    triggerAiInCallAction("[system prompt:User joined the call]");
}


/**
 * Update call timer display (Keep unchanged)
 */
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ Replace old showIncomingCallModal with this complete function ▼▼▼
function showIncomingCallModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // Display different information based on whether it's a group chat
    if (chat.isGroup) {
        // Get which member initiated the call from videoCallState
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || 'One member';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // Display group name
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} invites you to join group video`; // Display specific initiator
    } else {
        // Single chat logic remains unchanged
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = 'Invites you to a video call';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * Hide AI-initiated call request modal (Keep unchanged)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
}

async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || 'me';

    // 1. If the user has input, render and save it to call history first
    if (userInput && videoCallState.isUserParticipating) {
        const userBubble = document.createElement('div');
        userBubble.className = 'call-message-bubble user-speech';
        userBubble.textContent = userInput;
        callFeed.appendChild(userBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    // 2. Build a brand new System Prompt with complete context
    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        const participantNames = videoCallState.participants.map(p => p.name);
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        inCallPrompt = `
# Your task
You are a director of a group video call. Your task is to play all【except for the user】AI roles, and【in a third-person observer perspective】to describe all their actions and language during the call.
# Core rules
1.  **【【【Identity iron law】】】**: The user's identity is【${userNickname}】.you【Absolutely must not】generate \`name\` fields are **"${userNickname}"** 's speech.
2.  **【【【Perspective Iron Rule】】】**: Your reply【Absolutely must not】Use first person\"me\".
3.  **Format**: Your reply【must】is a JSON array, where each object represents a character's speech, in the format of:\`{"name": "role name", "speech": "*He smiled* Hello everyone!"}\`.
4.  **Roleplay**: Strictly adhere to each character's settings.
# Current situation
You are in a group video call.
**Chat summary before call**:
${videoCallState.preCallContext}
**Current participants**: ${participantNames.join(', ')}.
**Call just started...**
Now, please based on【Pre-call summary】and the following【Real-time call log】,continue the conversation.
`;
    } else { 
        let openingContext = videoCallState.initiator === 'user'
            ? `You just answered the user's video call request.`
            : `The user just answered your initiated video call.`;
        inCallPrompt = `
# Your task
You are now a scene description engine. Your task is to portray ${chat.name} (${chat.settings.aiPersona}),and【in a third-person observer perspective】to describe TA's all actions and language during the video call.
# Core rules
1.  **【【【Perspective Iron Rule】】】**: Your reply【Absolutely must not】Use first person\"me\".Must use third person, such as\"He\",\"She\",or directly use character name\"${chat.name}\".
2.  **Format**: Your reply【must】is a descriptive text.
# Current situation
You are with the user(${userNickname},Persona: ${chat.settings.myPersona})having a video call.
**${openingContext}**
**Chat summary before call (This is the reason for your call, it's crucial!)**:
${videoCallState.preCallContext}
Now, please based on【Pre-call summary】and the following【Real-time call log】,continue the conversation.
`;
    }
    
    // 3. Build the messages array to send to the API
    const messagesForApi = [
        { role: 'system', content: inCallPrompt },
        // Add existing call history
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    // --- 【Core fix:Ensure there is content on the first call】---
    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*You pressed the answer button...*` : `*The other party pressed the answer button...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    // --- End of fix ---
    
    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model, messages: messagesForApi, temperature: 0.8
            })
        });
        if (!response.ok) throw new Error((await response.json()).error.message);
        
        const data = await response.json();
        const aiResponse = data.choices[0].message.content;

        const connectingElement = callFeed.querySelector('em');
        if (connectingElement) connectingElement.remove();

        // 4. Process the content returned by the AI and save it to call history
        if (videoCallState.isGroupCall) {
            const speechArray = parseAiResponse(aiResponse);
            speechArray.forEach(turn => {
                if (!turn.name || turn.name === userNickname || !turn.speech) return;
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                
                const speaker = videoCallState.participants.find(p => p.name === turn.name);
                if (speaker) {
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
            });
        } else {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'call-message-bubble ai-speech';
            aiBubble.textContent = aiResponse;
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
            if(speakingAvatar) {
                speakingAvatar.classList.add('speaking');
                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}

// ▼▼▼ Take this【brand new function】into the JS function definition area ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ End of paste ▲▲▲

// ▼▼▼ 【Brand new】This function is the core of this fix, please paste it into your JS function area ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. Update the status of the original message in memory
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. Get the current user's nickname and build a clearer system message for the AI
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // Record is\"me\"money paid
        systemContent = `[system prompt:you (${myNickname}) For ${originalMessage.senderName}'s takeout order(Timestamp: ${originalTimestamp})Payment completed. This order is closed; other members can no longer pay.]`;
    } else {
        systemContent = `[system prompt:you (${myNickname}) Declined ${originalMessage.senderName}'s pay-for-me takeout request(Timestamp: ${originalTimestamp}).]`;
    }

    // 3. Create a new system message hidden from users to inform the AI of the result
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. Save the updated data to the database and immediately redraw the UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【Important】Only after successful payment, trigger an AI response to let it thank you
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ End of new function paste ▲▲▲

/**
 * 【Brand new】Handle user initiated by clicking avatar\"Tap once-Tap\",with custom suffix functionality
 * @param {string} chatId - occurred\"Tap once-Tap\"chat ID
 * @param {string} characterName - Patted character name
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. Trigger screen shake animation
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. Pop up input box for user to enter suffix
    const suffix = await showCustomPrompt(
        `You patted \"${characterName}\"`, 
        "(Optional)Enter suffix",
        "",
        "text"
    );

    // If the user clicks cancel, do nothing
    if (suffix === null) return;

    // 3. Create user visible\"Tap once-Tap\"Messages
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
    // 【Core modification】Append suffix to message content
    const visibleMessageContent = `${myNickname} Patted \"${characterName}\" ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // Still a system message
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. Create a system message hidden from the user but visible to the AI, to trigger an AI response
    // 【Core modification】Also add the suffix to the prompt for the AI
    const hiddenMessageContent = `[system prompt:User(${myNickname})just patted you(${characterName})${suffix.trim()}.Please respond to this.]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // Timestamp+1to ensure order
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. Save changes and update UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ Please use this【After logic refactoring】function, completely replace your old renderMemoriesScreen function ▼▼▼
/**
 * 【Refactored version】Render memories and commitments interface, using a single loop and clear if/elselogic
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. Get all memories, and by target date(If it's a commitment)or creation date(If it's a memory)descending order
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">There are no shared memories or commitments here yet~</p>';
        return;
    }

    // 2. Arrange unexpired commitments at the top
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // aAt the front
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // bAt the front
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // All are countdowns, ascending by date
        return 0; // Other cases maintain original order
    });

    // 3. 【Core】Use a single loop to process all card types
    allMemories.forEach(item => {
        let card;
        // Judgment 1:If it's an ongoing commitment
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // Judgment 2:All other cases(Normal memory or expired commitment)
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. Start all countdowns
    startAllCountdownTimers();
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * Create normal memory card DOM element
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【Core fix】Here, we clearly distinguish between different types of memories
    if (memory.type === 'countdown' && memory.targetDate) {
        // If it's an expired commitment
        titleHtml = `[Commitment reached] ${memory.description}`;
        contentHtml = `On ${new Date(memory.targetDate).toLocaleString()}, we witnessed this commitment together.`;
    } else {
        // If it's a normal diary-style memory
        titleHtml = memory.authorName ? `${memory.authorName} 's diary` : 'Our memories';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('Delete record', 'Are you sure you want to delete this record?', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【Core fix】Before use, first create targetDate variable from countdown object
    const targetDate = new Date(countdown.targetDate);
    
    // Now targetDate can be safely used
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--Day--time--Min--seconds</div>
        <div class="target-date">Target time: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('Delete commitment', 'Are you sure you want to delete this commitment?', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ Replacement end ▲▲▲

// Global variable, used to manage all countdowns
let activeCountdownTimers = [];

// ▼▼▼ Please use this【Completely fixed】function, completely replace your old startAllCountdownTimers function in your code ▼▼▼
function startAllCountdownTimers() {
    // First clear all possibly existing old timers to prevent memory leaks
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【Core fix】Here, we first declare timerId with let
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "Commitment reached!";
                // Now updateTimer can correctly find and clear itself
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}Day ${hours}h ${minutes}m ${seconds}s`;
        };
        
        updateTimer(); // Execute once immediately to display initial countdown
        
        // 【Core fix】Here, we assign a value to the declared timerId
        timerId = setInterval(updateTimer, 1000);
        
        // Store valid timer IDs in a global array so they can be cleared on next refresh
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ Please use this【Ultimate reverse proxy compatible version】Replace old triggerAiFriendApplication function ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("Process started", `Preparing for character\"${chat.name}\"preparing friend application...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("Configuration error", "APISettings incomplete, cannot continue.");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || 'me') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    const systemPrompt = `
# Your task
You are now the role\"${chat.name}\".You were previously by the user(Your chat partner)blocked, you haven't been in contact for a while.
Now, you are very eager to reconcile and chat with the user again. Please carefully analyze the following\"Dialogue summary before being blocked\",understand what happened then, and then think of a sincere, character-consistent, and【specific to the event】application reason.
# Your role setting
${chat.settings.aiPersona}
# Dialogue summary before being blocked (This is the key reason you were blocked)
${contextSummary}
# Instruction format
Your reply【must】is a JSON object, formatted as follows:
\`\`\`json
{
  "decision": "apply",
  "reason": "Write here the sincere, targeted application reason you want to tell the user."
}
\`\`\`
`;

    const messagesForApi = [
        { role: 'user', content: systemPrompt }
    ];

    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: messagesForApi,
                temperature: 0.9,
            })
        });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API Request failed: ${response.status} - ${errorData.error.message}`);
        }
        
        const data = await response.json();
        
        // --- 【Core fix:Purify AI's response here】 ---
        let rawContent = data.choices[0].message.content;
        // 1. Remove possible leading and trailing "```json" and "```"
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
        // 2. Remove all newlines and extra spaces, ensure it's a clean JSON string
        const cleanedContent = rawContent.trim();
        
        // 3. Parse using purified content
        const responseObj = JSON.parse(cleanedContent);
        // --- 【Fix end】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("Application successful!", `\"${chat.name}\"A friend request has been sent to you. Please return to the chat list to view.`);

        } else {
            await showCustomAlert("AIDecision", `\"${chat.name}\"After thinking, decided not to send friend request for now, will reset cooldown period.`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("Execution error", `for\"${chat.name}\"Error occurred when applying for friend:\n\n${error.message}\n\nWill reset cooldown period.`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【Brand new】Red packet feature core function ▼▼▼

/**
 * 【Main entry】Based on chat type, decide whether to open transfer popup or red packet popup
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // Single chat remains unchanged, open transfer popup
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * Open and initialize send red packet modal
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // Clear input box
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // Populate recipient list for exclusive red packet
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
    chat.members.forEach(member => {
        const option = document.createElement('option');
        option.value = member.name;
        option.textContent = member.name;
        receiverSelect.appendChild(option);
    });
    
    // Default display lucky red packet tab
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * Send group red packet(Lucky Draw)
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("Please enter a valid total amount!"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("Please enter a valid number of red packets!"); return;
    }
    if (amount / count < 0.01) {
        alert("Single red packet amount cannot be less than 0.01 yuan!"); return;
    }

    const myNickname = chat.settings.myNickname || 'me';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || 'Wishing you prosperity,good luck and great fortune!',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * Send exclusive red packet
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("Please enter a valid amount!"); return;
    }
    if (!receiverName) {
        alert("Please select a recipient!"); return;
    }
    
    const myNickname = chat.settings.myNickname || 'me';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || 'A red packet has been prepared for you',
        receiverName: receiverName, // Core fields
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【Main entry】Triggered when the user clicks the red packet card (V4 - Refactored process version)
 * @param {number} timestamp - Timestamp of the clicked red packet message
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || 'me';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // If it's an exclusive red packet and not for me, or if all claimed, or already claimed, only show details
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // Core process:First, try to open the red packet
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // If successfully opened(claimedAmountNot null)
        if (claimedAmount !== null) {
            // **Key:After data update, re-render UI**
            renderChatInterface(currentChatId);
            
            // Display success message
            await showCustomAlert("Congratulations!", `You claimed ${packet.senderName}'s red packet, amount is ${claimedAmount.toFixed(2)} yuan.`);
        }

        // Regardless of success or failure, finally display the details page
        // At this time, need to get the latest packet object from state, because it may have been updated in handleOpenRedPacket
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * 【Core】Handle logic for user opening red packet (V5 - Focus on data update)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || 'me';
    
    // 1. Check if the red packet can still be claimed
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("Too slow", "Red packet has been claimed all!");
        return null; // Return null indicates claiming failed
    }
    
    // 2. Calculate claimed amount
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. Update red packet data
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. Build system message and AI command
    let hiddenMessageContent = isNowFullyClaimed
        ? `[system prompt:User (${myNickname}) Claimed the last red packet, now ${packet.senderName}'s red packet has been claimed all. Please comment on this event.]`
        : `[system prompt:User (${myNickname}) Just claimed a red packet (Timestamp: ${packet.timestamp}).Red packet not yet claimed all, you can now use 'open_red_packet' command to try claiming.]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `You claimed ${packet.senderName}'s red packet`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. Save to database
    await db.chats.put(chat);
    
    // 6. Return the claimed amount, for subsequent pop-up
    return claimedAmount;
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * 【Brand new】Display red packet claiming details modal box (V4 - Fixed parameter error)
 */
async function showRedPacketDetails(packet) {
    // 1. Directly check if the passed-in packet object exists, no need to search again
    if (!packet) {
        console.error("showRedPacketDetailsReceived invalid packet object");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || 'me';
    
    // 2. All subsequent logic remains unchanged, directly use the passed-in packet object
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || 'Wishing you prosperity,good luck and great fortune!';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}red packets, total ${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}yuan.`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` Remaining red packets will be refunded within ${timeLeft} hours.`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">the luckiest</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} yuan</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ Replacement end ▲▲▲

// Bind event for close details button
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// Function for global call, so that onclick on the red packet card can find it
window.handlePacketClick = handlePacketClick;

// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【Brand new】Core function for voting feature ▼▼▼

/**
 * Open create poll modal box and initialize
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // Default create two empty option boxes
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * Dynamically add an option input box in the modal box
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="Option content...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // Ensure at least two options are kept
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('A poll needs at least 2 options.');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * User confirms to initiate poll
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('Please enter the poll question!');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // Filter out empty options

    if (options.length < 2) {
        alert('Please enter at least 2 valid poll options!');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // Initial poll is empty
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ Use this【Fixed duplicate click issue】version replaces handleUserVote function ▼▼▼
/**
 * Handle user vote, and save event as hidden message into history record
 * @param {number} timestamp - timestamp of the vote message
 * @param {string} choice - User selected option text
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';

    // 1. 【Core fix】If the poll does not exist or is closed, directly return
    if (!poll || poll.isClosed) {
        // If it is a closed poll, then directly display results
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. Check if the user clicked the same option they already voted for
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【Core fix】If not a duplicate click, then only execute voting logic
    if (!isReclickingSameOption) {
        // Remove old vote(If user changes selection)
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // Add new vote
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【Core logic】Now only process user vote event, no longer check if ended
    let hiddenMessageContent = null; 
    
    // Only when the user truly votes or changes vote, then generate prompt
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[system prompt:User (${myNickname}) Just voted for \"${choice}\".]`;
    }

    // 5. If there is an event that needs to notify AI, then create and add hidden message
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. Save data and update UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * User ends poll, and saves event as hidden message into history record
 * @param {number} timestamp - timestamp of the vote message
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("End the vote", "Are you sure you want to end this poll? After it ends, you will no longer be able to vote.");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `\"${opt}\"(${poll.votes[opt]?.length || 0}votes)`).join(',');
        const hiddenMessageContent = `[system prompt:User manually ended the poll! Final result is:${resultSummary}.]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【Core modification】Only save data and update UI, do not call triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ Replacement end ▲▲▲

/**
 * Display poll result details
 * @param {number} timestamp - timestamp of the vote message
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">No one has voted yet.</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}votes)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join(', ') : 'No one voted'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("Poll results", resultsHtml);
}

// ▲▲▲ End of new function paste ▲▲▲

// ▼▼▼ 【Brand new】AIAvatar library management function ▼▼▼

/**
 * Open AI avatar library management modal box
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `\"${chat.name}\"'s avatar library`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * Render content of AI avatar library
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">This avatar library is still empty, click top right corner\"Add\"!</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // Reuse style of emoji panel
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // Always display delete button
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('Delete avatar', `Are you sure you want to delete from avatar library\"${avatar.name}\"??`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * Add new avatar to current AI's avatar library
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("Add avatar", "Please name this avatar(For example:Happy, crying)");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("Add avatar", "Please enter avatar image URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("Please enter a valid image URL!");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * Close AI avatar library management modal box
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ End of new function paste ▲▲▲

// ▼▼▼ Please take these two【New functions】into the JS function definition area ▼▼▼

/**
 * 【Brand new】Apply the saved icon URL to the home screen App icon
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【Brand new】Render all App icon setting items on the appearance settings page
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
        'world-book': 'World book',
        'qq': 'QQ',
        'api-settings': 'APISettings',
        'wallpaper': 'Wallpaper',
        'font': 'Font'
    };

    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || 'Unknown App';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【Important】We use data-icon-id to mark which icon this setting item corresponds to
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">Replace</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ End of new function paste ▲▲▲

// ▼▼▼ Use this block【Final confirmed version】's code, replace old openBrowser and closeBrowser functions ▼▼▼

/**
 * When user clicks link card, open pseudo-browser
 * @param {number} timestamp - Timestamp of clicked message
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // Security check, ensure chat and history all exist
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("Cannot find or message type mismatched shared link:", timestamp);
        return; // If message not found, then directly exit
    }

    // Populate browser content
    document.getElementById('browser-title').textContent = message.source_name || 'Article details';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || 'Untitled'}</h1>
        <div class="article-meta">
            <span>Source: ${message.source_name || 'Unknown'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || 'Content is empty.').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // Display browser screen
    showScreen('browser-screen');
}

/**
 * Close pseudo-browser, return to chat interface
 * (This function is now by init() called by event listener in)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【Brand new】Core function for user sharing link feature ▼▼▼

/**
 * Open modal box for user to fill in link information
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // Clear last input content
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // Display modal box
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * User confirms share, create and send link card message
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("Title is a required item!");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // Create message object
    const linkMessage = {
        role: 'user', // Role is 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // User shared link, we do not provide images, let it always display placeholder image
        thumbnail_url: null 
    };

    // Add message to history record
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // Render new message and update list
    appendMessage(linkMessage, chat);
    renderChatList();

    // Close modal box
    document.getElementById('share-link-modal').classList.remove('visible');
}

// ▲▲▲ End of new function paste ▲▲▲

        // ===================================================================
        // 4. Initialization function init()
        // ===================================================================
        async function init() {

    // ▼▼▼ Added code ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ Addition finished ▲▲▲

    // ▼▼▼ Added code ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ Addition finished ▲▲▲


    // ▼▼▼ Modify these two lines ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // Clear custom styles of real chat interface
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // Clear custom styles of preview area
    // ▲▲▲ End of modifications ▲▲▲

            window.showScreen = showScreen;
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();

            // Initialize unread activity count
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ Code addition ended ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();

            // ==========================================================
            // --- Various event listeners ---
            // ==========================================================

            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 

    // ▼▼▼ Modify these two lines ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // Clear custom styles of real chat interface
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // Clear custom styles of preview area
    // ▲▲▲ End of modifications ▲▲▲

exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen'); });
            
            document.getElementById('add-chat-btn').addEventListener('click', async () => { const name = await showCustomPrompt('Create new chat', 'Please enter their name'); if (name && name.trim()) { const newChatId = 'chat_' + Date.now(); 
const newChat = { 
    id: newChatId, 
    name: name.trim(), 
    isGroup: false,                         relationship: {
                            status: 'friend', // 'friend', 'blocked_by_user', 'pending_user_approval'
                            blockedTimestamp: null,
                            applicationReason: ''
                        },
                        status: {
                            text: 'Online',
                            lastUpdate: Date.now(),
                            isBusy: false 
                        },
    settings: { 
        aiPersona: 'Who are you.', 
        myPersona: 'Who am I.', 
        maxMemory: 10, 
        aiAvatar: defaultAvatar, 
        myAvatar: defaultAvatar, 
        background: '', 
        theme: 'default', 
    fontSize: 13, 
    customCss: '', // <--- Add this line
    linkedWorldBookIds: [], 
    aiAvatarLibrary: [],
    aiAvatarFrame: '', 
        myAvatarFrame: '' 
    }, 
    history: [], 
    musicData: { totalTime: 0 } 
};
state.chats[newChatId] = newChat; await db.chats.put(newChat); renderChatList(); } });

            // ▼▼▼ 【Fix】Create group chat button now opens contact selector ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ Replacement end ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            audioPlayer.addEventListener('ended', playNext);
            audioPlayer.addEventListener('pause', () => { if(musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
            audioPlayer.addEventListener('play', () => { if(musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });

            const chatInput = document.getElementById('chat-input');
            document.getElementById('send-btn').addEventListener('click', async () => { const content = chatInput.value.trim(); if (!content || !state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); chatInput.value = ''; chatInput.style.height = 'auto'; chatInput.focus(); });
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
            // ▼▼▼ Use this entire block of code, replace old save-wallpaper-btn event listener ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // Save wallpaper
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 【Core modification】Save icon settings(It is already in memory, we only need to save the entire globalSettings)
    await db.globalSettings.put(state.globalSettings);

    // Apply all changes
    if (changesMade) {
        applyGlobalWallpaper();
        newWallpaperBase64 = null;
    }
    applyAppIcons(); // Reapply all icons

    alert('Appearance settings saved and applied!');
    showScreen('home-screen');
});
// ▲▲▲ Replacement end ▲▲▲
            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); state.apiConfig.model = document.getElementById('model-select').value; await db.apiConfig.put(state.apiConfig); 

// On the basis of 'save-api-settings-btn' inside 's click event listener
// await db.apiConfig.put(state.apiConfig); After this line

// ▼▼▼ Replace the previous section of logic for saving background activity settings with this enhanced version below ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// Only when user\"From off to on\", only then pop up a warning
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【High cost warning】\n\n" +
        "You are enabling\"Background character activity\"feature.\n\n" +
        "This will make your AI characters, even when you are not chatting with them, also able to\"Think independently\"and actively send you messages or conduct social interactions, greatly enhancing immersion.\n\n" +
        "But please note:\n" +
        "This will【automatically and regularly call API in the background】,even if you do not perform any operations. According to your character count and detection interval, this may lead to a significant increase in your API fees.\n\n" +
        "Are you sure you want to enable?"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // User cancels, toggle the switch back
        return; // Block subsequent logic
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// Dynamically start or stop simulator
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`Background activity simulation started, interval: ${state.globalSettings.backgroundActivityInterval}seconds`);
} else {
    console.log("Background activity simulation stopped.");
}
// ▲▲▲ Replacement end ▲▲▲

alert('APISettings saved!'); });
            document.getElementById('fetch-models-btn').addEventListener('click', async () => { const url = document.getElementById('proxy-url').value.trim(); const key = document.getElementById('api-key').value.trim(); if (!url || !key) return alert('Please first fill in reverse proxy address and key'); try { const response = await fetch(`${url}/v1/models`, { headers: { 'Authorization': `Bearer ${key}` } }); if (!response.ok) throw new Error('Unable to get model list'); const data = await response.json(); const modelSelect = document.getElementById('model-select'); modelSelect.innerHTML = ''; data.data.forEach(model => { const option = document.createElement('option'); option.value = model.id; option.textContent = model.id; if(model.id === state.apiConfig.model) option.selected = true; modelSelect.appendChild(option); }); alert('Model list updated'); } catch (error) { alert(`Fetch model failed: ${error.message}`); } });
            document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('Create world info', 'Please enter name'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('Name cannot be empty!'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });

            document.getElementById('chat-messages').addEventListener('click', (e) => { const aiImage = e.target.closest('.ai-generated-image'); if (aiImage) { const description = aiImage.dataset.description; if (description) showCustomAlert('Photo description', description); return; } const voiceMessage = e.target.closest('.voice-message-body'); if (voiceMessage) { const text = voiceMessage.dataset.text; if (text) showCustomAlert('Voice content', text); return; } });
            
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- Click to select --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `Selected ${checkedBoxes.length} items`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

// ▼▼▼ Please use this【Complete, brand new code】Replace old chat-settings-btn click event ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;

    // --- Unified display/Hide controls ---
    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
    
    // 【Core modification 1】According to whether it is a group chat, display or hide\"Friend groups\"Area
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // --- Load form data ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        
        // 【Core modification 2】If it is a one-on-one chat, load the group list into the drop-down box
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">Ungrouped</option>'; // Clear and set default option
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // If the current friend already has a group, select it by default
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
    // Load world info
    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
    worldBookCheckboxesContainer.innerHTML = '';
    const linkedIds = chat.settings.linkedWorldBookIds || [];
    if (state.worldBooks.length > 0) {
        state.worldBooks.forEach(book => {
            const isChecked = linkedIds.includes(book.id);
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
            worldBookCheckboxesContainer.appendChild(label);
        });
    }
    updateWorldBookSelectionDisplay();

    // Load and update all preview-related controls
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ Replacement end ▲▲▲
            
            function renderGroupMemberSettings(members) { const container = document.getElementById('group-members-settings'); container.innerHTML = ''; members.forEach(member => { const div = document.createElement('div'); div.className = 'member-editor'; div.dataset.memberId = member.id; div.innerHTML = `<img src="${member.avatar}" alt="${member.name}"><div class="member-name">${member.name}</div>`; div.addEventListener('click', () => openMemberEditor(member.id)); container.appendChild(div); }); }
            function openMemberEditor(memberId) { editingMemberId = memberId; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === memberId); document.getElementById('member-name-input').value = member.name; document.getElementById('member-persona-input').value = member.persona; document.getElementById('member-avatar-preview').src = member.avatar; document.getElementById('member-settings-modal').classList.add('visible'); }

            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { if (!editingMemberId) return; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === editingMemberId); member.name = document.getElementById('member-name-input').value; member.persona = document.getElementById('member-persona-input').value; member.avatar = document.getElementById('member-avatar-preview').src; renderGroupMemberSettings(chat.members); document.getElementById('member-settings-modal').classList.remove('visible'); });
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('Remark name/Group name cannot be empty!');
    chat.name = newName;
    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
    const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('Clear chat history', 'This operation will permanently delete all messages in this chat and cannot be recovered. Are you sure you want to clear them?', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            
            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            document.getElementById('add-sticker-btn').addEventListener('click', async () => { const url = await showCustomPrompt("Add emoji(URL)", "Please enter the image URL of the emoji pack"); if (!url || !url.trim().startsWith('http')) return url && alert("Please enter a valid URL (Starting with http)"); const name = await showCustomPrompt("Name emoji", "Please name this emoji (For example:Happy, confused)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: url.trim(), name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("Emoji name cannot be empty!"); });
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
            document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = async () => { const base64Url = reader.result; const name = await showCustomPrompt("Name emoji", "Please name this emoji (For example:Hooray, confused)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: base64Url, name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("Emoji name cannot be empty!"); }; event.target.value = null; });

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("Send voice message", "Please enter what you want to say:"); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("Send photo", "Please describe the photo you want to send in words:"); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【Brand new】Takeaway request function event binding ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('Please enter product information!');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('Please enter a valid proxy payment amount!');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    // 【Core fix】Get the user's own nickname here
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
    
    const msg = {
        role: 'user',
        // 【Core fix】Add the obtained nickname as senderName to the message object
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
            document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【Final enhanced version】Replace the old selection with this code block-delete-btn event listener ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('Delete message', `Are you sure you want to delete the selected ${selectedMessages.size} messages? This will change the AI's memory.`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【Core enhancement】Before deleting, check if the deleted message contains a poll
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`About\"${msg.question}\"'s poll(Timestamp: ${msg.timestamp})`);
            }
        }
        
        // 2. Update backend history
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        
        // 3. 【Core enhancement】Build more specific\"Forgetting instructions\"
        let forgetReason = "Some previous messages have been deleted by the user.";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` Including the following polls:${deletedPollsInfo.join(';')}.`;
        }
        forgetReason += " You should continue the conversation as if they never existed, and adjust your memory and behavior accordingly, without mentioning these deleted contents again.";

        const forgetInstruction = {
            role: 'system',
            content: `[system prompt:${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(forgetInstruction);
        
        // 4. Will contain\"Forgetting instructions\", the updated chat object is saved back to the database
        await db.chats.put(chat);
        
        // 5. Finally update the UI
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ Replacement end ▲▲▲

// For chat settings\"Change avatar frame\"Add click event to button
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        // 'chat' This parameter tells the function that this time it is for\"me/Other party\"this pair to change avatar frame
        openFrameSelectorModal('chat');
    }
});

// For member settings\"Change avatar frame\"Add click event to button
document.getElementById('member-settings-modal').addEventListener('click', (e) => {
    // 【Fix】Change .contents to .contains
    if (e.target.classList.contains('change-frame-btn')) { 
        // 'member' This parameter tells the function that this time it is for a single group member to change avatar frame
        openFrameSelectorModal('member');
    }
});

// ▲▲▲ End of paste ▲▲▲

            const fontUrlInput = document.getElementById('font-url-input');
            fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
            document.getElementById('save-font-btn').addEventListener('click', async () => {
                const newFontUrl = fontUrlInput.value.trim();
                if (!newFontUrl) { alert("Please enter a valid font URL."); return; }
                applyCustomFont(newFontUrl, false);
                state.globalSettings.fontUrl = newFontUrl;
                await db.globalSettings.put(state.globalSettings);
                alert('Font saved and applied!');
            });
            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("Modify nickname", "Please enter a new nickname", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 【After fix】's\"Posts\"button event ▼▼▼
document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
    // 1. Reset and get modal
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. Set to\"Posts\"mode
    modal.dataset.mode = 'shuoshuo';
    
    // 3. Hide with picture/text graph related parts
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    
    // 4. Modify the prompt text of the main input box to make it more consistent with\"Posts\"'s scene
    modal.querySelector('#post-public-text').placeholder = 'Share what's new...';
    
    // 5. Prepare and display modal
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">No available groups</p>';
    }
    modal.classList.add('visible');
});

// ▼▼▼ 【After fix】's\"Activity\"(Image)button event ▼▼▼
document.getElementById('create-post-btn').addEventListener('click', async () => {
    // 1. Reset and get modal
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. Set to\"Complex dynamics\"mode
    modal.dataset.mode = 'complex';
    
// 3. Ensure with picture/text graph related parts are visible
modal.querySelector('.post-mode-switcher').style.display = 'flex';
// Explicit activation\"Upload image\"mode...
modal.querySelector('#image-mode-content').classList.add('active');
// ...And ensure\"Text-image\"mode is hidden
modal.querySelector('#text-image-mode-content').classList.remove('active');
    
    // 4. Restore the default prompt text of the main input box
    modal.querySelector('#post-public-text').placeholder = 'Share what's new...(Optional public text)';

    // 5. Prepare and display modal(And\"Posts\"button's logic is the same)
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">No available groups</p>';
    }
    modal.classList.add('visible');
});
            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ Copy from here ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('Photo uploaded successfully!');
});

// --- ↑↑↑ End copy here ↑↑↑ ---

// --- ↓↓↓ Copy from here, completely replace the old photos-grid-page Listener ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // Prevent event bubbling up to the image
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            'Delete photo',
            'Are you sure you want to delete this photo? This operation is irreversible.',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('Photo deleted.');
        }
    } 
    else if (photoThumb) {
        // This is the restored image click-to-enlarge function!
        openPhotoViewer(photoThumb.src);
    }
});

// Restore image viewer control events
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// Restore the functions of keyboard left/right arrows and ESC key
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ End copy here ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("Create new album", "Please enter album name"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`Album "${albumName}" Created successfully!`); } else if (albumName !== null) { alert("Album name cannot be empty!"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("Enter image URL", "Please enter the link of the network image", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 【Final revised version】's\"Publish\"button event, permission vulnerability fixed ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;
    
    // --- 1. Get general visibility settings ---
    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    
    if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
    }

    let newPost = {};
    const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',
        // 【Important】Save permission information here
        visibleGroupIds: visibleGroupIds,
    };

    // --- 2. Build different post objects based on mode ---
    if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
            alert('Status content cannot be empty!');
            return;
        }
        newPost = {
            ...basePostData,
            type: 'shuoshuo',
            content: content,
        };

    } else { // Handle 'complex' mode (Image/Text-image)
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
            const imageUrl = document.getElementById('post-image-preview').src;
            const imageDescription = document.getElementById('post-image-description').value.trim();
            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                alert('Please add an image before posting!');
                return;
            }
            if (!imageDescription) {
                alert('Please add a simple description for your image(Required, for AI to see)!');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'image_post',
                publicText: publicText,
                imageUrl: imageUrl,
                imageDescription: imageDescription,
            };
        } else { // Text image mode
            const hiddenText = document.getElementById('post-hidden-text').value.trim();
            if (!hiddenText) {
                alert('Please enter text image description!');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'text_image',
                publicText: publicText,
                hiddenContent: hiddenText,
            };
        }
    }

    // --- 3. Save to database ---
    const newPostId = await db.qzonePosts.add(newPost);
    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "(No text content)";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

    // --- 4. 【Core fix】Notification loop with permission check ---
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue; // Skip group chat

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;

        // Condition 1:If the post is public (No visible groups set)
        if (!postVisibleGroups || postVisibleGroups.length === 0) {
            shouldNotify = true;
        } 
        // Condition 2:If the post is set to partially visible, and the current role is within the visible groups
        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
            shouldNotify = true;
        }

        // Only roles that meet the conditions will be notified
        if (shouldNotify) {
            const historyMessage = {
                role: 'system',
                content: `[system prompt:The user just posted a status update(ID: ${newPostId}),The content summary is:\"${postSummary}\".You can now comment on this status update.]`,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
        }
    }
    // --- Fix end ---

    await renderQzonePosts();
    modal.classList.remove('visible');
    alert('Status published successfully!');
});

// ▼▼▼ Please use this【an entire block】Complete code including all swipe and click events, replace the old postsList event listener ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- Bind all swipe events ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// --- Bind all click events ---
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) {
            showPostActions(parseInt(container.dataset.postId));
        }
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-container');
        if (!container) return;
        
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;

        const confirmed = await showCustomConfirm('Delete status', 'Are you sure you want to permanently delete this status?', { confirmButtonClass: 'btn-danger' });

        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
        
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) {
                         await db.chats.put(chat);
                     }
                 }
                 await renderQzonePosts();
                 alert('Status deleted.');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("Image content", hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('Tip', 'Unfavorited');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('Tip', 'Favorited successfully!');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('Comment content cannot be empty!');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];
        post.comments.push({ commenterName: state.qzoneSettings.nickname, text: commentText, timestamp: Date.now() });
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                chat.history.push({ role: 'system', content: `[system prompt:'${state.qzoneSettings.nickname}' Commented on the status with ID ${postId}:\"${commentText}\"]`, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        commentInput.value = '';
        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ Replacement end ▲▲▲

            // ▼▼▼ In init() function's event listener area, paste these two lines below ▼▼▼

            // Bind return buttons for activity page and favorites page
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ End of addition ▲▲▲

            // ▼▼▼ In init() function's event listener area, check and ensure you have this complete code ▼▼▼

            // Favorites page search function
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // Control the display of the clear button/Hide
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // If search box is empty, show all
                    return;
                }

                // Filtering logic
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || 'me') : 'me';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // Search content and author simultaneously, and case-insensitively
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // Clear button click event
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ Code check finished ▲▲▲

            // ▼▼▼ New addition/Modified event listener ▼▼▼
            
            // Bind event to the batch favorite button in the chat interface
                        // Bind event to the batch favorite button in the chat interface (Fixed)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【Core fix 1】Use a new, efficient index for querying
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // This is the time the favorite operation occurred
                                originalTimestamp: messageToSave.timestamp // 【Core fix 2】Save original message timestamp to new field
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // Update global favorite cache
                    await showCustomAlert('Favorited successfully', `Successfully favorited ${favoritesToAdd.length} messages.`);
                } else {
                    await showCustomAlert('Tip', 'All selected messages have been favorited.');
                }
                
                exitSelectionMode();
            });

            // Of the favorites page"Edit"button event (Fixed)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // Get main navigation bar
            const favoritesList = document.getElementById('favorites-list'); // Get favorite list
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- Enter edit mode ---
                    favoritesEditBtn.textContent = 'Done';
                    favoritesActionBar.style.display = 'block'; // Show delete action bar
                    mainBottomNav.style.display = 'none'; // ▼ New addition:Hide main navigation bar
                    favoritesList.style.paddingBottom = '80px'; // ▼ New addition:Add space to the bottom of the list
                } else {
                    // --- Exit edit mode ---
                    favoritesEditBtn.textContent = 'Edit';
                    favoritesActionBar.style.display = 'none'; // Hide delete action bar
                    mainBottomNav.style.display = 'flex';  // ▼ New addition:Restore main navigation bar
                    favoritesList.style.paddingBottom = ''; // ▼ New addition:Restore list default padding

                    // Clear all selections upon exiting
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `delete (0)`;
                }
            });

// ▼▼▼ It will be【completely replaced】with the following corrected code ▼▼▼
// Favorite list click selection event (Event delegation)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【New addition】Handle text image clicks, this logic should be placed at the very beginning to ensure it works in any mode
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("Image content", hiddenText.replace(/<br>/g, '\n'));
        return; // Exit after processing, do not continue to execute selection logic
    }
    
    // If not in selection mode, do not perform subsequent selection operations
    if (!isFavoritesSelectionMode) return;

    // --- The original selection logic is as follows, keep it unchanged ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // Toggle selection status
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // Update the count of the bottom delete button
    document.getElementById('favorites-delete-selected-btn').textContent = `delete (${selectedFavorites.size})`;
});

// ▼▼▼ It will be【completely replaced】with the following corrected code ▼▼▼
// Favorite page batch delete button event
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        'Confirm deletion', 
        `Are you sure you want to remove these ${selectedFavorites.size} items from favorites?`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('Deleted successfully', 'Selected favorites have been removed.');
        
        // 【Core fix 1】Remove deleted items from frontend cache as well
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【Core fix 2】Use the updated cache to re-render the list immediately
        displayFilteredFavorites(allFavoriteItems);
        
        // Finally, exit edit mode
        favoritesEditBtn.click(); // Simulate click"Done"button to exit edit mode
    }
});

// ▼▼▼ In init() Add to the end of the function ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("Background activity simulation has started automatically.");
}
// ▲▲▲ End of addition ▲▲▲

// ▼▼▼ 【This is the final correct code】Please paste this code into init() 's event listener area end ▼▼▼

// --- Unify handling of events for all controls affecting preview ---

// 1. Listen for theme selection
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. Listen for font size slider
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. Update value display in real time
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. Update preview
    updateSettingsPreview();
});

// 3. Listen for custom CSS input box
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. Listen for reset button
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ End of paste ▲▲▲

// ▼▼▼ Please paste this【new code】into init() 's event listener area end ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ End of new code paste ▲▲▲

// ▼▼▼ Please paste this【new code】into init() 's event listener area end ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // Refresh group list in chat settings
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // Click again to reopen
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ End of new code paste ▲▲▲

// ▼▼▼ Please paste this【new code】into init() 's event listener area end ▼▼▼
// Message action menu button event
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【Fix】Use the new editor entry ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ Replacement end ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ Please use this【After fix】code to replace the old select-message-btn event listener ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【Core fix】Before closing the menu, first capture the timestamp
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // Use the captured value
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ In init() Add to the end of the function's event listener area ▼▼▼

// Activity action menu button event
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ End of addition ▲▲▲

// ▼▼▼ Paste this【missing】event listener code into init() At the end of the function's event listener area ▼▼▼

// Avatar frame selection modal button event
document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);
document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
    frameModal.classList.remove('visible');
    editingFrameForMember = false; // Ensure reset state
});

// Avatar frame Tab switch event
aiFrameTab.addEventListener('click', () => {
    aiFrameTab.classList.add('active');
    myFrameTab.classList.remove('active');
    aiFrameContent.style.display = 'block';
    myFrameContent.style.display = 'none';
});
myFrameTab.addEventListener('click', () => {
    myFrameTab.classList.add('active');
    aiFrameTab.classList.remove('active');
    myFrameContent.style.display = 'block';
    aiFrameContent.style.display = 'none';
});

// ▲▲▲ Fix code paste end ▲▲▲

// ▼▼▼ 【New addition】Contact selector event binding ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【New addition】Bind\"Manage group members\"button event ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // Before switching screens, first hide the current chat settings pop-up
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // Then open the member management screen
    openMemberManagementScreen();
});
// ▲▲▲ End of added code ▲▲▲

// ▼▼▼ 【Final complete version】Group member management function event binding ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ Replacement end ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【Recovered】Event for removing members
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【Recovered】Event for adding from friend list
    // 【Key】for\"Done\"Button binding\"Add people to group\"'s logic
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // Use clone node method to clear old event listeners, prevent duplicate binding
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【Brand new】Video call function event listener ▼▼▼

// Bind the initiation buttons for single and group chats
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// Bind\"Hang up\"Button
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// Bind\"Cancel call\"Button
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【Brand new】Bind\"Join call\"Button
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ Use this【Fixed and activated spectator mode】's version replaces old decline-call-btn event listener ▼▼▼
// Bind incoming call request's\"Decline\"Button
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
    
    // 【Core fix】Here, we connect the rejection logic with the API call
    if (videoCallState.isGroupCall) {
        videoCallState.isUserParticipating = false; // Mark user as spectator
        
        // 1. Create a hidden message, notify AI user rejected
        const systemNote = {
            role: 'system',
            content: `[system prompt:The user rejected the call invitation, but you can start yourselves. Please each of you decide whether to join.]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        
        // 2. 【Key】Trigger AI response, let them decide themselves whether to start a group chat
        // This will be processed in the background, if the AIs decide to start, will eventually call startVideoCall()
        await triggerAiResponse(); 
        
    } else { // Single chat rejection logic remains unchanged
        const declineMessage = { role: 'user', content: 'I rejected your video call request.', timestamp: Date.now() };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // Go back to chat interface and display rejection message
        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);
        
        // Let AI respond to your rejection
        triggerAiResponse();
    }
    
    // Clean up state, just in case
    videoCallState.isAwaitingResponse = false;
});
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ Use this【Fixed duplicate avatar BUG】's version replaces old accept-call-btn event listener ▼▼▼
// Bind incoming call request's\"Accept\"Button
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    videoCallState.activeChatId = state.activeChatId;
    
    // 【Core fix】We no longer manually add users to the participants list here
    if (videoCallState.isGroupCall) {
        // For group chats, we only put【The AI that initiated the call】Add to participants list
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            // Clear potentially existing old data, then only add the initiator
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = []; // If the initiator is not found, clear it
        }
    }
    
    // Whether single chat or group chat, directly start the call interface!
    startVideoCall();
});
// ▲▲▲ Replacement end ▲▲▲


// ▼▼▼ Please use this【Added user highlight】's brand new version, completely replaces old user-speak-btn event listener ▼▼▼
// Bind the button for user speaking during a call
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ Core additions:Before popping up the input box, first find and highlight the user avatar ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('You say', 'Please enter what you want to say...');
    
    // ★★★★★ Core additions:Whether the user inputs or not, remove highlight as soon as the input box is closed ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ Replacement end ▲▲▲

// ▼▼▼ 【New addition】Memoir related event binding ▼▼▼
// 1. Connect\"Memories\"tab and its view
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // Before switching, ensure"Favorites"page's edit mode is closed
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // Render on click
});

// 2. Bind the return button of the memoir interface
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ Addition finished ▲▲▲

// 【Brand new】Convention/Countdown function event binding
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('Please fill in the complete appointment title and date!');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('Please enter a valid, future date!');
        return;
    }

    const newCountdown = {
        chatId: null, // User created, not belonging to any specific AI
        authorName: 'me',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【Brand new】Blacklist function event binding
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        'Confirm blacklist', 
        `Are you sure you want to blacklist\"${chat.name}\"? After blacklisting, you will not be able to send messages to them, until you remove them from the blacklist, or wait for them to re-apply for friendship.`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        await db.chats.put(chat);
        
        // Close settings pop-up, and refresh chat interface
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // Refresh chat list, there may be UI changes
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("Manually triggering friend request process, please wait...\nIf the API call is successful, a prompt will pop up. If it fails, there will also be an error prompt. If there is no response for a long time, it means the AI may decide not to apply for now.");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;
        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: 'I approved your friend request', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【New addition】Handle the click event of the apply for friend button
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            'Send friend request', 
            `Please enter what you want to say to\"${chat.name}\"'s application reason:`,
            "Let's make up!"
        );
        // Only when the user has entered content and clicked\"Confirm\"then continue
        if (reason !== null) {
            // Update relationship status to\"Waiting for AI approval\"
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // Refresh UI, display\"Waiting for approval\"'s interface
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【Key】Trigger AI response, let it handle this friend request
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【Brand new】Red packet function event binding ▼▼▼

// 1. Connect the original transfer button(￥)'s click event, redirect to the new main entry function
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. Red packet modal's internal control buttons
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. Red packet modal's tab switch logic
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. Real-time update red packet amount display
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ New event binding end ▲▲▲

// ▼▼▼ 【Newly added】Use event delegation to handle red packet clicks, fix invalidation issue ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. Find the clicked red packet card
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // If what was clicked is not a red packet, do nothing

    // 2. From red packet card's parent.message-bubbleGet timestamp
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. Call our existing handler function
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ End of added code ▲▲▲

// ▼▼▼ 【Brand new】Voting function event listener ▼▼▼
// Add button in the input box toolbar
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// Vote creation modal's button
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// Use event delegation to handle all click events within the vote card
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // Clicked option
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // Clicked action button(End the vote/View results)
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // If it is an ended vote, clicking anywhere on the card can view results
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ New event listener paste end ▲▲▲

  // ▼▼▼ 【Brand new】AIAvatar gallery function event binding ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ Addition finished ▲▲▲

// ▼▼▼ In init() 's event listening area, paste this section【new code】▼▼▼
document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (!iconId) return;

        const currentUrl = state.globalSettings.appIcons[iconId];
        const newUrl = await showCustomPrompt(`Replace\"${item.querySelector('.icon-preview').alt}\"Icon`, 'Please enter new image URL', currentUrl, 'url');

        if (newUrl && newUrl.trim().startsWith('http')) {
            // Only update in memory, waiting for user click\"Save\"
            state.globalSettings.appIcons[iconId] = newUrl.trim();
            // Real-time update settings page's preview image
            item.querySelector('.icon-preview').src = newUrl.trim();
        } else if (newUrl !== null) {
            alert("Please enter a valid URL!");
        }
    }
});
// ▲▲▲ End of new code paste ▲▲▲

// ▼▼▼ In init() At the end of the function, paste this section【Brand new event listener】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // Use .closest() Look upwards for the clicked card
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // Call our function
            }
        }
    });

    // Browser back button's event listener, ensure it's only bound once
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ End of new code paste ▲▲▲

// ▼▼▼ In init() At the end of the function, paste this section【Brand new event listener】 ▼▼▼

    // 1. Bind above the input box\"Share link\"button's click event
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. Bind in the modal box\"Cancel\"button's click event
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. Bind in the modal box\"Share\"button's click event
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ End of new code paste ▲▲▲

        // ===================================================================
        // 5. Start!
            
            showScreen('home-screen');
        }

        init();
    });
</script>
</body>
</html>