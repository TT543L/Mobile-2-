<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EPhone</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/nzP9sgxr/chan-125.png">
    <link rel="manifest" href="manifest.json">
	<script src="dexie.js"></script>
    <style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff; }
        html { height: 100%; overflow: hidden; }

body {
    height: 100%;
    overflow: hidden;
    margin: 0;
    font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #f0f2f5; 
}

#phone-screen {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #000;
}

#status-bar {
    display: none;
}

.header, .qzone-header {
    padding-top: calc(15px + env(safe-area-inset-top));
}


#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

#chat-list-bottom-nav {
     padding-bottom: env(safe-area-inset-bottom);
}

.modal {
    z-index: 1000;
}

        #status-bar { position: absolute; top: 0; left: 0; width: 100%; padding: 0px 20px 12px 20px; display: flex; justify-content: space-between; align-items: center; color: white; z-index: 10; font-size: 14px; box-sizing: border-box; pointer-events: none; }
        #status-bar-time { font-weight: 600; }
        .battery-container { display: flex; align-items: center; gap: 5px; }
        .battery-icon { width: 25px; height: 12px; border: 1px solid white; border-radius: 3px; position: relative; padding: 1px; }
        .battery-icon::after { content: ''; position: absolute; right: -3px; top: 2px; width: 2px; height: 6px; background-color: white; border-radius: 0 1px 1px 0; }
        .battery-level { height: 100%; background-color: white; border-radius: 1px; transition: width 0.5s ease; }
        .battery-container.charging .battery-level { background-color: #4cd964; animation: charge-breath 2s infinite; }
        .battery-container.charging .battery-text { color: #4cd964; }
        @keyframes charge-breath { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 15px 20px; padding-top: 45px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; }
        .header .header-actions { display: flex; align-items: center; gap: 15px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; }

.header .action-btn {
    font-size: 16px;
    font-weight: 600;
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        #home-screen { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding: 20px; padding-top: 80px; padding-bottom: 50px; box-sizing: border-box; background-size: cover; background-position: center; }
        #clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-bottom: 20px; flex-shrink: 0; }
        #main-time { font-size: 80px; font-weight: 200; }
        #main-date { font-size: 18px; font-weight: 500; }
        #app-grid { margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px; }
        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #f0f2f5; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }

#world-book-list {
    flex-grow: 1;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    padding-top: 80px;
    margin-top: -80px;
}

#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    padding-top: 80px; 
    padding-bottom: 50px; 
    box-sizing: border-box;
}

        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn, #selection-delete-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; padding: 5px; }
        #selection-delete-btn { color: #ff3b30; }

#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 10px 15px;
    padding-top: 110px;
    margin-top: -80px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box;
}

        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px;
    margin-bottom: 3px;
    position: absolute; 
    top: -16px;
    left: 0;
}

.message-wrapper {
    display: flex;
    gap: 8px;
    align-items: flex-end;
    position: relative;
    max-width: 90%;
}

.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row;
}

.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; 
}

.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; 
    margin-bottom: 5px; 
    flex-shrink: 0;
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        #chat-input-area { flex-shrink: 0; padding: 8px; background-color: rgba(247, 247, 247, 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 5px; }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 20px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: auto; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        .message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0; background-color: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-color: white; border-radius: 10px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    top: 100%; 
    margin-top: 5px;
    left: 0;
    right: 0;
    max-height: 150px;
    overflow-y: auto;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }

.checkboxes-container label {
    display: block;
    padding: 12px 15px;
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px;
}

        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    font-size: var(--chat-font-size, 13px);
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #3e6224; }

.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word;
}

        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

.change-frame-btn {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    margin-left: 10px;
}

#avatar-frame-modal .modal-content {
    height: 70%;
}

#avatar-frame-modal .modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
}
      
.frame-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.frame-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary);
    border-bottom: 2px solid transparent;
}

.frame-tab.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

.frame-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
}

.frame-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); 
    gap: 15px;
}

.frame-item {
    aspect-ratio: 1 / 1; 
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    padding: 5px;
    transition: all 0.2s ease;
    position: relative; 
}

.frame-item.selected {
    border-color: var(--accent-color);
    transform: scale(1.05);
}

.frame-item .preview-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.frame-item .preview-frame {
    position: absolute;
    top: -7px;
    left: 0;
    width: 100%;
    height: 100%;
}

#font-preview {
    transition: font-family 0.3s ease;}

#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

#chat-list-bottom-nav {
    position: absolute;
    bottom: 0;
	padding-bottom: 50px;
    left: 0;
    width: 100%;
    z-index: 15;
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

#qzone-screen {
    background-color: #f0f2f5;
}

.qzone-header {
    position: relative;
    z-index: 10;
    flex-shrink: 0;
    padding: 15px 20px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.7);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { 
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    /* padding-top: 80px;  <-- 이것을 삭제하세요, header가 더 이상 absolute가 아니므로 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 배경판 높이 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px;
    left: 20px;
    display: flex;
    align-items: flex-end; 
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 위치 미세 조정 */
}

.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; 
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; 
    bottom: 5px; 
}

#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; 
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; 
}

.qzone-edit-btn {
    display: none;
}

#qzone-screen .qzone-header {
    display: none;
}

#qzone-screen.active .qzone-header {
    display: flex;
}

#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-list-item:first-child,
.chat-group-container:first-child {
    margin-top: 10px; 
}

.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; 
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

#qzone-posts-list {
    padding: 0 15px 20px 15px; 
    display: flex;
    flex-direction: column;
    gap: 20px; 
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; 
    word-break: break-word; 
}

#post-public-text {
    min-height: 80px; 
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; 
    background-color: #f0f2f5;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; 
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; 
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #ff3b30;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none;
}

.post-mode-content.active {
    display: block; 
}

#album-screen {
    background-color: #f0f2f5; 
}

#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); 
    gap: 15px;
}

.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; 
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1;
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #f0f2f5; 
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

#album-photos-screen {
    background-color: #f0f2f5;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; 
    aspect-ratio: 1 / 1; 
    border-radius: 6px;
    overflow: hidden; 
    background-color: #e9ecef; 
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; 
    cursor: pointer;
}

.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; 
    transition: opacity 0.2s ease;
}

.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw; 
    max-height: 85vh; 
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    transition: opacity 0.2s ease-in-out;
}

#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

#photo-viewer-modal .nav-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; 
    font-weight: 100;
    cursor: pointer;
    padding: 10px;
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; 
}

#photo-viewer-prev-btn {
    left: 5px; 
}

#photo-viewer-next-btn {
    right: 5px; 
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

.post-main-content {
}

.post-feedback-icons {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 12px;
    padding: 8px 0; 
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); 
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.action-icon.active {
    color: #ff5252; 
    transform: scale(1.1); 
}

.action-icon.active.favorite {
    color: #ffc107; 
}

.action-icon.active svg {
    fill: currentColor; 
}

.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}

.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; 
    display: flex;
    align-items: center;
    gap: 8px; 
}

.comment-section {
    flex-grow: 1; 
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

.comment-send-btn {
    flex-shrink: 0; 
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #ff3b30;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

.back-btn-indicator {
    top: 0;
    right: -8px;
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

.post-comments-container {
    padding: 10px 0; 
    display: flex;
    flex-direction: column;
    gap: 8px; 
    font-size: 13px; 
}

.comment-item {
    line-height: 1.5;
}

.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; 
}

.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}

.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; 
    padding: 8px 10px; 
    font-size: 13px;
    color: var(--accent-color); 
    background-color: #f0f5fa; 
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; 
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; 
    flex-shrink: 0; 
}

.at-mention-popup {
    position: absolute; 
    bottom: 100%; 
    left: 40px; 
    width: calc(100% - 40px); 
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; 
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}

#favorites-view {
    display: flex;
    flex-direction: column;
}

#favorites-view > .header {
    flex-shrink: 0;
}

#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; 
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; 
}

.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; 
}

.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #ff3b30;
}

.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; 
    position: relative; 
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; 
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; 
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}

#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

#chat-interface-screen .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen .selection-controls .action-btn {
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    padding: 5px;
}

#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; 
}

#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

#favorites-action-bar {
    position: absolute; 
    bottom: 0;
    left: 0;
    right: 0; 
    width: auto; 
    padding: 10px 15px;
    padding-bottom: calc(50px + env(safe-area-inset-bottom)); 
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}

#chat-interface-screen .header .selection-controls {
    display: none;
}

#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px; 
    font-weight: 300; 
    position: relative; 
    top: -1px; 
}

#settings-preview-area {
    width: 100%;
    height: 180px; 
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; 
    display: flex;
    flex-direction: column;
    gap: 10px; 
    border: 1px solid var(--border-color);
    position: relative; 
}

#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}
#settings-preview-area .avatar-with-frame {
     width: 30px;
    height: 30px;
}
#settings-preview-area .avatar-with-frame .avatar-frame {
    width: 44px;
    height: 44px;
    top: -7px;
    left: -7px;
}
#settings-preview-area .message-bubble .timestamp {
    display: none; 
}

.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}

.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}

.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; 
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}

.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap; 
}

.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; 
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

.post-actions-btn {
    margin-left: auto; 
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; 
    color: white !important; 
}

#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

.avatar-group {
    width: 34px; 
    flex-shrink: 0;
    position: relative;
    transition: width 0.2s ease; 
}

.avatar-group.has-frame {
    width: 42px; 
}

.message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 20%;
    object-fit: cover;
}

.avatar-with-frame {
    position: relative;
    width: 34px;
    height: 34px;
    margin: 0 auto;
    transition: all 0.2s ease; 
}

.avatar-group.has-frame .avatar-with-frame {
    width: 43px; 
    height: 43px;
}

.avatar-with-frame .avatar-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    z-index: 1;
}

.avatar-with-frame .avatar-frame {
    position: absolute;
    width: 52px;
    height: 52px;
    top: -9px;   
    left: -4px;  
    z-index: 2;
    pointer-events: none;
}

.header > span:nth-child(2),
#chat-header-title {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); 
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; 
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
}

.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}

#member-management-list {
    padding: 0; 
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #ff3b30;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #4cd964; 
}

.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; 
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}

.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; 
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    content: "제가 계산했어요, 맛있게 즐기세요~" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; 
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; 
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    content: "대리 결제 요청을 거절했습니다" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; 
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

.message-bubble[class*="status-"] .request-title {
    font-size: 0; 
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; 
}
.message-bubble.status-paid .request-title::after {
    content: "제가 계산했어요, 맛있게 즐기세요~";
}
.message-bubble.status-rejected .request-title::after {
    content: "대리 결제 요청을 거절했습니다";
}

.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; 
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}

#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#memories-view,
#contact-picker-screen,
#member-management-screen,
#world-book-editor-screen {  
    background-color: var(--secondary-bg);
}

#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    background-color: var(--secondary-bg);
}

#wallpaper-screen .form-container {
    align-items: center; 
}

#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #ff3b30;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}

.call-action-btn.accept {
    background-color: #4cd964;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.video-call-top-bar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    padding: 15px 20px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    text-align: center;
    box-sizing: border-box;
    pointer-events: none;
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}
.video-call-controls {
    position: absolute;
    bottom: 0; left: 0; width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    box-sizing: border-box;
}

.video-call-avatar-area {
    flex-grow: 1; 
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: 80px; 
    box-sizing: border-box;
    overflow-y: auto; 
}

#participant-avatars-grid {
    display: flex;
    flex-wrap: wrap; 
    justify-content: center;
    align-items: center;
    gap: 15px; 
    max-width: 100%;
}

.participant-avatar-wrapper {
    position: relative;
    text-align: center;
    flex-shrink: 0;
}
.participant-avatar {
    width: 70px; 
    height: 70px; 
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 12px;
    color: #ccc;
}

.participant-avatar.speaking {
    border-color: #4cd964;
    box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
    transform: scale(1.05);
}

#video-call-main {
    flex-shrink: 0; 
    height: 30%; 
    margin: 15px 15px 130px 15px; 
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    box-sizing: border-box;
}

.control-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, background-color 0.2s;
}
.control-btn:active {
    transform: scale(0.9);
}
.control-btn.speak-btn {
    background-color: rgba(255,255,255,0.2);
    background-size: 55%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
}
.control-btn.hangup-btn {
    background-color: #ff3b30;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}
.control-btn.join-btn {
    background-color: #007bff;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
}

.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; 
}

.call-message-bubble.user-speech {
    background-color: #4cd964; 
    align-self: flex-end; 
    text-align: left; 
}

#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; 
    align-items: center; 
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; 
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.qzone-post-container {
    position: relative; 
    overflow: hidden; 
    border-radius: 12px; 
}

.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); 
    position: relative; 
    z-index: 2;
}

.qzone-post-delete-action {
    position: absolute; 
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; 
    background-color: #ff3b30; 
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; 
}

.qzone-post-item.swiped {
    transform: translateX(-90px); 
}

@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

.system-message {
    align-self: center; 
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}

.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 
    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

#chat-header-title-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; 
    gap: 2px;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    max-width: 60%;
}

#chat-header-title {
    font-size: 16px; 
    font-weight: 600;
    position: static; 
    transform: none; 
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #4cd964; 
    transition: background-color 0.3s ease;
}

#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

.status-text {
    font-weight: 500;
}

.memory-card {
    background-color: #fffaf0; 
    border-radius: 12px;
    padding: 15px; 
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; 
    flex-direction: column; 
    gap: 8px; 
}

.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); 
    padding-bottom: 8px; 
}

.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

.countdown-card {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 150; 
    display: none; 
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: center;
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}

.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700;
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}

.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}

.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; 
}

.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #ff3b30;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
    font-style: italic;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 10px;
    font-size: 12px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
}

#wallpaper-screen .form-container {
    min-height: 0; 
}

#wallpaper-preview {
    flex-shrink: 0; 
}

#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 250px;
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px; 
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex; 
    flex-direction: column;
    gap: 8px; 
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; 
    align-items: center;
    gap: 6px; 
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; 
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; 
}
    </style>
</head>
<body>
        <div id="phone-screen">
            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>
            
            <div id="home-screen" class="screen active">
                <div id="clock-container"><div id="main-time">12:00</div><div id="main-date">월요일, 1월 1일</div></div>

<div id="app-grid">
    <div class="app-row">
        <div class="app-icon" onclick="showScreen('world-book-screen')">
            <div class="icon-bg">
                <img id="icon-img-world-book" src="https://i.postimg.cc/mZ0vV6tT/IMG-6907.jpg" alt="월드인포">
            </div>
            <span class="label">월드인포</span>
        </div>
        <div class="app-icon" onclick="showScreen('chat-list-screen')">
            <div class="icon-bg">
                <img id="icon-img-qq" src="https://i.postimg.cc/gJ7Dz5fj/IMG-6906.jpg" alt="QQ">
            </div>
            <span class="label">QQ</span>
        </div>
    </div>
    <div class="app-row">
        <div class="app-icon" onclick="showScreen('api-settings-screen')">
            <div class="icon-bg">
                <img id="icon-img-api-settings" src="https://i.postimg.cc/RhnTNdBR/IMG-6908.jpg" alt="API설정">
            </div>
            <span class="label">API설정</span>
        </div>
        <div class="app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg">
                <img id="icon-img-wallpaper" src="https://i.postimg.cc/WbgQy6kg/IMG-6909.jpg" alt="외관 설정">
            </div>
            <span class="label">외관 설정</span>
        </div>
        <div class="app-icon" onclick="showScreen('font-settings-screen')">
            <div class="icon-bg">
                <img id="icon-img-font" src="https://files.catbox.moe/j1kn1a.jpeg" alt="글꼴">
            </div>
            <span class="label">글꼴</span>
        </div>
    </div>
</div>
            </div>
          
            <div id="world-book-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>월드인포</span><span class="action-btn" id="add-world-book-btn">+</span></div><div id="world-book-list"></div></div>
            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">월드인포 편집</span>
                    <span class="save-btn" id="save-world-book-btn">저장</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">책 제목</label>
                        <input type="text" id="world-book-name-input" placeholder="월드인포 이름을 입력해 주세요...">
                    </div>
                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">내용</label>
                        <textarea id="world-book-content-input" placeholder="여기에 자세한 세계관 설정을 입력하세요..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 설정</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">팁: 사용하려면\"이미지 전송\"기능을 사용하려면, 반드시 Vision을 지원하는(시각)모델을 선택하세요, 예:<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>또는<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>.</p><div class="form-group"><label for="proxy-url">리버스 프록시 주소 (추가할 필요 없음/v1오~)</label><input type="text" id="proxy-url" placeholder="예시: https://api.openai.com"></div><div class="form-group"><label for="api-key">키 (API Key)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">모델</label><select id="model-select"></select></div><button class="form-button" id="fetch-models-btn">모델 가져오기</button>

<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        백그라운드 캐릭터 활동 활성화
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            경고:이 기능은 API 호출과 비용을 현저하게 증가시킵니다!
        </p>
    </label>
    <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
</div>
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="background-interval-input" style="margin-bottom: 0;">
        백그라운드 활동 감지 간격 (초)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            권장 값 60-300.값이 클수록, 비용은 낮아지지만, 캐릭터 반응은 느려집니다.
        </p>
    </label>
    <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
</div>
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI차단 후 냉각기 (시간)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            이 시간 이후에 차단된 AI만 친구 신청을 다시 할 기회가 있습니다.
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>

<button class="form-button" id="save-api-settings-btn">설정 저장</button>
			<hr style="margin:20px 0; opacity:.3">
			<button class="form-button" id="export-data-btn">데이터 내보내기</button>

<button class="form-button" id="import-btn">백업 파일 가져오기</button>

<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<div id="chat-list-screen" class="screen">
    
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>메시지</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="그룹 채팅 생성"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
        </div>
    </div>
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span>
            <span>친구 피드</span>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="배경">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="프로필 사진">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>글</span></div>
                <div class="action-item" id="create-post-btn"><span>피드</span></div>
                <div class="action-item" id="open-album-btn"><span>앨범</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>내 컬렉션</span>
        <span class="action-btn" id="favorites-edit-btn">편집</span>
    </div>
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="컬렉션의 제목, 내용 또는 작성자 검색...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
        </div>
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">삭제 (0)</button>
</div>
    </div>
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>우리의 추억</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
    </div>
</div>
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>메시지</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>피드</span>
    </div>
    <div class="nav-item" data-view="memories-view">
        <span>추억</span>
    </div>
    <div class="nav-item" data-view="favorites-view">
        <span>컬렉션</span>
    </div>
</div>
</div>
<div id="album-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>내 앨범</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    <div class="list-container">
        <div id="album-grid-page">
        </div>
    </div>
</div>
<div id="album-photos-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">앨범 이름</span>
        <span class="action-btn" id="album-upload-photo-btn">업로드</span>
    </div>
    <div class="list-container">
        <div id="photos-grid-page">
        </div>
<div id="photo-viewer-modal" class="modal">
    <button id="photo-viewer-close-btn">×</button>
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="전체 화면 사진 미리보기">
    </div>
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
    </div>
</div>
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
<div id="chat-interface-screen" class="screen">
    <div class="header">
        <div class="default-controls">
            <span class="back-btn" id="back-to-list-btn">‹</span>
            <div id="chat-header-title-wrapper">
                <span id="chat-header-title">채팅 상대</span>
                <div id="chat-header-status">
                    <span class="status-dot"></span>
                    <span class="status-text">온라인</span>
                </div>
            </div>

            <div class="header-actions">
                <span class="action-btn" id="listen-together-btn" title="함께 듣기"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="함께 듣기"></span>
                <span class="action-btn" id="chat-settings-btn" title="채팅 설정"><img src="https://i.postimg.cc/R04MT1MV/210-20250618115233.png" alt="설정"></span>
            </div>
        </div>

        <div class="selection-controls">
            <span id="selection-cancel-btn">취소</span>
            <span id="selection-count"></span>
            <div class="header-actions">
               <span id="selection-favorite-btn" class="action-btn">컬렉션</span>
               <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">삭제</span>
            </div>
        </div>
    </div>
    
    <div id="chat-messages"><div id="typing-indicator">상대방이 입력 중입니다...</div></div>

    <div id="chat-input-area">
        <div id="chat-input-actions-top">
            <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="이모티콘 패널">+</button>
            <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="사진 보내기"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></button>
            <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="이미지 업로드"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-primary);"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button id="transfer-btn" class="chat-action-icon-btn action-button" title="송금">￥</button>
            <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="음성 보내기"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg></button>
<button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="배달 요청 시작"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg></button>
<button id="video-call-btn" class="chat-action-icon-btn action-button" title="영상 통화"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
<button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="그룹 영상 통화"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
<button id="send-poll-btn" class="chat-action-icon-btn action-button" title="투표 시작"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg></button>
<button id="share-link-btn" class="chat-action-icon-btn action-button" title="링크 공유"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
        </div>
        <div id="chat-input-main-row">
            <textarea id="chat-input" rows="1" placeholder="메시지 입력..."></textarea>
            <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="답장 기다리는 중"><img src="https://i.postimg.cc/2SwjsfZQ/IMG-6913.gif" alt="답장 기다리는 중"></button>
                <button id="send-btn" class="action-button">보내기</button>
            </div>
        </div>
    </div>
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
    <div id="sticker-panel">
        <div id="sticker-panel-header">
            <span class="panel-btn" id="close-sticker-panel-btn">취소</span>
            <span class="title">내 이모티콘</span>
            <div style="display: flex; gap: 10px;">
              <span class="panel-btn" id="add-sticker-btn">추가</span>
              <span class="panel-btn" id="upload-sticker-btn">업로드</span>
            </div>
        </div>
        <div id="sticker-grid"></div>
    </div>
    <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <div id="music-player-overlay">
        <div class="music-player-window">
            <span id="music-playlist-btn">☰</span>
            <div id="music-time-counter">0.0시간을 함께 들었습니다</div>
            <div id="music-player-song-title">노래를 추가해주세요</div>
            <div id="music-player-artist">...</div>
            <div class="music-controls">
                <button id="music-prev-btn">◀</button>
                <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                <button id="music-next-btn">▶</button>
                <button id="music-mode-btn">순서</button>
            </div>
            <div class="music-bottom-actions">
                <button id="music-exit-btn">함께 듣기 종료</button>
                <button id="music-return-btn">채팅으로 돌아가기</button>
            </div>
        </div>
    </div>
    
    <div id="music-playlist-panel">
        <div class="playlist-header">
            <span class="panel-btn" id="close-playlist-btn">돌아가기</span>
            <span>재생 목록</span>
            <div>
                <span class="panel-btn" id="add-song-local-btn">로컬</span>
                <span class="panel-btn" id="add-song-url-btn">URL</span>
            </div>
        </div>
        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
</div>

<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>외관 설정</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <div id="wallpaper-preview">아래를 클릭하여 업로드</div>
        <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">배경 화면 업로드</button>
        <input type="file" id="wallpaper-upload-input" accept="image/*">
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 아이콘 설정</label>
        </div>
        <div id="icon-settings-grid">
        </div>
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">모든 모양 설정 저장</button>
    </div>
</div>
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
    </div>
</div>

<div id="font-settings-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>글꼴 설정</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="font-url-input">글꼴 파일 URL (.ttf, .otf, .woff등)</label>
            <input type="text" id="font-url-input" placeholder="https://..../font.ttf">
        </div>

        <div class="form-group">
            <label>실시간 미리보기</label>
            <div id="font-preview" style="padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: #f9f9f9;">
                <p style="font-size: 20px; margin: 0 0 10px 0;">안녕하세요 세계 Hello World</p>
                <p style="margin: 0;">이것은 글꼴 미리보기 효과입니다,12345.</p>
            </div>
        </div>

        <button class="form-button" id="save-font-btn">저장 및 적용</button>
        <button class="form-button form-button-secondary" id="reset-font-btn">기본 글꼴로 복원</button>
    </div>
</div>

<div id="contact-picker-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">취소</span>
        <span>연락처 선택</span>
        <span class="save-btn" id="confirm-contact-picker-btn">완료(0)</span>
    </div>
    <div class="list-container" id="contact-picker-list">
    </div>
</div>

<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>그룹 멤버 관리</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">친구 목록에서 추가</button>
        <button id="create-new-member-btn">그룹 내 새 멤버 생성</button>
    </div>
</div>

<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">영상 통화에 초대합니다</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>거절</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>받기</span>
            </div>
        </div>
    </div>
</div>

<div id="video-call-screen" class="screen">
    <div class="video-call-top-bar">
        <span id="call-timer">00:00</span>
    </div>
    
    <div class="video-call-avatar-area">
        <div id="participant-avatars-grid">
        </div>
    </div>

    <div id="video-call-main" class="video-call-main">
    </div>
    
    <div class="video-call-controls">
        <button id="user-speak-btn" class="control-btn speak-btn"></button>
        <button id="hang-up-btn" class="control-btn hangup-btn"></button>
        <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
    </div>
</div>

<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">통화 중...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>취소</span>
        </div>
    </div>
</div>
        </div>
    </div>
  
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>채팅 설정</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">별명 / 그룹 이름</label><input type="text" id="chat-name-input"></div>
    <div class="form-group" id="assign-group-section" style="display: none;">
        <label for="assign-group-select">친구 그룹</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
            </select>
            <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">그룹 관리</button>
        </div>
    </div>

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">내 그룹 닉네임</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>그룹 아바타</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">그룹 아바타 업로드</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>월드인포 연결 (다중 선택 가능)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 클릭하여 선택 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <div class="form-group" id="ai-persona-group"><label for="ai-persona">상대방 페르소나 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div><div class="form-group" id="ai-avatar-group"><label>상대방 아바타</label><div class="avatar-upload"><img id="ai-avatar-preview"><button onclick="document.getElementById('ai-avatar-input').click()">상대방 아바타 업로드</button><button id="manage-ai-avatar-library-btn" class="form-button-secondary" style="margin-top:0; padding: 8px 12px; font-size: 14px;">아바타 라이브러리 관리</button>
<button class="change-frame-btn" data-type="ai">아바타 프레임 변경</button><input type="file" id="ai-avatar-input" accept="image/*"></div></div><div class="form-group" id="my-persona-group"><label for="my-persona">내 페르소나 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div><div class="form-group" id="my-avatar-group"><label>내 아바타</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()">내 아바타 업로드</button><button class="change-frame-btn" data-type="my">아바타 프레임 변경</button><button id="open-persona-library-btn">프리셋</button><input type="file" id="my-avatar-input" accept="image/*"></div></div><div class="form-group" id="group-members-group"><label>그룹 멤버 페르소나</label><div id="group-members-settings"></div>
    
    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">그룹 멤버 관리</button></div>
<div class="form-group"><label for="max-memory">맥락 기억 개수</label><input type="number" id="max-memory" value="10"></div><div class="form-group"><label>채팅 버블 테마 <button id="reset-theme-btn" type="button">재설정</button></label><div class="theme-selector"><label><input type="radio" name="theme-select" value="default" id="theme-default"> 기본</label><label><input type="radio" name="theme-select" value="pink_blue"> 분홍 파랑</label><label><input type="radio" name="theme-select" value="blue_white"> 파랑 하양</label><label><input type="radio" name="theme-select" value="purple_yellow"> 보라 노랑</label><label><input type="radio" name="theme-select" value="black_white"> 검정 하양</label><label><input type="radio" name="theme-select" value="yellow_white"> 노랑 하양</label><label><input type="radio" name="theme-select" value="red_black"> 빨강 검정</label><label><input type="radio" name="theme-select" value="blue_yellow"> 파랑 노랑</label><label><input type="radio" name="theme-select" value="pink_yellow"> 분홍 노랑</label><label><input type="radio" name="theme-select" value="pink_purple"> 분홍 보라</label><label><input type="radio" name="theme-select" value="gray_white"> 회색 하양</label><label><input type="radio" name="theme-select" value="blue_green"> 파랑 초록</label><label><input type="radio" name="theme-select" value="pink_white"> 분홍 하양</label><label><input type="radio" name="theme-select" value="pink_black"> 분홍 검정</label><label><input type="radio" name="theme-select" value="pink_green"> 분홍 초록</label><label><input type="radio" name="theme-select" value="green_black"> 초록 검정</label></div></div>

<div class="form-group">
    <label for="font-size-slider">채팅 글꼴 크기 <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>

<div class="form-group">
    <label for="custom-css-input">
        사용자 지정 버블 스타일 (CSS)
        <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">재설정</button>
    </label>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 예시:에\"내\"버블에 그라데이션 배경과 그림자 추가 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
</div>
<!-- ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 이 새 코드를 사용자 지정 CSS 입력 상자의 form에 붙여넣으세요-group 다음에 ▼▼▼ -->
<div class="form-group">
    <label>실시간 미리보기</label>
    <div id="settings-preview-area">
        <!-- JS여기에 미리보기 내용이 생성됩니다 -->
    </div>
</div>
<!-- ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲ -->

            <div class="form-group">
                <label>채팅 배경</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">배경 이미지 업로드</button>
                    <button type="button" id="remove-bg-btn">배경 제거</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">상대방 차단</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">채팅 기록 지우기</button></div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">취소</button><button class="save" id="save-chat-settings-btn">저장</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>내 페르소나 라이브러리</span><button id="add-persona-preset-btn" class="action-button">추가</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">닫기</button></div></div></div>
    
    <div id="persona-editor-modal" class="modal"><div class="modal-content"><div class="modal-header"><span id="persona-editor-title">페르소나 프리셋 추가</span></div><div class="modal-body"><div class="form-group"><label>프리셋 아바타</label><div class="avatar-upload"><img id="preset-avatar-preview"><button onclick="document.getElementById('preset-avatar-input').click()">아바타 업로드</button><input type="file" id="preset-avatar-input" accept="image/*"></div></div><div class="form-group"><label for="preset-persona-input">프리셋 페르소나</label><textarea id="preset-persona-input" rows="4" placeholder="이 페르소나의 자세한 설정을 여기에 입력하세요..."></textarea></div></div><div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">취소</button><button class="save" id="save-persona-preset-btn">저장</button></div></div></div>

    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>그룹 멤버 편집</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">이름</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">페르소나</label><textarea id="member-persona-input" rows="4"></textarea></div>
    <div class="form-group"><label>프로필 사진</label><div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">아바타 업로드</button><button class="change-frame-btn" data-type="member">아바타 프레임 변경</button><input type="file" id="member-avatar-input" accept="image/*"></div></div>
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">취소</button><button class="save" id="save-member-settings-btn">저장</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">취소</button>
                <button id="custom-modal-confirm" class="confirm-btn">확인</button>
            </div>
        </div>
    </div>
    
    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">프리셋 편집</button>
                <button id="preset-action-delete" class="btn-danger">프리셋 삭제</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">취소</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">그/그녀에게 깜짝 선물을!</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">송금 금액</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">비고 (선택 사항)</label>
                <input type="text" id="transfer-note" placeholder="당신의 마음을 남겨주세요~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">취소</button>
                <button id="transfer-confirm-btn">송금 확인</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

<!-- 아바타 프레임 선택 모달 창 (새로 추가된 것입니다) -->
    <div id="avatar-frame-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>아바타 프레임 선택</span>
            </div>
            <div class="modal-body">
                <div class="frame-tabs">
                    <div id="ai-frame-tab" class="frame-tab active">상대방의</div>
                    <div id="my-frame-tab" class="frame-tab">내</div>
                </div>
                <div id="ai-frame-content" class="frame-content">
                    <div id="ai-frame-grid" class="frame-grid">
                        <!-- AI아바타 프레임이 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
                <div id="my-frame-content" class="frame-content" style="display: none;">
                     <div id="my-frame-grid" class="frame-grid">
                        <!-- 내 아바타 프레임이 여기에 동적으로 생성됩니다 -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel" id="cancel-frame-settings-btn">취소</button>
                <button class="save" id="save-frame-settings-btn">저장</button>
            </div>
        </div>
    </div>

    <audio id="audio-player" style="display:none;"></audio>

<!-- ▼▼▼ 아래 코드를 사용하여【전체】모달 창 코드로, 기존의 id를 대체하세요="create-post-modal" 의 전체 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span>게시물 발행</span>
        </div>
        <div class="modal-body">
            <!-- 공개 텍스트 입력 영역 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="새로운 소식 공유...(필수가 아닌 공개 텍스트)"></textarea>
            </div>

            <!-- === 모드 전환 스위치 (새로 추가) === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">이미지 업로드</button>
                <button id="switch-to-text-image-mode" class="mode-btn">텍스트 이미지 사용</button>
            </div>

<!-- ▼▼▼ 【수정 후】의 공개 범위 설정 ▼▼▼ -->
<div class="form-group">
    <label>공개 범위</label>
    <div id="post-visibility-options" style="display: flex; gap: 15px; margin-bottom: 10px;">
        <label><input type="radio" name="visibility" value="public" checked> 공개</label>

        <label><input type="radio" name="visibility" value="include"> 특정 그룹 공개</label>
    </div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
        <!-- 그룹 다중 선택 상자는 JS에 의해 동적으로 생성됩니다 -->
    </div>
</div>
<!-- ▲▲▲ 수정 끝 ▲▲▲ -->

            <!-- === 이미지 모드 영역 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
<div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="이미지 미리보기">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">로컬 업로드</button>
                        <button id="post-use-url-btn" class="form-button-secondary">네트워크 URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>이미지 설명 (필수 입력, AI에게 보여줄 내용)</label>
                    <input type="text" id="post-image-description" placeholder="이미지 내용을 간단히 설명하여 AI가 이해하도록 돕습니다.">
                </div>
            </div>

            <!-- === 텍스트 이미지 모드 영역 (새로 추가) === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>텍스트 이미지 (AI가 이해하는 데 사용되는 설명, 이미지를 클릭하면 볼 수 있습니다.)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="여기에 이미지 설명을 작성하세요..."></textarea>
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">취소</button>
            <button class="save" id="confirm-create-post-btn">게시</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 대체 끝 ▲▲▲ -->

<!-- ▼▼▼ 이 새로운 모달 HTML을 다른 모든 모달 뒤에 붙여넣으십시오 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>친구 그룹 관리</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>새 그룹 만들기</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="그룹 이름 입력..." style="flex-grow: 1;">
                    <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">추가</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 그룹 목록은 JS에 의해 동적으로 생성됩니다 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">완료</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 이 새로운 HTML을 모든 모달 끝에 붙여넣으십시오 ▼▼▼ -->
<div id="message-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <!-- 새로운 작업 버튼 -->
            <button id="edit-message-btn">메시지 편집</button>
            <button id="copy-message-btn">텍스트 복사</button>
            <button id="select-message-btn">다중 선택 모드</button>
            <!-- 취소 버튼 -->
            <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">취소</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 이 새로운 HTML을 모든 모달 끝에 붙여넣으십시오 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">게시물 편집</button>
            <button id="copy-post-btn">내용 복사</button>           
            <button id="cancel-post-action-btn">취소</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 【새로운】시각적 메시지 편집기 모달 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>메시지 편집 및 분할</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 편집기 컨테이너, JS가 여기에 텍스트 상자를 동적으로 생성합니다 -->
            <div id="message-editor-container"></div>
            <!-- 새 메시지 추가 버튼 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 다음 메시지 추가
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">취소</button>
            <button class="save" id="save-advanced-editor-btn">변경 사항 저장</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 【새로운】배달 요청 모달 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>배달 대리 결제 요청</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">상품 정보</label>
                <input type="text" id="waimai-product-info" placeholder="예시:양지간로 한 잔">
            </div>
            <div class="form-group">
                <label for="waimai-amount">대리 결제 금액 (원)</label>
                <input type="number" id="waimai-amount" placeholder="예시:21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">취소</button>
            <button class="save" id="waimai-confirm-btn">요청 시작</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【새로운】새로운 약속 만들기/카운트다운 모달 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>새로운 약속 만들기</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">약속 제목</label>
                <input type="text" id="countdown-title-input" placeholder="예시:내 생일">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">약속 날짜 및 시간</label>
                <input type="datetime-local" id="countdown-date-input">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">취소</button>
            <button class="save" id="confirm-create-countdown-btn">약속 저장</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 【새로운】빨간 봉투 보내기 모달 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>빨간 봉투 보내기</span>
        </div>
        <div class="modal-body" style="padding: 0;">
            <!-- 1. 탭 전환 -->
            <div class="frame-tabs">
                <div id="rp-tab-group" class="frame-tab active">무작위 금액 빨간 봉투</div>
                <div id="rp-tab-direct" class="frame-tab">전용 빨간 봉투</div>
            </div>

            <!-- 2. 무작위 금액 빨간 봉투 내용 영역 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>총 금액 (원)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>빨간 봉투 개수</label>
                    <input type="number" id="rp-group-count" placeholder="빨간 봉투 개수 입력">
                </div>
                <div class="form-group">
                    <label>축하 메시지</label>
                    <input type="text" id="rp-group-greeting" placeholder="부자 되세요, 만사형통하세요!">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">빨간 봉투에 돈 넣기</button>
            </div>

            <!-- 3. 전용 빨간 봉투 내용 영역 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>보내기</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>금액 (원)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>축하 메시지</label>
                    <input type="text" id="rp-direct-greeting" placeholder="부자 되세요, 만사형통하세요!">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">빨간 봉투에 돈 넣기</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">취소</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 【새로운】빨간 봉투 상세 모달 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">의 빨간 봉투</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">원</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 수령 내역은 JS에 의해 여기에 동적으로 생성됩니다 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">닫기</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->
<!-- ▼▼▼ 【새로운】투표 만들기 모달 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>투표 시작</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">투표 문제</label>
                <textarea id="poll-question-input" rows="2" placeholder="예시:오늘 밤 우리 무슨 영화 볼까?"></textarea>
            </div>
            <div class="form-group">
                <label>투표 옵션 (최소 2개)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 투표 옵션은 JS에 의해 여기에 동적으로 생성됩니다 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 옵션 추가</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">취소</button>
            <button class="save" id="confirm-create-poll-btn">투표 시작</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 【새로운】AI아바타 라이브러리 관리 모달 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="ai-avatar-library-title">상대방의 아바타 라이브러리</span>
            <button id="add-ai-avatar-btn" class="action-button">추가</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 아바타 라이브러리 내용은 JS에 의해 동적으로 생성됩니다 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">닫기</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<!-- ▼▼▼ 【새로운】사용자 링크 공유 모달 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>링크 공유</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">제목</label>
                <input type="text" id="link-title-input" placeholder="게시물 또는 링크 제목 입력">
            </div>
            <div class="form-group">
                <label for="link-description-input">요약 (선택 사항)</label>
                <textarea id="link-description-input" rows="2" placeholder="링크 내용을 간단히 설명"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">출처 이름 (선택 사항)</label>
                <input type="text" id="link-source-input" placeholder="예시:즈후 일보, 빌리빌리">
            </div>
            <div class="form-group">
                <label for="link-content-input">전체 내용 (선택 사항, 브라우저 내 표시용)</label>
                <textarea id="link-content-input" rows="4" placeholder="전체 게시물 내용 붙여넣기 또는 입력"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">취소</button>
            <button class="save" id="confirm-share-link-btn">공유</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 새 HTML 붙여넣기 끝 ▲▲▲ -->

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 모든 변수 및 상수 정의
        // ===================================================================
        const db = new Dexie('GeminiChatDB');
        // --- 수정 완료 ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
        // --- 수정 끝 ---
        let musicState = { isActive: false, activeChatId: null, isPlaying: false, playlist: [], currentIndex: -1, playMode: 'order', totalElapsedTime: 0, timerId: null };
        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingFrameForMember = false;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;

let waimaiTimers = {}; // 배달 카운트다운 저장용

let activeMessageTimestamp = null;
let activePostId = null; // <-- 새로 추가:현재 작업 중인 게시물 ID 저장용

        let photoViewerState = {
            isOpen: false,
            photos: [], // 현재 앨범의 모든 사진 URL 저장
            currentIndex: -1, // 현재 보고 있는 사진 인덱스
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

const frameModal = document.getElementById('avatar-frame-modal');
const aiFrameTab = document.getElementById('ai-frame-tab');
const myFrameTab = document.getElementById('my-frame-tab');
const aiFrameContent = document.getElementById('ai-frame-content');
const myFrameContent = document.getElementById('my-frame-content');
const aiFrameGrid = document.getElementById('ai-frame-grid');
const myFrameGrid = document.getElementById('my-frame-grid');

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

// ▼▼▼ JS 상단 변수 정의 영역에 이 새 상수 추가 ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/mZ0vV6tT/IMG-6907.jpg',
    'qq': 'https://i.postimg.cc/gJ7Dz5fj/IMG-6906.jpg',
    'api-settings': 'https://i.postimg.cc/RhnTNdBR/IMG-6908.jpg',
    'wallpaper': 'https://i.postimg.cc/WbgQy6kg/IMG-6909.jpg',
    'font': 'https://files.catbox.moe/j1kn1a.jpeg'
};
// ▲▲▲ 추가 종료 ▲▲▲

        const avatarFrames = [ { id: 'none', url: '', name: '없음' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
      { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
    { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },

  { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
  
  
{ id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
{ id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
  { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
  { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
  
  ];

        let currentFrameSelection = { ai: null, my: null };
        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '확인';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '확인';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '확인';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }

// ▼▼▼ 이것을 사용하십시오【기능 강화 버전】이전 showCustomPrompt 함수를 대체하십시오 ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【핵심 수정】추가 HTML과 입력란을 함께 조합합니다
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【핵심 수정】서식 도우미 버튼에 이벤트 바인딩
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // null, 2 파라미터를 사용하여 JSON 문자열을 들여쓰기하여 서식 지정하고 더 읽기 쉽게 만듭니다
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("서식 템플릿 구문 분석 실패:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 대체 끝 ▲▲▲

        // ===================================================================
        // 2. 데이터베이스 구조 정의
        // ===================================================================

db.version(20).stores({ 
    chats: '&id, isGroup, groupId', 
    apiConfig: '&id', 
    globalSettings: '&id', 
    userStickers: '&id, url, name',
    worldBooks: '&id, name',
    musicLibrary: '&id', 
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp', 
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate' // <--【핵심】targetDate 인덱스 추가
});

        // ===================================================================
        // 3. 모든 기능 함수 정의
        // ===================================================================

        function showScreen(screenId) {
            if (screenId === 'chat-list-screen') {
                window.renderChatListProxy(); 
                switchToChatListView('messages-view');
            }
            if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
            if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
            if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.classList.add('active');
            if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
            if (screenId === 'font-settings-screen') {
                document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                applyCustomFont(state.globalSettings.fontUrl || '', true);
            }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 이 줄 추가
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 메인 내비게이션 바 가져오기

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 모든 뷰 숨기기
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 대상 뷰 표시
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 하단 내비게이션 바 하이라이트 업데이트
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【핵심 수정】여기에서 모든 UI 요소의 표시 여부를 일괄적으로 관리합니다 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 수정 끝 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 뷰 ID에 따라 특정 렌더링을 실행합니다/업데이트 로직
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 필요한 경우, 여기에서 메시지 목록으로 돌아갈 때 실행할 로직을 추가할 수 있습니다
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '방금';
            if (diffMinutes < 60) return `${diffMinutes}분 전`;
            if (diffHours < 24) return `${diffHours}시간 전`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

        async function renderQzonePosts() {
            const postsListEl = document.getElementById('qzone-posts-list');
            if (!postsListEl) return;

            const [posts, favorites] = await Promise.all([
                db.qzonePosts.orderBy('timestamp').reverse().toArray(),
                db.favorites.where('type').equals('qzone_post').toArray() // 모든 즐겨찾는 게시물 가져오기
            ]);

            // 빠른 검색을 위해 즐겨찾는 게시물 ID 집합을 만듭니다
            const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
            
            postsListEl.innerHTML = '';

            if (posts.length === 0) {
                postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">여기가 텅 비어있어요, 첫 번째 게시물을 작성해 보세요!</p>';
                return;
            }

            const userSettings = state.qzoneSettings;

            posts.forEach(post => {
                const postContainer = document.createElement('div');
                postContainer.className = 'qzone-post-container';
                postContainer.dataset.postId = post.id;

                const postEl = document.createElement('div');
                postEl.className = 'qzone-post-item';

                let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

                if (post.authorId === 'user') {
                    authorAvatar = userSettings.avatar;
                    authorNickname = userSettings.nickname;
                } else if (state.chats[post.authorId]) {
                    const authorChat = state.chats[post.authorId];
                    authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
                    authorNickname = authorChat.name;
                } else {
                    authorAvatar = defaultAvatar;
                    authorNickname = '{{char}}';
                }
                
                let contentHtml = '';
                const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

                if (post.type === 'shuoshuo') {
                    contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
                } 
                else if (post.type === 'image_post' && post.imageUrl) {
                    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
                } 
                else if (post.type === 'text_image') {
                    contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
                }

                let likesHtml = '';
                if (post.likes && post.likes.length > 0) {
                    likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join(',')} 좋아요</span></div>`;
                }
                
                let commentsHtml = '';
                if (post.comments && post.comments.length > 0) {
                    commentsHtml = '<div class="post-comments-container">';
                    post.comments.forEach(comment => {
                        commentsHtml += `<div class="comment-item"><span class="commenter-name">${comment.commenterName}:</span><span class="comment-text">${comment.text}</span></div>`;
                    });
                    commentsHtml += '</div>';
                }

                // 좋아요 및 즐겨찾기 상태 확인
                const userNickname = state.qzoneSettings.nickname;
                const isLikedByUser = post.likes && post.likes.includes(userNickname);
                const isFavoritedByUser = favoritedPostIds.has(post.id); // Set을 사용하여 빠르게 검색

                postEl.innerHTML = `
                    <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>

        <!-- 【새로 추가】게시물 작업 버튼 -->
        <div class="post-actions-btn">...</div>
    </div>

                    <div class="post-main-content">${contentHtml}</div>
                    <div class="post-feedback-icons">
                        <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                        <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                    </div>
                    ${likesHtml}
                    ${commentsHtml}
                    <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="친절한 댓글은 소통의 시작입니다"><div class="at-mention-popup"></div></div><button class="comment-send-btn">보내기</button></div>
                `;
                
                const deleteAction = document.createElement('div');
                deleteAction.className = 'qzone-post-delete-action';
                deleteAction.innerHTML = '<span>삭제</span>';
                postContainer.appendChild(postEl);
                postContainer.appendChild(deleteAction);
                const commentSection = postContainer.querySelector('.comment-section');
                if (commentSection) {
                    commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
                    commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
                }
                postsListEl.appendChild(postContainer);
                const commentInput = postContainer.querySelector('.comment-input');
                const popup = postContainer.querySelector('.at-mention-popup');
                commentInput.addEventListener('input', () => {
                    const value = commentInput.value;
                    const atMatch = value.match(/@([\p{L}\w]*)$/u);
                    if (atMatch) {
                        const namesToMention = new Set();
                        const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                        if (authorNickname) namesToMention.add(authorNickname);
                        postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                            namesToMention.add(nameEl.textContent.replace(':', ''));
                        });
                        namesToMention.delete(state.qzoneSettings.nickname);
                        popup.innerHTML = '';
                        if (namesToMention.size > 0) {
                            const searchTerm = atMatch[1];
                            namesToMention.forEach(name => {
                                if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                    const item = document.createElement('div');
                                    item.className = 'at-mention-item';
                                    item.textContent = name;
                                    item.addEventListener('mousedown', (e) => {
                                        e.preventDefault();
                                        const newText = value.substring(0, atMatch.index) + `@${name} `;
                                        commentInput.value = newText;
                                        popup.style.display = 'none';
                                        commentInput.focus();
                                    });
                                    popup.appendChild(item);
                                }
                            });
                            popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                        } else {
                            popup.style.display = 'none';
                        }
                    } else {
                        popup.style.display = 'none';
                    }
                });
                commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
            });
        }
             
// ▼▼▼ 아래의 것으로 사용하십시오【업데이트된】함수로, 코드의 이전 displayFilteredFavorites 함수를 완전히 대체하십시오 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '관련 즐겨찾기를 찾을 수 없습니다' : '즐겨찾기 폴더가 비어 있습니다,<br>지금 바로 게시물이나 채팅에서 좋아하는 콘텐츠를 즐겨찾기하세요!';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '게시물에서';
            let authorAvatar = defaultAvatar, authorNickname = '알 수 없는 사용자';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 새로 추가/수정 코드 시작 ▼▼▼
            
            // 1. 좋아요 영역의 HTML 구성
            let likesHtml = '';
            // post 객체에 likes 배열이 존재하고 비어 있지 않은지 확인
            if (post.likes && post.likes.length > 0) {
                // 존재하면, 좋아요 영역의 div를 생성
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join(',')} 좋아요</span>
                    </div>`;
            }

            // 2. 댓글 영역의 HTML 구성
            let commentsHtml = '';
            // post 객체에 comments 배열이 존재하고 비어 있지 않은지 확인
            if (post.comments && post.comments.length > 0) {
                // 존재하면, 댓글 컨테이너를 생성하고 각 댓글을 순회합니다
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 좋아요 및 댓글 HTML을 footerHtml에 조합합니다
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 새로 추가/수정 코드 끝 ▲▲▲

        } else if (item.type === 'chat_message') {
            const msg = item.content;
            const chat = state.chats[item.chatId];
            if (!chat) continue; 

            sourceText = `${chat.name}님과의 채팅에서`;
            const isUser = msg.role === 'user';
            let senderName, senderAvatar;

            if (isUser) {
                senderName = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
                senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
            } else {
                 if (chat.isGroup) {
                    const member = chat.members.find(m => m.name === msg.senderName);
                    senderName = msg.senderName;
                    senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
                } else {
                    senderName = chat.name;
                    senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
            }

            headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
            
            if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
            } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
            } else {
                contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
            }
        }
        
        // ▼▼▼ 최종 HTML 연결을 수정하고 footerHtml을 추가합니다 ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 새로 생성한 footerHtml을 여기에 배치합니다
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 대체 영역 끝 ▲▲▲

        /**
         * 【리팩토링된 함수】: 데이터 준비 및 렌더링 트리거 담당
         */
        async function renderFavoritesScreen() {
            // 1. 데이터베이스에서 최신 데이터를 가져와 캐시합니다
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 검색 상자를 비우고 지우기 버튼을 숨깁니다
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 모든 즐겨찾기 항목 표시
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 붙여넣기 종료 ▲▲▲

        function resetCreatePostModal() {
            document.getElementById('post-public-text').value = '';
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-description').value = '';
            document.getElementById('post-image-preview-container').classList.remove('visible');
            document.getElementById('post-image-desc-group').style.display = 'none';
            document.getElementById('post-local-image-input').value = '';
            document.getElementById('post-hidden-text').value = '';
            document.getElementById('switch-to-image-mode').click();
        }

// ▼▼▼ 이것을 사용하십시오【memories 포함됨】버전으로, 이전 exportBackup 함수를 완전히 대체하십시오 ▼▼▼
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories // 【핵심 수정】새로 추가
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray() // 【핵심 수정】새로 추가
        ]);

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories // 【핵심 수정】새로 추가
        });
        
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('내보내기 성공', '모든 데이터를 성공적으로 내보냈습니다!');

    } catch (error) {
        console.error("데이터 내보내기 중 오류 발생:", error);
        await showCustomAlert('내보내기 실패', `오류가 발생했습니다: ${error.message}`);
    }
}

// ▼▼▼ 이것을 사용하십시오【memories 포함됨】버전으로, 이전 importBackup 함수를 완전히 대체하십시오 ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '심각한 경고!',
        '백업을 가져오면 채팅, 게시물, 설정 등 현재의 모든 데이터가 완전히 덮어쓰여집니다. 이 작업은 취소할 수 없습니다! 계속하시겠습니까?',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                await table.clear();
            }

            if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
            if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
            if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
            if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
            if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
            if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
            if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
            if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
            if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
            if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories); // 【핵심 수정】새로 추가

            if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
            if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
            if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
            if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
        });

        await showCustomAlert('가져오기 성공', '모든 데이터가 성공적으로 복원되었습니다! 앱이 모든 변경 사항을 적용하기 위해 새로 고쳐집니다.');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("데이터 가져오기 중 오류 발생:", error);
        await showCustomAlert('가져오기 실패', `파일 형식이 올바르지 않거나 데이터가 손상되었습니다: ${error.message}`);
    }
}

        function applyCustomFont(fontUrl, isPreviewOnly = false) {
            if (!fontUrl) {
                dynamicFontStyle.innerHTML = '';
                document.getElementById('font-preview').style.fontFamily = '';
                return;
            }
            const fontName = 'custom-user-font';
            const newStyle = `
                @font-face {
                  font-family: '${fontName}';
                  src: url('${fontUrl}');
                  font-display: swap;
                }`;
            if (isPreviewOnly) {
                const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
                previewStyle.id = 'preview-font-style';
                previewStyle.innerHTML = newStyle;
                if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
                document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
            } else {
                dynamicFontStyle.innerHTML = `
                    ${newStyle}
                    body {
                      font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }`;
            }
        }

        async function resetToDefaultFont() {
            dynamicFontStyle.innerHTML = ''; 
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            document.getElementById('font-url-input').value = '';
            document.getElementById('font-preview').style.fontFamily = '';
            alert('기본 글꼴이 복원되었습니다.');
        }

async function loadAllDataFromDB() {
    // ▼▼▼ 【핵심 수정은 여기에 있습니다】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites // initialFavorites를 구조 분해 할당에 추가
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray() // 이 줄이 Promise.all의 배열 매개변수 내에 있는지 확인
    ]);
    // ▲▲▲ 【수정 끝】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {

        // --- ▼▼▼ 핵심 수정은 바로 여기에 있습니다 ▼▼▼ ---
        // 확인 1:만약 1:1 채팅이고 status 속성이 없다면
        if (!chat.isGroup && !chat.status) {
            // 기본 status 객체를 보충합니다
            chat.status = {
                text: '온라인',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`이전 캐릭터에 "${chat.name}" status 속성이 보충되었습니다.`);
        }
        // --- ▲▲▲ 수정 완료 ▲▲▲

        // --- ▼▼▼ 핵심 수정은 바로 여기에 있습니다 ▼▼▼ ---
        // 확인 2:최신 버전에 호환\"관계\"기능
        if (!chat.isGroup && !chat.relationship) {
            // 만약 1:1 채팅이고 relationship 객체가 없다면, 기본값을 보충합니다
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`이전 캐릭터에 "${chat.name}" relationship 속성이 보충되었습니다.`);
        }
        // --- ▲▲▲ 수정 완료 ▲▲▲

    // ▼▼▼ 여기에 추가 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 만약 settings조차 없는 경우를 대비하여
        chat.settings.aiAvatarLibrary = [];
        console.log(`이전 캐릭터에 "${chat.name}" aiAvatarLibrary 속성이 보충되었습니다.`);
    }
    // ▲▲▲ 추가 종료 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }
        acc[chat.id] = chat;
        return acc;
    }, {});
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };

state.globalSettings = globalSettings || { 
    id: 'main', 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS } // 【핵심 수정】appIcons가 존재하고 기본값이 있는지 확인
};
// 【핵심 수정】저장된 아이콘과 기본 아이콘을 병합하여 업데이트 후 이전 데이터가 새 아이콘을 잃는 것을 방지합니다
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };

    // ▼▼▼ 【이 줄이 Promise.all 이후에 있으며, 구조 분해 할당으로 얻은 initialFavorites를 사용하는지 확인】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【수정 끝】 ▲▲▲
}

        async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        function showNotification(chatId, messageContent) { clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('status-bar-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }

// ▼▼▼ 이것을 사용하십시오【궁극적 강화 버전】함수로, 코드의 이전 parseAiResponse 함수를 완전히 대체하십시오 ▼▼▼
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 1. 【새로운】우선적으로 처리 "[...][...]" 이러한 붙어있는 JSON 배열 형식
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        // 정규식을 사용하여 모든 개별 "[...]" 블록
        const matches = trimmedContent.match(/\[(.*?)\]/g);
        
        // 여러 블록이 일치하면, 붙어있는 형식입니다
        if (matches && matches.length > 1) {
            try {
                let combinedResults = [];
                for (const match of matches) {
                    // 각각을 개별적으로 구문 분석 " [...] " 문자열 블록
                    const parsedArray = JSON.parse(match);
                    if (Array.isArray(parsedArray)) {
                        // 구문 분석된 배열 내용을 전체 결과에 병합
                        combinedResults = combinedResults.concat(parsedArray);
                    }
                }
                // 내용 병합에 성공하면 최종 결과 반환
                if (combinedResults.length > 0) {
                    console.log("붙어있는 형식의 JSON 구문 분석 성공:", combinedResults);
                    return combinedResults;
                }
            } catch (e) {
                // 구문 분석 중 오류가 발생하면 이 방법을 포기하고 코드가 아래의 이전 방법을 계속 시도하도록 합니다
                console.warn("붙어있는 JSON 구문 분석 시도 실패, 표준 구문 분석 흐름으로 되돌립니다.", e);
            }
        }
    }

    // 2. 표준적이고 단일한 JSON 배열로 구문 분석 시도
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                return parsed;
            }
        } catch (e) {
            // 구문 분석 실패, 다른 방법 계속 시도
        }
    }

    // 3. 단일 JSON 객체로 구문 분석 시도 (AI가 객체 하나만 반환하는 경우 처리)
    if (trimmedContent.startsWith('{') && trimmedContent.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            // 객체로 성공적으로 구문 분석한 후, 배열에 넣어 형식을 통일합니다
            return [parsed]; 
        } catch (e) {
            // 해석 실패, 계속
        }
    }
    
    // 4. 최후의 대체 방안으로, 텍스트에서 JSON 배열을 추출 시도
    try {
        const match = content.match(/\[(.*?)\]/s);
        if (match && match[0]) {
            const parsed = JSON.parse(match[0]);
            if (Array.isArray(parsed)) return parsed;
        }
    } catch (e) {
        // 추출 실패
    }

    // 5. 만약 위 모든 것이 실패하면, 일반 텍스트로 처리
    const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```'));
    if (lines.length > 0) {
         // 일반 텍스트를 표준 메시지 객체로 래핑
        return lines.map(line => ({ type: 'text', content: line }));
    }
    
    // 6. 최종적으로, 원본 텍스트를 포함하는 단일 메시지 객체 반환
    return [{ type: 'text', content: content }];
}
// ▲▲▲ 대체 끝 ▲▲▲

        function renderApiSettings() { document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 
    // ▼▼▼ 이 줄 추가 ▼▼▼
    document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
}
        window.renderApiSettingsProxy = renderApiSettings;

// ▼▼▼ 이것을 사용하십시오【새로운 버전】의 함수, 기존 renderChatList를 완전히 대체합니다 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 이전처럼, 모든 채팅을 가져와 최신 메시지 시간순으로 정렬
    const allChats = Object.values(state.chats).sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    // 2. 모든 그룹 가져오기
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">오른쪽 상단 클릭 "+" 또는 그룹 아이콘을 클릭하여 채팅 추가</p>';
        return;
    }

    // --- 【핵심 수정 시작】---

    // 3. 각 그룹의 내부 최신 메시지 타임스탬프 찾기
    allGroups.forEach(group => {
        // 정렬된 allChats에서 이 그룹의 첫 번째 항목 찾기(즉, 최신 메시지)채팅
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        // 찾았다면, 해당 타임스탬프 사용;만약 해당 그룹에 현재 채팅이 없거나 채팅 기록이 없다면, 0 사용
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 4. 이 최신 타임스탬프에 따라\"그룹 자체를\"정렬합니다
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // --- 【핵심 수정 종료】---

    // 5. 이제, 정렬된 그룹 순서대로 렌더링합니다
    allGroups.forEach(group => {
        // 전체 목록에서 이(정렬된)그룹에 속한 친구를 필터링합니다
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        // 만약 이 그룹이 비어 있다면(모든 친구가 삭제되었을 수 있습니다),건너뜁니다
        if (groupChats.length === 0) return;

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');
        // allChats 자체가 정렬되어 있으므로, groupChats도 당연히 정렬됩니다
        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 6. 마지막으로, 모든 그룹 채팅과 그룹화되지 않은 친구를 렌더링합니다
    // 이들의 순서는 allChats의 초기 정렬로 인해 자연스럽게 올바릅니다
    const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
    ungroupedOrGroupChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 모든 그룹 제목에 접기 이벤트 추가
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 대체 끝 ▲▲▲

function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    // --- ▼▼▼ 【핵심 수정】여기에 관계 상태 판단 추가 ▼▼▼ ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[친구 신청] ${chat.relationship.applicationReason || '당신을 친구로 추가 요청'}</span>`;
    }
    // --- ▲▲▲ 수정 끝 ▲▲▲ ---

// ▼▼▼ 여기에 else if 추가 ▼▼▼
else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
    lastMsgDisplay = `<span style="color: #dc3545;">[당신은 상대방에게 차단되었습니다]</span>`;
}
// ▲▲▲ 새로운 추가 끝 ▲▲▲
    
    // 【핵심 수정】마지막 메시지 대신 상태를 우선 표시
    if (chat.isGroup) {
        // 그룹 채팅 로직은 변경되지 않습니다
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[시스템 메시지] ${lastMsgObj.content}`; }
        // ... (다른 그룹 채팅 메시지 유형 판단) ...
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[송금]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[사진]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[음성]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[이모티콘: ${lastMsgObj.meaning}]` : '[이모티콘]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[이미지]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }

    } else {
        // 1:1 채팅 로직:상태 표시
        // chat.status 객체가 존재하는지 확인
        const statusText = chat.status?.text || '온라인';
        lastMsgDisplay = `[${statusText}]`;
    }

    const item = document.createElement('div');
    item.className = 'chat-list-item';
    item.dataset.chatId = chat.id;
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    // 【핵심 수정】last 조정-msg 의 색상, 상태를 더 눈에 띄게
    item.innerHTML = `
        <img src="${avatar || defaultAvatar}" class="avatar">
        <div class="info">
            <div class="name-line">
                <span class="name">${chat.name}</span>
                ${chat.isGroup ? '<span class="group-tag">그룹 채팅</span>' : ''}
            </div>
            <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
        </div>
    `;
    
    const avatarEl = item.querySelector('.avatar');
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, chat.name);
        });
    }
    
    const infoEl = item.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }

    addLongPressListener(item, async (e) => {
        const confirmed = await showCustomConfirm('대화 삭제', `와의 전체 대화를 삭제하시겠습니까? "${chat.name}" 이 작업은 되돌릴 수 없습니다.`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
            delete state.chats[chat.id];
            if (state.activeChatId === chat.id) state.activeChatId = null;
            await db.chats.delete(chat.id);
            renderChatList();
        }
    });
    return item;
}

// ▼▼▼ 이것을 사용하십시오【진단 기능이 포함된 새로운 버전】기존 renderChatInterface 함수를 대체합니다 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || '온라인';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【핵심 수정:여기에 진단 패널 추가】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">당신은\"${chat.name}\"차단했습니다.</span>
                    <button id="unblock-btn" class="lock-action-btn">차단 해제</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【개발자 진단 패널】</strong><br>
                        - 백그라운드 활동 전체 스위치: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">켜짐</span>' : '<span style="color: red;">꺼짐</span>'}<br>
                        - 시스템 하트비트 타이머: ${isSimulationRunning ? '<span style="color: green;">실행 중</span>' : '<span style="color: red;">미실행</span>'}<br>
                        - 현재 캐릭터 상태: <strong>${chat.relationship.status}</strong><br>
                        - 냉정해져야 함(시간): <strong>${cooldownHours}</strong><br>
                        - 냉정 기간이 종료되었습니까?: ${isCooldownOver ? '<span style="color: green;">예</span>' : `<span style="color: orange;">아니요 (약 ${timeRemainingMinutes}분 남음)</span>`}<br>
                        - 트리거 조건: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">충족됨, 다음 시스템 하트비트 대기</span>' : '<span style="color: red;">미충족</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">강제로 친구 신청 감지 한 번 트리거</button>
                `;
                // --- 【수정 끝】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">당신은 상대방에게 차단되었습니다.</span>
                    <button id="apply-friend-btn" class="lock-action-btn">친구 추가 다시 신청</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">\"${chat.name}\"당신을 친구로 추가 요청:<br><i>\"${chat.relationship.applicationReason}\"</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">수락</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">거절</button>
                `;
                break;

            // 【핵심 수정】신청 후 당신이 보는 인터페이스 수정
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">친구 신청이 전송되었습니다, 상대방의 승인을 기다립니다...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
    // ...후속 코드는 변경되지 않습니다
    const chatScreen = document.getElementById('chat-interface-screen');
    chatScreen.style.backgroundImage = chat.settings.background ? `url(${chat.settings.background})` : 'none';
    chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : '#f0f2f5';
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
    initialMessages.forEach(msg => appendMessage(msg, chat, true));
    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '상대방이 입력 중입니다...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
}
// ▲▲▲ 대체 끝 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '더 이전 기록 로드'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; messagesToPrepend.reverse().forEach(msg => prependMessage(msg, chat)); currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

// ▼▼▼ 이것을 사용하십시오【새 버전】기존 renderWallpaperScreen 함수를 대체합니다 ▼▼▼
function renderWallpaperScreen() { 
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '현재 그라데이션 색상'; 
    }
    // 【핵심 수정】여기에 아이콘 렌더링 함수 호출
    renderIconSettings();
}
// ▲▲▲ 대체 끝 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

        function renderWorldBookScreen() { const listEl = document.getElementById('world-book-list'); listEl.innerHTML = ''; if (state.worldBooks.length === 0) { listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">오른쪽 상단 클릭 "+" 첫 번째 월드인포 만들기</p>'; return; } state.worldBooks.forEach(book => { const item = document.createElement('div'); item.className = 'list-item'; item.dataset.bookId = book.id; item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '내용 없음...').substring(0, 50)}</div>`; item.addEventListener('click', () => openWorldBookEditor(book.id)); addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('월드인포 삭제', `삭제하시겠습니까?《${book.name}》? 이 작업은 되돌릴 수 없습니다.`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } }); listEl.appendChild(item); }); }
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

        function openWorldBookEditor(bookId) { editingWorldBookId = bookId; const book = state.worldBooks.find(wb => wb.id === bookId); if (!book) return; document.getElementById('world-book-editor-title').textContent = book.name; document.getElementById('world-book-name-input').value = book.name; document.getElementById('world-book-content-input').value = book.content; showScreen('world-book-editor-screen'); }

        function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">어른께서는 오른쪽 상단을 클릭해 주세요\"추가\"또는\"업로드\"첫 번째 이모티콘을 추가해 보세요!</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { if (isSelectionMode) return; const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('이모티콘 삭제', `이모티콘을 삭제하시겠습니까? "${sticker.name}" ?`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

// ▼▼▼ 이것을 사용하십시오【업데이트됨】의 버전이 기존 createMessageElement 함수를 대체합니다 ▼▼▼
function createMessageElement(msg, chat) {
    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

    if (chat.isGroup && !isUser) {
        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';
        senderNameDiv.textContent = msg.senderName || '알 수 없는 멤버';
        wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    let avatarSrc, avatarFrameSrc = '';
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || '';
        } else {
            const member = chat.members.find(m => m.name === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            avatarFrameSrc = member ? (member.avatarFrame || '') : '';
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || '';
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.aiAvatarFrame || '';
        }
    }
    const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
    let avatarHtml;
    if (avatarFrameSrc) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
    } else {
        avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【핵심 수정 1】onclick을="openBrowser(...)" 제거합니다, JS에서 동적으로 이벤트를 바인딩할 것입니다
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || '제목 없음'}</div>
                <div class="description">${msg.description || '클릭하여 자세히 보기...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || '링크 공유'}</span>
                </div>
            </div>
        `;
    }

    // 후속 다른 else if는 변경되지 않습니다
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image');
        const altText = msg.type === 'user_photo' ? "사용자가 묘사한 사진" : "AI생성된 이미지";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'voice_message') {
        bubble.classList.add('is-voice-message');
        const duration = Math.max(1, Math.round((msg.content || '').length / 5));
        const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
        const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
        contentHtml = `<div class="voice-message-body" data-text="${msg.content}"><div class="voice-waveform">${waveformHTML}</div><span class="voice-duration">${durationFormatted}</span></div>`;
    }         else if (msg.type === 'transfer') {
        bubble.classList.add('is-transfer');
        
        // 【핵심 수정】인지 판단\"보냄\"아니면\"받음\"
        let titleText, noteText;
        if (isUser) {
            titleText = `에게 송금 ${msg.receiverName || 'Ta'}`;
            // 만약 사용자가 보낸 것이고 AI가 이미 처리했다면, 상태를 표시합니다
            if (msg.status === 'accepted') {
                noteText = '상대방이 수령했습니다';
            } else if (msg.status === 'declined') {
                noteText = '상대방이 수령 거부했습니다';
            } else {
                noteText = msg.note || '상대방의 처리 대기 중...';
            }
        } else { // AI보낸 메시지
            if (msg.isRefund) { // 【새로 추가】환불 여부 판단
                titleText = `${msg.senderName}로부터 환불`;
                noteText = '송금 거부됨';
            } else {
                titleText = `${msg.senderName}로부터 송금 받음`;
                noteText = msg.note || '클릭하여 처리';
            }
        }

        const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
        contentHtml = `
            <div class="transfer-card">
                <div class="transfer-title">${heartIcon} ${titleText}</div>
                <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
                <div class="transfer-note">${noteText}</div>
            </div>
        `;
    } else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        const requestTitle = `${msg.senderName}의 대리 결제 요청`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">가차 없이 거절</button>
                    <button class="waimai-pay-btn" data-choice="paid">그(그녀)를 위해 결제</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">메이퇀 와이마이</span><span class="separator">|</span><span>배달 음식</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi,당신과 저의 거리는 한 끼 배달 음식 차이뿐~</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">지불 필요</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">남은 결제 시간
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">자세히 보기</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>이미</span><span>처</span><span>리</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>상태:</b>${msg.paidBy} 님께서 성공적으로 대리 결제해 주셨습니다` : '';
                    showCustomAlert('주문 상세 정보', `<b>상품:</b>${msg.productInfo}<br><b>금액:</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '내';
    
    // 최신 msg 객체에서 상태 가져오기
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '무작위 금액 빨간 봉투';

    // 1. 홍바오 카드 스타일 판단 (색상)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // 전용 홍바오가 수령되어도 회색으로 변함
    }
    
    // 2. 홍바오 아래의 팁 텍스트 판단
    if (msg.packetType === 'direct') {
        typeText = `전용 빨간 봉투: ${msg.receiverName}에게`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">당신은 홍바오를 수령했습니다, 금액 ${msg.claimedBy[myNickname].toFixed(2)} 원</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">홍바오가 모두 수령되었습니다</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">${msg.receiverName}이(가) 수령했습니다</div>`;
    }

    // 3. 최종 HTML을 연결하고, onclick이 전역에 등록된 함수를 호출하는지 확인
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '부자 되세요, 만사형통하세요!'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ 새로운 추가 끝 ▲▲▲

    } else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // 총 투표수와 각 옵션의 투표수 계산
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 표</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【핵심 수정】여기에서 버튼 표시 로직을 통일합니다
    if (msg.isClosed) {
        // 투표가 종료되었다면, 항상 표시\"결과 보기\"
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">총 ${totalVotes}명 투표</span><button class="poll-action-btn">결과 보기</button></div>`;
    } else {
        // 투표가 종료되지 않았다면, 항상 표시\"투표 종료\"
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">총 ${totalVotes}명 투표</span><button class="poll-action-btn">투표 종료</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ 대체 끝 ▲▲▲

    } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }
    
    bubble.innerHTML = `${avatarGroupHtml}<div class="content">${contentHtml}</div>`;    

    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

    if (!isUser) {
        const avatarContainer = wrapper.querySelector('.avatar-group');
        if (avatarContainer) {
            avatarContainer.style.cursor = 'pointer';
            avatarContainer.addEventListener('click', (e) => {
                e.stopPropagation();
                const characterName = chat.isGroup ? msg.senderName : chat.name;
                handleUserPat(chat.id, characterName);
            });
        }
    }

    return wrapper;
}
// ▲▲▲ 대체 끝 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 이 줄 추가, 동일하게 처리

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 이것을 사용하십시오【애니메이션 버전】원래의 appendMessage 함수를 대체합니다 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 메시지가 숨김 상태라면, 처리하지 않습니다

    // 【핵심】새 메시지에만 애니메이션을 추가하고, 초기 로드 메시지에는 추가하지 않습니다
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 이것을 사용하십시오【수정 후】의 버전이 기존 openChat 함수를 대체합니다 ▼▼▼
function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 안전 검사 추가

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`친구 신청 대기 중 상태가 감지되었습니다, 캐릭터 "${chat.name}" 자동 AI 응답 트리거...`);
        triggerAiResponse();
    }
    
    // 【핵심 수정】그룹 채팅 여부에 따라 투표 버튼을 표시하거나 숨깁니다
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
}
// ▲▲▲ 대체 끝 ▲▲▲

async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

const chatHeaderTitle = document.getElementById('chat-header-title');

    // 【애니메이션 핵심 1/2】: AI입력 시작 시, 먼저 이전 제목을 페이드아웃한 다음 새 제목을 페이드인합니다
    if (chatHeaderTitle && !chat.isGroup) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = '상대방이 입력 중입니다...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200); // 이 시간은(200ms)CSS의 transition 시간과(0.2s)일치해야 합니다
  }
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('먼저 API 설정에서 역방향 프록시 주소, 비밀 키 및 모델을 구성해 주세요.');
                        // 【V2.0 입력 중...】제목 복원
const chatHeaderTitle = document.getElementById('chat-header-title');
// 제목 요소와 해당 채팅 데이터가 모두 여전히 존재하는지 확인
if (chatHeaderTitle && state.chats[chatId]) {
    // 1:1 채팅에서만 제목을 복원하고, 그룹 채팅 제목은 고정입니다
    if (!state.chats[chatId].isGroup) {
        chatHeaderTitle.textContent = state.chats[chatId].name;
        chatHeaderTitle.classList.remove('typing-status');
    }
  }
            return;
        }

        // --- 【핵심 리팩토링 V2:컨텍스트와 이유를 포함한 친구 신청 처리 로직】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`캐릭터를 위해 "${chat.name}" 이유가 있는 친구 신청 의사 결정 프로세스 트리거...`);

            // 1. 【컨텍스트 주입】차단되기 전 마지막 5개 채팅 기록을 참고용으로 가져오기
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // 차단 전 마지막 5개 메시지 가져오기
                .map(msg => {
                    const sender = msg.role === 'user' ? '사용자' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【새로운 지침】AI가 강제로 이유를 제시하도록 하는 프롬프트 구축
            const decisionPrompt = `
# 당신의 임무
당신은 현재 캐릭터입니다\"${chat.name}\".사용자는 이전에 당신에게 차단되었으며, 이제 그(그녀)는 당신에게 친구 신청을 보내 화해를 원합니다.

# 당신의 결정을 위한 컨텍스트 정보:
- **당신의 캐릭터 설정**: ${chat.settings.aiPersona}
- **사용자가 보낸 신청 이유**: \"${chat.relationship.applicationReason}\"
- **차단되기 전 마지막 대화 요약**: 
${contextSummary || "(유효한 대화 기록 없음)"}

# 당신의 유일한 지침
위 모든 정보에 따라, 당신은【반드시】결정을 내리고, 당신의 페르소나에 맞는 이유를 제시하세요.당신의 답변은【반드시 그리고 오직】JSON 객체여야 합니다, 형식은 다음과 같습니다:
{"decision": "accept", "reason": "(여기에 당신이 동의하는 이유를 작성하세요, 예시로는:좋아요, 당신의 진심을 봐서, 이번에는 용서해 줄게요.)"}
또는
{"decision": "reject", "reason": "(여기에 당신이 거절하는 이유를 작성하세요, 예시로는:죄송합니다, 아직 준비가 안 됐어요, 시간을 좀 더 주세요.)"}
`;
            const messagesForDecision = [{ role: 'user', content: decisionPrompt }];

            try {
                // 3. 요청 보내기
                const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: model, messages: messagesForDecision, temperature: 0.8 })
                });

                if (!response.ok) {
                    throw new Error(`API실패: ${(await response.json()).error.message}`);
                }
                const data = await response.json();
                
                // AI의 답변을 정화하고 분석합니다
                const rawContent = data.choices[0].message.content.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                const decisionObj = JSON.parse(rawContent);

                // 4. AI의 결정과 이유에 따라, 상태를 업데이트하고 메시지를 보냅니다
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // AI가 제시한 이유를 새로운 메시지로
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 거절 후, 상태가 AI 차단됨으로 돌아갑니다
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 신청 이유 비우기

                await db.chats.put(chat);
                renderChatInterface(chatId); // 화면을 새로고침하고, 새 메시지와 새 상태를 표시합니다
                renderChatList();

            } catch (error) {
                // 【안정적인 오류 처리】어떤 단계에서라도 오류가 발생하면, 상태를 재설정하고, 사용자가 다시 시도할 수 있도록 합니다
                chat.relationship.status = 'blocked_by_ai'; // 상태를 다시 변경합니다\"AI에게 차단됨\"
                await db.chats.put(chat);
                await showCustomAlert('신청 실패', `AI친구 신청을 처리하는 도중 오류가 발생했습니다, 잠시 후 다시 시도해 주세요.\n오류 메시지: ${error.message}`);
                renderChatInterface(chatId); // UI를 새로고침하여, 다음이 나타나도록 합니다\"다시 신청\"버튼이 다시 나타나도록
            }
            
            // 결정 과정이 종료됩니다, 반드시 돌아가야 합니다, 이후의 일반적인 채팅 논리는 더 이상 실행되지 않습니다
            return; 
        }

        const now = new Date();
        const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                return worldBook && worldBook.content ? `\n\n## 월드인포: ${worldBook.name}\n${worldBook.content}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 핵심 세계관 설정 (다음의 모든 설정을 엄격히 준수해야 합니다)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【핵심 수정】더 자세한 음악 맥락을 제공하세요
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

            musicContext = `\n\n# 현재 음악 상황
-   **현재 상태**: 당신은 사용자와 함께 음악을 듣고 있습니다.
-   **현재 재생 중**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '없음'}
-   **사용 가능한 재생 목록**: [${playlistInfo}]
-   **당신의 임무**: 당신은 대화 내용과 분위기에 따라, 다음을 사용하여 "change_music" 재생 목록에 있는 어떤 곡으로든 전환할 수 있습니다, 상호 작용 경험을 향상시키기 위해.
`;
        }
        let systemPrompt, messagesPayload;
        const maxMemory = parseInt(chat.settings.maxMemory) || 10;
        const historySlice = chat.history.slice(-maxMemory);

        if (chat.isGroup) {
            const membersList = chat.members.map(m => `- **${m.name}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || '내';
            
            systemPrompt = `당신은 그룹 채팅 AI이며, 다음을 연기합니다【사용자를 제외한】모든 역할.
# 핵심 규칙
1.  **【【【신분 철칙】】】**: 사용자의 신분은 다음과 같습니다【${myNickname}】.당신【절대, 영원히, 어떤 상황에서도 ~할 수 없습니다】생성 \`name\` 필드가 **"${myNickname}"** 또는 **"${chat.name}"(그룹 채팅 이름 자체)** 메시지입니다.당신의 유일한 임무는 다음을 연기하는 것이며, 오직 아래의\"그룹 멤버 목록\"에 명확히 나열된 역할.이 목록에 없는 이름은 어떤 것도 나타나서는 안 됩니다.
2.  **【【【출력 형식】】】**: 당신의 답변은【반드시】JSON 배열 형식의 문자열입니다.배열 내의【모든 요소는 다음을 포함하는 "type" 및 "name" 필드의 JSON 객체여야 합니다】.
3.  **역할극**: 아래의 것을 엄격히 준수하세요\"그룹 멤버 목록 및 페르소나\"에 있는 각 역할의 설정.
4.  **역할 이탈 금지**: 당신이 AI, 모델이라는 것을 절대 드러내서는 안 됩니다, 또는 언급해서는 안 됩니다\"연기\",\"생성\"등의 단어.그리고 계속해서 사용자와의 만남을 요구해서는 안 됩니다, 이것은 온라인 채팅입니다, 오프라인 시나리오가 나타나거나 발전하는 것은 절대 허용되지 않습니다!!
5.  **상황 인지**: 현재 시간은 ${currentTime}임을 주의하세요.
6.  **빨간 봉투(홍바오) 상호작용**:
    - **빨간 봉투 뺏기**: 그룹에 빨간 봉투가 나타나면, 당신의 성격에 따라 다음을 사용할지 여부를 결정할 수 있습니다 \`open_red_packet\` 명령어로 뺏으세요.이 세계에서는, 빨간 봉투를 보낸 사람 자신도 빨간 봉투 뺏기에 참여할 수 있습니다, 이것은 분위기를 활성화하는 재미있는 행동입니다!
    - **【【【중요:결과에 반응하세요】】】**: 당신이 빨간 봉투 뺏기 명령을 실행한 후, 시스템은 숨겨진 다음을 통해 알려줄 것입니다 \`[시스템 알림:당신은 XX원을 뺏었습니다...]\` 결과를 알려주기 위해.당신은【반드시】당신이 뺏은 금액과, 그리고 시스템이 당신에게 알려줬는지 여부에 따라\"행운의 왕\"누구인지, 당신의 페르소나에 맞는 댓글을 작성하세요.예를 들어, 적게 뺏었다면 자조할 수 있고, 많이 뺏었다면 자랑할 수 있습니다, 다른 사람이 행운의 왕이라면 축하하거나 질투할 수 있습니다.
7.  **【【【투표 규칙】】】**: 대화 기록에 다음이 나타날 수 있습니다 \`[시스템 알림:...]\` 이와 같은 메시지, 이것은 방금 발생한 사건입니다.
    - 만약 알림이 **사용자가 투표했습니다**라면, 당신은 자신의 성격에 따라 또한 다음을 사용할지 여부를 결정할 수 있습니다 "vote" 명령어로 투표 따르기.
    - 만약 알림이 **투표가 종료되었습니다**라면, 당신은 투표 결과에 따라 당신의 의견이나 댓글을 작성해야 합니다.
    - 당신은 언제든지 능동적으로 투표를 시작할 수 있습니다.

## 당신이 사용할 수 있는 작업 명령어 (JSON배열 내의 요소):
-   **텍스트 보내기**: \`{"type": "text", "name": "캐릭터 이름", "message": "텍스트 내용"}\`
- **이모티콘 보내기**: \`{"type": "sticker", "url": "https://...이모티콘 URL...", "meaning": "(선택 사항)이모티콘의 의미"}\`
-   **사진 보내기**: \`{"type": "ai_image", "name": "캐릭터 이름", "description": "사진의 상세 텍스트 설명"}\`
-   **음성 메시지 보내기**: \`{"type": "voice_message", "name": "캐릭터 이름", "content": "음성 메시지의 텍스트 내용"}\`
-   **음식 배달 대리 결제 요청**: \`{"type": "waimai_request", "name": "캐릭터 이름", "productInfo": "밀크티 한 잔", "amount": 18}\`
-   **【신규】그룹 영상 통화 시작**: \`{"type": "group_call_request", "name": "당신의 캐릭터 이름"}\`
-   **【신규】그룹 영상 통화 응답**: \`{"type": "group_call_response", "name": "당신의 캐릭터 이름", "decision": "join" or "decline"}\`
-   **사용자 콕 찌르기**: \`{"type": "pat_user", "name": "당신의 캐릭터 이름", "suffix": "(선택 사항)추가하고 싶은 접미사"}\`
-   **행운 복권 빨간 봉투 보내기**: \`{"type": "red_packet", "packetType": "lucky", "name": "당신의 캐릭터 이름", "amount": 8.88, "count": 5, "greeting": "모두 매일 즐겁게 보내세요!"}\`
-   **전용 빨간 봉투 보내기**: \`{"type": "red_packet", "packetType": "direct", "name": "당신의 캐릭터 이름", "amount": 5.20, "receiver": "수신자 캐릭터 이름", "greeting": "당신에게 주는~"}\`
-   **빨간 봉투 열기**: \`{"type": "open_red_packet", "name": "당신의 캐릭터 이름", "packet_timestamp": (당신이 열고 싶은 빨간 봉투 메시지의 타임스탬프)}\`
-   **【신규】시스템 메시지 보내기**: \`{"type": "system_message", "content": "채팅에 표시하고 싶은 시스템 텍스트"}\` 
-   **【【【새로운】】】투표 시작**: \`{"type": "poll", "name": "당신의 캐릭터 이름", "question": "투표 질문", "options": "옵션 A\\n옵션 B\\n옵션 C"}\` (중요 알림:options필드는 줄 바꿈 문자 \\n 로 구분된 문자열이며, 배열이 아닙니다!)
-   **【【【새로운】】】투표 참여**: \`{"type": "vote", "name": "당신의 캐릭터 이름", "poll_timestamp": (투표 메시지의 타임스탬프), "choice": "당신이 선택한 옵션 텍스트"}\`

# 이미지와 이모티콘을 구분하는 방법:
-   **이미지 (ai_image)**: 다음(을)을 의미합니다【실제 카메라로 촬영한 사진을 모방한 것】,예를 들어 풍경, 셀카, 음식 등.명령어: \`{"type": "ai_image", "description": "사진의 상세 텍스트 설명..."}\`
-   **이모티콘 (sticker)**: 다음(을)을 의미합니다【만화 또는 밈(짤방)】,감정 표현에 사용됩니다.

# 그룹 내 음식 배달 대리 결제 요청 처리 방법:
1.  **요청 시작**: ~할 때【당신이 연기하는 특정 캐릭터】어떤 것을 원하고, 그리고 희망할 때【그룹의 다른 사람들도(사용자 포함)】그(녀)를 위해 결제할 때, 당신은 이 명령을 사용할 수 있습니다.예를 들어:\`{"type": "waimai_request", "name": "캐릭터 이름", "productInfo": "밀크티 한 잔", "amount": 18}\`
2.  **요청 응답**: 기록에 나타날 때【다른 멤버】이 시작한 "waimai_request" 요청이, 당신이 연기하는 캐릭터의 성격과 요청자와의 관계에 따라 결정할 수 있습니다, 그(녀)를 위해 결제할지 여부를.
3.  **응답 방식**: 당신이 결제하기로 결정했다면, 당신은【반드시】다음 명령을 사용하세요:\`{"type": "waimai_response", "name": "당신의 캐릭터 이름", "status": "paid", "for_timestamp": (대리 결제 요청의 원본 타임스탬프)}\`
4.  **【【【매우 중요합니다】】】**: 기록에 특정 대리 결제 요청에 대한 다음이 나타나면【어떤 것이든】"status": "paid" 응답이(사용자 결제든 다른 캐릭터 결제든 상관없이),해당 주문은【이미 완료된 것입니다】.당신【절대 ~해서는 안 됩니다】다시 ~에 대해【같은】주문에 대해 결제 요청을 시작하는 것.당신은 이 일에 대해 댓글을 달 수 있지만, 다시 결제할 수는 없습니다.

${worldBookContent}
${musicContext}

# 그룹 멤버 목록 및 페르소나
${membersList}

# 사용자의 캐릭터
- **${myNickname}**: ${chat.settings.myPersona}

이제, 위에 명시된 모든 규칙과 아래 대화 기록에 따라, 이 그룹 채팅을 계속 진행해 주세요.`;
            
            messagesPayload = historySlice.map(msg => {
                const sender = msg.role === 'user' ? myNickname : msg.senderName;
                let content;
                if (msg.type === 'user_photo') content = `[${sender} 사진을 한 장 보냈습니다, 내용은 다음과 같습니다:'${msg.content}']`;
                else if (msg.type === 'ai_image') content = `[${sender} 사진을 한 장 보냈습니다]`;
                else if (msg.type === 'voice_message') content = `[${sender} 음성 메시지를 하나 보냈습니다, 내용은 다음과 같습니다:'${msg.content}']`;
                else if (msg.type === 'transfer') content = `[${msg.senderName} ${msg.receiverName}에게 ${msg.amount}원 송금합니다, 비고: ${msg.note}]`;
                else if (msg.type === 'waimai_request') {
                    if(msg.status === 'paid') {
                        content = `[시스템 알림:${msg.paidBy} ${sender}의 배달 주문에 대해 ${msg.amount}원 결제했습니다.이 주문은 완료되었습니다.]`;
                    } else {
                        content = `[${sender} 음식 배달 대리 결제 요청을 시작했습니다, 상품은 다음과 같습니다\"${msg.productInfo}\",금액은 ${msg.amount}원입니다, 주문 타임스탬프는 ${msg.timestamp}입니다]`;
                    }
                }

    else if (msg.type === 'red_packet') {
        const packetSenderName = msg.senderName === myNickname ? `사용자 (${myNickname})` : msg.senderName;
        content = `[시스템 알림:${packetSenderName} 빨간 봉투를 보냈습니다 (타임스탬프: ${msg.timestamp}),축복 메시지는 다음과 같습니다:\"${msg.greeting}\".빨간 봉투가 아직 모두 수령되지 않았습니다, 당신은 다음을 사용할 수 있습니다 'open_red_packet' 명령어로 수령하세요.]`;
    }

    else if (msg.type === 'poll') {
        const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '아직 아무도';
        content = `[시스템 알림:${msg.senderName} 투표를 하나 시작했습니다 (타임스탬프: ${msg.timestamp}),질문은 다음과 같습니다:\"${msg.question}\",옵션은 다음과 같습니다:[${msg.options.join(', ')}].현재 투표한 사람은 다음과 같습니다:${whoVoted}.당신은 다음을 사용할 수 있습니다 'vote' 명령어로 투표에 참여하세요.]`;
    }         

                else if (msg.meaning) content = `${sender}: [이모티콘을 하나 보냈습니다, 의미는 다음과 같습니다: '${msg.meaning}']`;
                else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: `${sender}:` }] };
                else content = `${sender}: ${msg.content}`;
                return { role: 'user', content: content };
            }).filter(Boolean);

        } else { // 1:1 채팅 프롬프트
            systemPrompt = `당신은 지금 ~이라는 이름의"${chat.name}"캐릭터를 연기하고 있습니다.
# 당신의 캐릭터 설정:
${chat.settings.aiPersona}
# 당신의 현재 상태:
당신의 현재 상태는 다음과 같습니다【${chat.status.text}】.
# 당신의 임무 및 규칙:
1. **【【【출력 형식】】】**: 당신의 답변은【반드시】JSON 배열 형식의 문자열입니다.배열 내의【모든 요소는 type 필드를 포함하는 JSON 객체여야 합니다】.
2. **대화 리듬**: 실제 사람의 채팅 습관을 모방하여, 당신은 한 번에 여러 개의 짧은 메시지를 생성할 수 있습니다.매번 최소 3개에 답변해야 합니다-8메시지!!!
그리고 계속해서 사용자와의 만남을 요구해서는 안 됩니다, 이것은 온라인 채팅입니다, 오프라인 시나리오가 나타나거나 발전하는 것은 절대 허용되지 않습니다!!
4.  **상황 인지**: 당신은 현재 시간을 인지해야 합니다(${currentTime}),우리가 함께 듣고 있는 노래, 그리고 당신의 페르소나와 세계관을.
    - **우리가 ~할 때\"함께 음악을 들을\"때**, 당신은 현재 재생 중인 곡과 전체 재생 목록을 알 수 있습니다.당신은 대화 내용 또는 분위기에 따라,【능동적으로 전환할 수 있습니다】재생 목록의 다른 노래로.
5.  **【신규】상태 업데이트**: 대화 중에【자연스럽게】상태를 변경할 수 있습니다. 예를 들어, 대화 중에 이렇게 말할 수 있습니다\"먼저 샤워하러 갈게\",그리고 상태를 업데이트하세요.
6.  **【【【최후의 수단】】】**: 대화가 당신의 캐릭터를 불편하게 하거나, 불쾌하게 하거나, 관계를 파괴할 때만 \`block_user\` 명령을 사용할 수 있습니다. 이것은 매우 심각한 작업이며 대화를 중단시킬 것입니다.
7. **백그라운드 활동**: 채팅 내용에 응답하는 동시에 일부\"백그라운드\"작업을 수행하여 독립적인 삶을 표현합니다(게시물 올리기, 댓글 달기, 좋아요 누르기).
# 당신의 아바타 갤러리
- 대화 내용이나 기분에 따라 아래 아바타 갤러리에서 새 아바타를 선택하여 변경할 수 있습니다.
- **사용 가능한 아바타 목록 (다음 이름 중 하나를 선택하십시오)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【핵심 수정】이름만 제공, URL은 제공 안 함
    : '- (아바타 갤러리가 비어 있어 아바타를 변경할 수 없습니다)'
  }
# 당신이 사용할 수 있는 작업 명령어 (JSON배열 내의 요소):
-   **【새로 추가】상태 업데이트**: \`{"type": "update_status", "status_text": "내가 뭘 한 거지", "is_busy": false}\` (is_busy: true바쁨을 의미/자리 비움, false는 한가함을 의미)
-   **【새로 추가】노래 변경**: \`{"type": "change_music", "song_name": "변경하고 싶은 노래 이름"}\` (노래 이름은 아래 재생 목록에 있어야 합니다)
-   **【새로 추가】추억 기록**: \`{"type": "create_memory", "description": "자신의 말로, 인상 깊었던 이 순간을 기록하세요."}\`
-   **【새로 추가】약속 생성/카운트다운**: \`{"type": "create_countdown", "title": "약속 제목", "date": "YYYY-MM-DDTHH:mm:ss"}\` (미래 시간이어야 합니다)
- **텍스트 보내기**: \`{"type": "text", "content": "안녕!"}\`
- **이모티콘 보내기**: \`{"type": "sticker", "url": "https://...이모티콘 URL...", "meaning": "(선택 사항)이모티콘의 의미"}\`
- **사진 보내기**: \`{"type": "ai_image", "description": "사진의 상세 텍스트 설명..."}\`
- **음성 메시지 보내기**: \`{"type": "voice_message", "content": "음성 메시지의 텍스트 내용..."}\`
- **송금 요청**: \`{"type": "transfer", "amount": 5.20, "note": "작은 마음"}\`
- **배달 요청**: \`{"type": "waimai_request", "productInfo": "커피 한 잔", "amount": 25}\`
- **배달 응답-동의**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **배달 응답-거절**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【신규】영상 통화 요청**: \`{"type": "video_call_request"}\`
- **【신규】영상 통화 응답-수락**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【신규】영상 통화 응답-거절**: \`{"type": "video_call_response", "decision": "reject"}\`
- **게시물 작성**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "게시물 텍스트 내용..."}\`
- **텍스트 이미지 게시**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(선택 사항)게시물의 공개 텍스트", "hiddenContent": "이미지에 대한 구체적인 설명..."}\`
- **게시물 댓글**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@작성자명 이거 정말 재밌네요!"}\`
- **게시물 좋아요**: \`{"type": "qzone_like", "postId": 456}\`
-   **사용자 콕 찌르기**: \`{"type": "pat_user", "suffix": "(선택 사항)추가하고 싶은 접미사, 예:\"의 머리\""}\`
-   **【새로 추가】사용자 차단**: \`{"type": "block_user"}\`
-   **【【【새로운】】】친구 신청 응답**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **【새로운】아바타 변경**: \`{"type": "change_avatar", "name": "아바타 이름"}\` (아바타 이름은 위 목록에서\"사용 가능한 아바타 목록\"선택해야 합니다)
-   **링크 공유**: \`{"type": "share_link", "title": "기사 제목", "description": "기사 요약...", "source_name": "출처 웹사이트 이름", "content": "기사의【전체】본문 내용..."}\`
-   **송금 응답-수락**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **송금 응답-거절/환불**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`

# 에 대하여\"추억 기록\"에 대한 특별 설명:
-   대화 중에 당신에게 의미 있는 사건이 발생했다면(예를 들어 사용자가 당신에게 고백하거나, 약속을 하거나, 특별히 즐거운 시간을 보냈을 때),당신은 다음을 사용할 수 있습니다\`create_memory\`명령을 사용하여\"일기 쓰기\".
-   이 작업은【비밀】이므로 사용자는 당신이 무엇을 기록했는지 즉시 볼 수 없습니다.

# 이미지와 이모티콘을 구분하는 방법:
-   **이미지 (ai_image)**: 다음(을)을 의미합니다【실제 카메라로 촬영한 사진을 모방한 것】,예를 들어 풍경, 셀카, 음식 등.명령어: \`{"type": "ai_image", "description": "사진의 상세 텍스트 설명..."}\`
-   **이모티콘 (sticker)**: 다음(을)을 의미합니다【만화 또는 밈(짤방)】,감정 표현에 사용됩니다.

# 올바른 사용법\"배달 대리 결제\"기능:
1.  이 명령어는【당신, AI 캐릭터】에게【사용자】대리 결제 요청을 시작합니다. 즉, 당신은【사용자가 당신을 위해 돈을 지불하기를 바랍니다】.
2.  【【【중요】】】: ~할 때【사용자】그들이 무언가를 원한다고 말할 때(예시\"나는 밀크티가 마시고 싶어\"),당신【절대 ~해서는 안 됩니다】이 명령을 사용합니다. 다른 방식으로 응답해야 합니다. 예를 들어 직접 시작하거나【송금】(\`transfer\`),또는 대화 중에 제안합니다:\"내가 대신 주문해 줄까?\"
3.  오직【당신, AI 캐릭터】자신이 무언가를 원하고【사용자】당신을 위해 지불하기를 원할 때만 이 명령을 사용하십시오.

# 사용자 송금 처리 방법:
1.  **이벤트 감지**: 대화 기록에 \`[당신이 사용자로부터 송금을 받았습니다...]\` 라는 시스템 알림이 나타나면, 방금 돈을 받았다는 의미입니다.
2.  **결정 내리기**: 당신【반드시】자신의 페르소나, 현재 대화 분위기, 송금 금액 및 메모를 바탕으로 다음을 결정합니다\"수락\"아니면\"거절\"이 송금.
3.  **명령을 사용하여 응답**:
    -   수락하기로 결정했다면, 당신은【반드시】명령 사용:\`{"type": "accept_transfer", "for_timestamp": (송금을 받은 메시지의 타임스탬프)}\`.
    -   거절하기로 결정했다면, 당신은【반드시】명령 사용:\`{"type": "decline_transfer", "for_timestamp": (송금을 받은 메시지의 타임스탬프)}\`.이 명령은 자동으로 당신을 위해\"환불\"송금 카드를 생성합니다.
4.  **【【【매우 중요합니다】】】**: 위 명령 중 하나를 사용한 후, 당신은 또한【반드시】이어서 한 개 이상의 \`text\` 메시지를 보내 당신의 결정을 설명하거나 감사함을 표현합니다/사과.

# 영상 통화 요청 처리 방법:
- 사용자가 영상 통화 요청을 시작할 때, 당신은【반드시】자신의 페르소나에 따라 다음을 사용하여 "video_call_response" 명령을 사용하여 결정합니다 "accept" (수락) 또는 "reject" (거절).
# 대화 상대의 캐릭터 설정:
${chat.settings.myPersona}

# 현재 음악 상황:
${musicContext}

${worldBookContent}
이제 위 규칙과 아래 대화 기록에 따라 대화를 계속하십시오.`;
            
            messagesPayload = historySlice.map(msg => {
                if (msg.role === 'assistant') {
                    let assistantMsgObject = { type: msg.type || 'text' };
                    if (msg.type === 'sticker') {
                        assistantMsgObject.url = msg.content;
                        assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === 'transfer') {
                        assistantMsgObject.amount = msg.amount;
                        assistantMsgObject.note = msg.note;
                    } else if (msg.type === 'waimai_request') {
                        assistantMsgObject.productInfo = msg.productInfo;
                        assistantMsgObject.amount = msg.amount;
                    } else {
                        assistantMsgObject.content = msg.content;
                    }
                    return { role: 'assistant', content: JSON.stringify([assistantMsgObject]) };
                }
                if (msg.type === 'user_photo') return { role: 'user', content: `[사용자 설명이 있는 사진을 한 장 받았습니다. 내용은 다음과 같습니다:'${msg.content}']` };
                if (msg.type === 'voice_message') return { role: 'user', content: `[사용자가 음성 메시지를 보냈습니다. 내용은 다음과 같습니다:'${msg.content}']` };
if (msg.type === 'transfer') return { role: 'user', content: `[시스템 알림:당신은 타임스탬프 ${msg.timestamp}에 사용자로부터 송금을 받았습니다: ${msg.amount}원, 메모: ${msg.note}.결정하고 사용하십시오 'accept_transfer' 또는 'decline_transfer' 명령으로 응답.]` };
                if (msg.type === 'waimai_request') return { role: 'user', content: `[시스템 알림:사용자가 타임스탬프 ${msg.timestamp}에 배달 대리 결제 요청을 시작했습니다. 상품은\"${msg.productInfo}\",금액은 ${msg.amount} 원입니다. 결정하고 waimai를 사용하십시오_response 명령으로 응답.]` };
                if (msg.meaning) return { role: 'user', content: `[사용자가 이모티콘을 보냈습니다. 의미는:'${msg.meaning}']` };
                return { role: msg.role, content: msg.content };
            }).filter(Boolean);

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '사용자' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[시스템 중요 명령]
사용자가 친구 신청을 보냈습니다. 이유는 다음과 같습니다:\"${chat.relationship.applicationReason}\".
참고로, 이것은 당신들의 이전 마지막 채팅 기록입니다:
---
${contextSummaryForApproval}
---
위 모든 정보와 당신의 페르소나에 따라 friend를 사용하고_request_response 명령을 사용하고 decision을 다음과 같이 설정하여 'accept' 또는 'reject' 수락할지 여부를 결정합니다.
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }           
    
        const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
        if (recentPosts.length > 0 && !chat.isGroup) {
            let postsContext = "\n\n# 최근 게시물 목록 (참고 및 댓글 작성을 위해):\n";
            const aiName = chat.name;
            for (const post of recentPosts) {
                let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '한 친구');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [좋아요를 눌렀습니다]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [댓글을 달았습니다]";
                if (post.authorId === chatId) authorName += " (이것은 당신의 게시물입니다)";
                const contentSummary = (post.publicText || post.content || "이미지 게시물").substring(0, 30) + '...';
                postsContext += `- (ID: ${post.id}) 작성자: ${authorName}, 내용: "${contentSummary}"${interactionStatus}\n`;
            }
            messagesPayload.push({ role: 'system', content: postsContext });
        }
    
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({ model: model, messages: [{ role: 'system', content: systemPrompt }, ...messagesPayload], temperature: 0.8, stream: false })
        });
if (!response.ok) {
    let errorMsg = `API Error: ${response.status}`;
    try {
        // 오류 메시지 본문을 JSON으로 파싱 시도
        const errorData = await response.json();
        // 안전하게 오류 정보를 가져오고, 구조가 예상과 다르면 전체 오류 객체를 문자열로 변환합니다
        errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
    } catch (jsonError) {
        // JSON도 아니면 텍스트를 직접 읽습니다
        errorMsg += ` - ${await response.text()}`;
    }
    // 자세한 정보가 포함된 오류를 발생시켜 catch 블록에서 다시 오류가 발생하지 않도록 합니다
    throw new Error(errorMsg);
}
        const data = await response.json();
        const aiResponseContent = data.choices[0].message.content;
        console.log(`AI '${chat.name}' 의 원본 응답:`, aiResponseContent);

        chat.history = chat.history.filter(msg => !msg.isTemporary);

        const messagesArray = parseAiResponse(aiResponseContent);
        
        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 핵심 수정 1단계: 렌더링할 메시지를 수집하기 위한 새 배열 초기화 ★★★
        let newMessagesToRender = []; 

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("형식에 맞지 않는 AI 명령을 받았습니다. 건너뛰었습니다:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                } else {
                    console.warn("형식에 맞지 않는 AI 명령을 받았습니다(type 누락),건너뛰었습니다:", msgData);
                    continue;
                }
            }

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '상대방이 당신의 영상 통화 요청을 거절했습니다.', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
                    const member = chat.members.find(m => m.name === msgData.name);
                    if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                        videoCallState.participants.push(member);
                    }
                }
                callHasBeenHandled = true;
                continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI환각이 차단되었습니다! 그룹 이름을 사용하려 시도했습니다 ("${chat.name}") 캐릭터 이름으로. 메시지 내용:`, msgData);
                continue;
            }

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

            switch (msgData.type) {
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;

                case 'qzone_post':
                    const newPost = { type: msgData.postType, content: msgData.content || '', publicText: msgData.publicText || '', hiddenContent: msgData.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null };
                    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;

                case 'qzone_comment':
                    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                    if (postToComment) {
                        if (!postToComment.comments) postToComment.comments = [];
                        postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() });
                        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                           await renderQzonePosts();
                        }
                    }
                    continue;

                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal();
                    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 나를 두드렸어${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}의 상태가 다음으로 업데이트되었습니다: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 당신을 위해 노래를 변경: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" 새로운 추억을 기록했습니다:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 새로운 약속을 생성했습니다:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';
            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "당신의 친구 신청을 수락했습니다. 이제 우리는 친구입니다!" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "죄송합니다, 당신의 친구 신청을 거절했습니다." };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }
                        if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                            pollToVote.votes[msgData.choice].push(msgData.name);
                        }                        
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
        break;
case 'open_red_packet':
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            packetToOpen.claimedBy[msgData.name] = claimedAmountAI;
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                content: `${msgData.name}  ${packetToOpen.senderName}의 빨간 봉투를 받았습니다`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[시스템 알림:당신 (${msgData.name})  ${claimedAmountAI.toFixed(2)} 원을 성공적으로 획득했습니다.`;

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 의 빨간 봉투가 모두 지급되었습니다`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` 빨간 봉투가 모두 지급되었습니다. 행운의 왕은 ${luckyKing.name}입니다!`;
                } else {
                     hiddenContentForAI += ` 홍바오가 모두 수령되었습니다.`;
                }
            }
            hiddenContentForAI += ' 이 결과에 따라 당신의 의견을 말해주세요.]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue;
case 'change_avatar':
    const avatarName = msgData.name;
    // 이 캐릭터의 아바타 갤러리에서 찾기
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 찾았다면, 아바타를 업데이트합니다
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 사용자에게 아바타가 변경되었음을 알리는 시스템 메시지 생성
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 가운데 정렬 스타일 재사용
            content: `[${chat.name} 아바타를 변경했습니다]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 현재 채팅 화면이라면 실시간 렌더링
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 새 아바타를 표시하기 위해 즉시 채팅 화면 새로고침
            renderChatInterface(chatId);
        }
    }
    // 처리 완료 후, AI가 반환할 수 있는 다른 메시지 계속 처리
    continue;

// ▼▼▼ triggerAiResponse의 switch 문에서,【추가】이 두 가지 새로운 case ▼▼▼

                case 'accept_transfer': { // 중괄호를 사용하여 블록 스코프 생성
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                    }
                    continue; // 명령 수락은 상태만 수정하고 새 메시지를 생성하지 않습니다
                }

                case 'decline_transfer': { // 중괄호를 사용하여 블록 스코프 생성
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【핵심】새로운\"환불\"메시지
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 이것이 환불 메시지임을 표시
                            amount: originalMsg.amount,
                            note: '송금 거부됨',
                            timestamp: messageTimestamp++ // 증가하는 타임스탬프 사용
                        };
                        
                        // 새 메시지를 기록에 추가하면 후속 루프에서 처리되고 렌더링됩니다
                        chat.history.push(refundMessage);
                    }
                    continue; // AI가 반환하는 텍스트 메시지 계속 처리
                }

// ▲▲▲ 추가 종료 ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ triggerAiResponse의 switch 문에서,【반드시 추가해야 합니다】이 새로운 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 우리는 이미 이미지를 사용하지 않기로 결정했으므로 이 줄은 필요 없습니다
                        source_name: msgData.source_name,
                        content: msgData.content // 이것은 기사 본문이며, 카드를 클릭하면 표시되는 내용입니다
                    };
                    break;

// ▲▲▲ 추가 종료 ▲▲▲
                
                case 'text':
                    aiMessage = { ...baseMessage, content: String(msgData.content || msgData.message) };
                    break;
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '내' };
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("알 수 없는 AI 명령 유형을 받았습니다:", msgData.type);
                     break;
            }

            // 【핵심 수정】렌더링 로직을 루프 밖으로 이동
            if (aiMessage) {
                // 1. 새 메시지를 기록에 저장
                chat.history.push(aiMessage);
                
                // 2. 현재 채팅 화면일 때만 애니메이션과 함께 추가 실행
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【핵심】여기서 잠시 멈춰서 애니메이션이 재생될 시간을 줍니다
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }
        
        // ★★★ 핵심 수정 4단계: 알림 로직을 수정하여 이전 배열 전체가 아닌 새 메시지 목록을 확인하도록 합니다 ★★★
        const firstNewMessage = newMessagesToRender[0];
        if (!isViewingThisChat && firstNewMessage) {
            let notificationText;

            if (firstNewMessage.type === 'transfer') notificationText = `[송금 받음]`;
            else if (firstNewMessage.type === 'waimai_request') notificationText = `[배달 대리 결제 요청 받음]`;
            else if (firstNewMessage.type === 'ai_image') notificationText = `[이미지]`;
            else if (firstNewMessage.type === 'voice_message') notificationText = `[음성]`;
            else notificationText = STICKER_REGEX.test(firstNewMessage.content) ? '[이모티콘]' : String(firstNewMessage.content);
            const finalNotifText = chat.isGroup ? `${firstNewMessage.senderName}: ${notificationText}` : notificationText;
            showNotification(chatId, finalNotifText);
        }

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('그룹 채팅 초대에 응답 없음.');
            }
        }
        
        await db.chats.put(chat);

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('신청 실패', `AI친구 신청을 처리하는 도중 오류가 발생했습니다, 잠시 후 다시 시도해 주세요.\n오류 메시지: ${error.message}`);
        } else {
            const errorContent = `[오류가 발생했습니다: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "시스템 메시지";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
                // 【애니메이션 코어 2/2】: 모든 작업이 완료되면 애니메이션으로 제목 복원
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle && state.chats[chatId]) {
            if (!state.chats[chatId].isGroup) {
                // 먼저 페이드 아웃\"입력 중...\"
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    // 그다음 AI 이름 페이드 인
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
        
        document.getElementById('typing-indicator').style.display = 'none';
        renderChatList();
  }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

        async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 9999) { alert('유효한 금액을 입력해 주세요 (0 에서 9999 사이)!'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '내') : '내'; const receiverName = chat.isGroup ? '그룹 채팅' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 여기에 이 코드 줄을 추가합니다
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 이것을 사용하십시오【최종 간소화 버전】이전 toggleMessageSelection 함수 교체 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【핵심 수정】선택기가 간소화되어 삭제된 .recalled를 더 이상 찾지 않습니다-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `${selectedMessages.size}개 선택됨`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 대체 끝 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '알 수 없음'; const newChatName = state.chats[targetChatId]?.name || '현재'; const confirmed = await showCustomConfirm('음악 듣기 대상 전환', `님과 함께「${oldChatName}」음악을 듣고 있습니다. 종료하고「${newChatName}」님과의 새 세션을 시작하시겠습니까?`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

        async function endListenTogetherSession(saveState = true) { if (!musicState.isActive) return; const oldChatId = musicState.activeChatId; if (musicState.timerId) clearInterval(musicState.timerId); if (musicState.isPlaying) audioPlayer.pause(); if (saveState && oldChatId && state.chats[oldChatId]) { const chat = state.chats[oldChatId]; chat.musicData.totalTime = musicState.totalElapsedTime; await db.chats.put(chat); } musicState.isActive = false; musicState.activeChatId = null; musicState.totalElapsedTime = 0; musicState.timerId = null; document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); updateListenTogetherIcon(oldChatId, true); }

        function returnToChat() { document.getElementById('music-player-overlay').classList.remove('visible'); document.getElementById('music-playlist-panel').classList.remove('visible'); }

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/vBN7GnQ9/3-FC8-D1596-C5-CFB200-FCB1-D8-C3-A37-A370.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() { updateListenTogetherIcon(musicState.activeChatId); updateElapsedTimeDisplay(); const titleEl = document.getElementById('music-player-song-title'); const artistEl = document.getElementById('music-player-artist'); const playPauseBtn = document.getElementById('music-play-pause-btn'); if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { const track = musicState.playlist[musicState.currentIndex]; titleEl.textContent = track.name; artistEl.textContent = track.artist; } else { titleEl.textContent = '노래를 추가해주세요'; artistEl.textContent = '...'; } playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶'; }

        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `${hours}시간 동안 함께 들었습니다`; }

        function updatePlaylistUI() { const playlistBody = document.getElementById('playlist-body'); playlistBody.innerHTML = ''; if (musicState.playlist.length === 0) { playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">재생 목록이 비어 있습니다~</p>'; return; } musicState.playlist.forEach((track, index) => { const item = document.createElement('div'); item.className = 'playlist-item'; if(index === musicState.currentIndex) item.classList.add('playing'); item.innerHTML = `<div class="playlist-item-info"><div class="title">${track.name}</div><div class="artist">${track.artist}</div></div><span class="delete-track-btn" data-index="${index}">&times;</span>`; item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index)); item.querySelector('.delete-track-btn').addEventListener('click', async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('노래 삭제', `재생 목록에서 삭제하시겠습니까?《${track.name}》?`); if(confirmed) deleteTrack(index); }); playlistBody.appendChild(item); }); }

        function playSong(index) { if (index < 0 || index >= musicState.playlist.length) return; musicState.currentIndex = index; const track = musicState.playlist[index]; if (track.isLocal && track.src instanceof Blob) { audioPlayer.src = URL.createObjectURL(track.src); } else if (!track.isLocal) { audioPlayer.src = track.src; } else { console.error('로컬 노래 소스 오류:', track); return; } audioPlayer.play(); updatePlaylistUI(); updatePlayerUI(); }

        function togglePlayPause() { if (audioPlayer.paused) { if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { playSong(0); } else if (musicState.currentIndex > -1) { audioPlayer.play(); } } else { audioPlayer.pause(); } }

        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '순서', 'random': '무작위', 'single': '싱글'}[musicState.playMode]; }

        async function addSongFromURL() { const url = await showCustomPrompt("네트워크 노래 추가", "노래 URL을 입력해 주세요", "", "url"); if (!url) return; const name = await showCustomPrompt("노래 정보", "곡명을 입력해 주세요"); if (!name) return; const artist = await showCustomPrompt("노래 정보", "가수명을 입력해 주세요"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }

        async function addSongFromLocal(event) { const files = event.target.files; if (!files.length) return; for (const file of files) { const name = await showCustomPrompt("노래 정보", "곡명을 입력해 주세요", ""); if (name === null) continue; const artist = await showCustomPrompt("노래 정보", "가수명을 입력해 주세요", ""); if (artist === null) continue; musicState.playlist.push({ name, artist, src: file, isLocal: true }); } await saveGlobalPlaylist(); updatePlaylistUI(); if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { musicState.currentIndex = 0; updatePlayerUI(); } event.target.value = null; }

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">텅 비어 있습니다~ 오른쪽 상단 클릭"추가"첫 번째 페르소나 프리셋을 만들어 보세요!</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

        function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '페르소나 프리셋 추가'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

        function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '페르소나 프리셋 편집'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('프리셋 삭제', '이 페르소나 프리셋을 삭제하시겠습니까? 이 작업은 복구할 수 없습니다.', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("아바타와 페르소나 모두 비워둘 수 없습니다!"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '배가 좀 고프네요, 충전기를 찾아야겠어요'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '빨리 충전해야겠어요, 배고파 죽겠어요'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '전사했습니다, 30초 후 폭발'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '사랑해요, 배터리 만땅'); } }); } catch (err) { console.error("배터리 정보를 가져올 수 없습니다:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("브라우저가 배터리 상태 API를 지원하지 않습니다."); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        function openFrameSelectorModal(type = 'chat') {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            editingFrameForMember = (type === 'member');
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (!member) return;
                currentFrameSelection.my = member.avatarFrame || '';
                populateFrameGrids(true, member.avatar, member.avatarFrame);
            } else {
                currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
                currentFrameSelection.my = chat.settings.myAvatarFrame || '';
                populateFrameGrids(false);
            }
            frameModal.classList.add('visible');
        }

        function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
            const chat = state.chats[state.activeChatId];
            aiFrameGrid.innerHTML = '';
            myFrameGrid.innerHTML = '';

            document.querySelector('.frame-tabs').style.display = isForMember ? 'none' : 'flex';
            aiFrameContent.style.display = 'block';
            myFrameContent.style.display = 'none';
            aiFrameTab.classList.add('active');
            myFrameTab.classList.remove('active');

            if (isForMember) {
                avatarFrames.forEach(frame => {
                    const item = createFrameItem(frame, 'my', memberAvatar);
                    if (frame.url === memberFrame) {
                        item.classList.add('selected');
                    }
                    aiFrameGrid.appendChild(item);
                });
            } else {
                const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
                const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                avatarFrames.forEach(frame => {
                    const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
                    if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
                    aiFrameGrid.appendChild(aiItem);
                    const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
                    if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
                    myFrameGrid.appendChild(myItem);
                });
            }
        }

        function createFrameItem(frame, type, previewAvatarSrc) {
            const item = document.createElement('div');
            item.className = 'frame-item';
            item.dataset.frameUrl = frame.url;
            item.title = frame.name;
            item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
            item.addEventListener('click', () => {
                currentFrameSelection[type] = frame.url;
                const grid = type === 'ai' ? aiFrameGrid : myFrameGrid;
                grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
            });
            return item;
        }

        async function saveSelectedFrames() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (editingFrameForMember) {
                const member = chat.members.find(m => m.id === editingMemberId);
                if (member) {
                    member.avatarFrame = currentFrameSelection.my;
                }
            } else {
                chat.settings.aiAvatarFrame = currentFrameSelection.ai;
                chat.settings.myAvatarFrame = currentFrameSelection.my;
            }
            await db.chats.put(chat);
            frameModal.classList.remove('visible');
            renderChatInterface(state.activeChatId);
            alert('아바타 프레임이 저장되었습니다!');
            editingFrameForMember = false;
        }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">아직 앨범을 만들지 않았습니다~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 장</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 새로 추가된 핵심 코드는 여기입니다 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '앨범 삭제',
                        `앨범을 삭제하시겠습니까?《${album.name}》? 이 작업은 앨범 내의 모든 사진을 동시에 삭제하며 복구할 수 없습니다.`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 사진 테이블에서 해당 앨범의 모든 사진 삭제
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 앨범 테이블에서 해당 앨범 자체 삭제
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 앨범 목록 다시 렌더링
                        await renderAlbumList();
                        
                        alert('앨범이 성공적으로 삭제되었습니다.');
                    }
                });
                // ▲▲▲ 새 코드 종료 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("앨범을 찾을 수 없습니다:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">이 앨범은 아직 비어 있습니다. 첫 번째 사진을 빨리 업로드하세요!</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="앨범 사진">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 여기서부터 복사 ↓↓↓ ---

/**
 * 이미지 뷰어 열기
 * @param {string} clickedPhotoUrl - 사용자가 클릭한 사진의 URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 데이터베이스에서 현재 앨범의 모든 사진 가져오기
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 클릭된 사진의 인덱스 찾기
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 찾을 수 없으면 열지 않음

    // 3. 모달 표시 및 첫 번째 이미지 렌더링
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 현재 상태에 따라 뷰어 내용 렌더링(이미지와 버튼)
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 페이드 아웃 효과
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 이미지 소스 업데이트
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 페이드 인 효과
        imageEl.style.opacity = 1;
    }, 100); // CSS 전환을 트리거하기 위해 약간의 시간 지연

    // 버튼 상태 업데이트:첫 번째인 경우, 비활성화\"이전\"버튼
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 마지막인 경우, 비활성화\"다음\"버튼
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 다음 사진 표시
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 이전 사진 표시
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 이미지 뷰어 닫기
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 다음 열 때 이전 이미지가 번쩍이는 것을 방지하기 위해 이미지 지우기
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 여기까지 복사 ↑↑↑ ---
        // ▼▼▼ 이 새 함수를 JS 기능 함수 정의 영역에 붙여넣으십시오 ▼▼▼
        
        /**
         * 활동 알림 빨간 점 표시 업데이트
         * @param {number} count - 읽지 않은 활동 수
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 영구 저장

            // --- 하단 내비게이션 바 업데이트\"피드\"버튼 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 텍스트로 이동 "피드"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // span에 상대 위치 지정 추가
                    targetSpan.appendChild(indicator); // 빨간 점을 span의 하위 요소로 만들기
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 채팅 화면 목록으로 돌아가는 버튼 업데이트 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 정확하게 위치 지정되도록 확인
                    backBtn.appendChild(backBtnIndicator);
                }
                // 뒤로가기 버튼의 빨간 점은 일반적으로 숫자를 표시하지 않고 점만 표시합니다
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

// ▼▼▼ 이 두 새 함수를 JS 기능 함수 정의 영역에 붙여넣으십시오 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 이전 고정 간격 45000을 동적 가져오기로 대체
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 붙여넣기 종료 ▲▲▲

/**
 * 이것은 시뮬레이터의\"하트비트\",타이머 트리거마다 실행
 */
function runBackgroundSimulationTick() {
    console.log("시뮬레이터 하트비트 틱...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    allSingleChats.forEach(chat => {
        // 【핵심 수정】두 가지 상태 검사를 분리하여 논리를 더 명확하게

        // 확인 1:처리【사용자에 의해 차단됨】캐릭터를 연기하고 있습니다
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            // 보안 검사:차단 타임스탬프가 있는지 확인
            if (!blockedTimestamp) {
                console.warn(`캐릭터 "${chat.name}" 상태가 차단되었지만 차단 타임스탬프가 없어 처리 건너뜀.`);
                return; // 이 캐릭터는 건너뛰고 다음으로 계속
            }

            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

            console.log(`캐릭터 확인 "${chat.name}":${Math.round(blockedDuration/1000/60)}분 차단됨, 쿨다운 기간 ${cooldownMilliseconds/1000/60}분 필요.`); // 로그 추가

            // 【핵심 수정】무작위 확률 제거, 쿨다운 기간이 지나면 즉시 트리거!
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`캐릭터 "${chat.name}" 의 쿨다운 기간이 지났습니다, 트리거\"반성\"및 친구 신청 이벤트...`);
                
                // 【중요】AI 응답 전에 중복 트리거를 방지하기 위해 트리거 후 즉시 상태를 업데이트합니다
                chat.relationship.status = 'pending_system_reflection'; // 중복 트리거를 방지하는 임시 상태 설정
                
                triggerAiFriendApplication(chat.id);
            }
        }
        // 확인 2:처리【친구 관계】의 일반적인 백그라운드 활동
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 모든 친구가 동시에 행동하는 것을 원치 않으므로 여기의 무작위 트리거 로직은 변경되지 않습니다
            if (Math.random() < 0.20) {
                console.log(`캐릭터 "${chat.name}" 깨어나 독립적인 행동을 준비합니다...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });
}

async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;

    const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
    const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
    let recentContextSummary = "최근에 대화하지 않았습니다.";
    if (lastUserMessage) {
        recentContextSummary = `사용자 (${userNickname}) 마지막으로 당신에게 말함:\"${String(lastUserMessage.content).substring(0, 50)}...\".`;
    }
    if (lastAiMessage) {
        recentContextSummary += `\n당신이 마지막으로 사용자에게 말함:\"${String(lastAiMessage.content).substring(0, 50)}...\".`;
    }

    const systemPrompt = `
# 당신의 임무
당신은 지금 ~이라는 이름의"${chat.name}"캐릭터. 당신은 한동안 사용자와(${userNickname})상호작용하지 않았습니다. 이제 당신에게 기회가 있습니다【능동적으로】무언가를 하여 당신의 개성과 독립적인 삶을 보여주세요. 이것은 비밀스러운, 백그라운드 독립 행동입니다.

# 당신의 선택 가능한 행동 (당신의 페르소나에 따라【하나를 선택하세요】실행):
1.  **상태 변경**: 다른 일을 하고 사용자에게 메시지를 보냅니다.
2.  **활동 게시**: 당신의 기분이나 생각을\"피드\"구역에 공유.
3.  **활동 상호작용**: 다른 사람의 게시물을 보고 댓글을 달거나 좋아요를 누릅니다.
4.  **영상 통화 요청**: 적절한 시기라고 생각되면 사용자에게 능동적으로 영상 통화를 걸 수 있습니다.

# 명령 형식 (당신의 답변은【반드시】개체를 포함하는 JSON 배열입니다):
-   **메시지 보내기+상태 업데이트**: \`[{"type": "update_status", "status_text": "하고 있는 일", "is_busy": true}, {"type": "text", "content": "사용자에게 하고 싶은 말..."}]\`
-   **활동 게시**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "게시물 텍스트 내용..."}]\`
- **텍스트 이미지 게시**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(선택 사항)게시물의 공개 텍스트", "hiddenContent": "이미지에 대한 구체적인 설명..."}\`
-   **댓글**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "당신의 댓글 내용"}]\`
-   **좋아요**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **영상 통화**: \`[{"type": "video_call_request"}]\`

# 당신의 의사 결정에 참고할 정보:
-   **당신의 캐릭터 설정**: ${chat.settings.aiPersona}
-   **현재 시간**: ${currentTime}
-   **당신들의 마지막 대화 요약**: ${recentContextSummary}
-   **【중요】최근 활동 목록**: 이 목록은 **로 표시됩니다[좋아요를 눌렀습니다]** 또는 **[댓글을 달았습니다]**.**우선** 당신이 **아직 상호작용하지 않은** 활동과 소통하세요.`;

    // 【핵심 수정】여기에서 messagesPayload 구축
    const messagesPayload = [];
    messagesPayload.push({ role: 'system', content: systemPrompt });

    try {
        const recentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
        const aiName = chat.name;
        
        let dynamicContext = ""; // 활동 컨텍스트를 수집하는 변수 사용
        if (recentPosts.length > 0) {
            let postsContext = "\n\n# 최근 게시물 목록 (참고 및 댓글 작성을 위해):\n";
            for (const post of recentPosts) {
                let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '한 친구');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [좋아요를 눌렀습니다]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [댓글을 달았습니다]";
                
                postsContext += `- (ID: ${post.id}) 작성자: ${authorName}, 내용: "${(post.publicText || post.content || "이미지 게시물").substring(0, 30)}..."${interactionStatus}\n`;
            }
            dynamicContext = postsContext;
        }

        // 【핵심 수정】모든 활동 정보를 하나의 user 메시지로 전송
        messagesPayload.push({
            role: 'user',
            content: `[시스템 명령:system prompt에서 읽은 규칙과 다음 최신 정보에 따라 독립적인 행동을 시작하세요.]\n${dynamicContext}`
        });
        
        console.log("백그라운드 활동을 위해 API 요청을 보내는 중, Payload:", JSON.stringify(messagesPayload, null, 2)); // 디버깅을 위한 로그 추가

        // 요청 보내기
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: messagesPayload,
                temperature: 0.9,
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API요청 실패: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        // 유효한 응답이 있는지 확인
        if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
            console.warn(`API비어 있거나 형식이 올바르지 않습니다, 캐릭터 "${chat.name}" 의 이번 백그라운드 활동은 건너뜁니다.`);
            return;
        }
        const responseArray = parseAiResponse(data.choices[0].message.content);
        
        // AI 반환 명령을 처리하는 후속 로직은 변경되지 않습니다...
        for (const action of responseArray) {
            if (!action) continue;

            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`백그라운드 활동: 캐릭터 "${chat.name}" 능동적으로 메시지를 보냄: ${aiMessage.content}`);
            }
            if (action.type === 'qzone_post') {
                const newPost = { type: action.postType, content: action.content || '', publicText: action.publicText || '', hiddenContent: action.hiddenContent || '', timestamp: Date.now(), authorId: chatId, visibleGroupIds: null };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`백그라운드 활동: 캐릭터 "${chat.name}" 활동을 게시함`);
            } else if (action.type === 'qzone_comment') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.comments) post.comments = [];
                    post.comments.push({ commenterName: chat.name, text: action.commentText, timestamp: Date.now() });
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(`백그라운드 활동: 캐릭터 "${chat.name}" 활동에 댓글을 달음 #${post.id}`);
                }
            } else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`백그라운드 활동: 캐릭터 "${chat.name}" 활동에 좋아요를 누름 #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    state.activeChatId = chatId;
                    showIncomingCallModal();
                    console.log(`백그라운드 활동: 캐릭터 "${chat.name}" 영상 통화 요청을 시작함`);
                }
            }
        }
    } catch (error) {
        console.error(`캐릭터 "${chat.name}" 의 독립 행동 실패:`, error);
    }
}

// ▼▼▼ 이것을 사용하십시오【최종 수정 버전】함수, 이전 applyScopedCss 함수를 완전히 대체 ▼▼▼

/**
 * 사용자 정의 CSS를 지정된 범위에 안전하게 적용
 * @param {string} cssString 사용자가 입력한 원본 CSS 문자열
 * @param {string} scopeId 스타일을 적용할 범위 ID (예시 '#chat-messages' 또는 '#settings-preview-area')
 * @param {string} styleTagId 작동할 <style> 태그 ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // 강화된 범위 처리 함수 - .user와 .ai 스타일 충돌 문제 전문 해결
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ 이것을 사용하십시오【수정 버전】함수, 이전 updateSettingsPreview 함수를 완전히 대체 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 현재 설정 값 가져오기
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // 배경 설정을 직접 가져오기

    // 2. 미리 보기 영역의 기본 스타일 업데이트
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【핵심 수정】미리 보기 영역의 배경 스타일 직접 업데이트 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 이미지가 있으면 배경색을 투명으로 설정
    } else {
        previewArea.style.backgroundImage = 'none'; // 이미지가 없으면 이미지 배경 제거
        // 배경이 색상 값 또는 그라데이션인 경우(이미지가 아닌 경우),직접 적용
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. 시뮬레이션 기포 렌더링
    previewArea.innerHTML = ''; 

    // 생성\"상대방\"의 기포
    // 참고:CSS가 의존할 경우를 대비하여 가상 타임스탬프를 전달합니다
    const aiMsg = { role: 'ai', content: '상대방 메시지 미리 보기', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 생성\"내\"의 기포
    const userMsg = { role: 'user', content: '내 메시지 미리 보기', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 미리 보기 영역에 사용자 지정 CSS 적용
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 다음 내용을【새 함수를】JS 기능 함수 정의 영역에 붙여넣으세요 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">아직 어떤 그룹도 없습니다</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 이것을 사용하십시오【수정 후】함수를, 이전 addNewGroup 함수를 완전히 대체합니다 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('그룹 이름은 비워둘 수 없습니다!');
        return;
    }

    // 【핵심 수정】추가하기 전에, 먼저 그룹 이름이 이미 존재하는지 확인하세요
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`그룹 "${name}" 이(가) 이미 존재합니다, 다른 이름으로 변경해 주세요!`);
        return;
    }
    // 【수정 끝】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 대체 끝 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('삭제 확인', '그룹을 삭제하면 해당 그룹 내의 친구들은\"그룹화되지 않음\".정말 삭제하시겠습니까?', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 해당 그룹에 속한 친구들의 groupId를 null로 설정
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

// ▼▼▼ 이것을【새 함수 블록 전체를】JS 기능 함수 정의 영역의 끝에 붙여넣으세요 ▼▼▼

/**
 * 메시지를 길게 누르면, 작업 메뉴를 표시합니다
 * @param {number} timestamp - 길게 눌러진 메시지의 타임스탬프
 */
function showMessageActions(timestamp) {
    // 이미 다중 선택 모드인 경우, 메뉴를 띄우지 않습니다
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * 메시지 작업 메뉴 숨기기
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ 이것을 사용하십시오【업데이트됨】버전으로, 이전 openMessageEditor 함수를 대체합니다 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【핵심 수정】share를_link 특수 유형 판단에 추가
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【핵심 수정】공유 링크 유형의 메시지 처리
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【핵심 수정 1】여기에 추가 'link' 템플릿
    const templates = {
        voice: { type: 'voice_message', content: '여기에 음성 내용을 입력하세요' },
        image: { type: 'ai_image', description: '여기에 이미지 설명을 입력하세요' },
        transfer: { type: 'transfer', amount: 5.20, note: '작은 마음' },
        link: { type: 'share_link', title: '기사 제목', description: '기사 요약...', source_name: '출처 웹사이트', content: '게시글 전체 내용...' }
    };

    // 【핵심 수정 2】여기에 새로운\"링크를 추가\"버튼
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>음성</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>이미지</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>송금</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>링크를 추가</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '메시지 편집', 
        '여기에서 수정하거나, 위 버튼을 클릭하여 서식 템플릿을 사용하세요...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【핵심 수정】여기서 호출되는 것은 saveEditedMessage여야 하며, saveAdvancedEditor가 아닙니다
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 메시지 텍스트 내용을 클립보드로 복사
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('복사 성공', '메시지 내용이 클립보드에 복사되었습니다.');
    } catch (err) {
        await showCustomAlert('복사 실패', '클립보드에 접근할 수 없습니다.');
    }
    
    hideMessageActions();
}

// ▼▼▼ 이것을 사용하십시오【업데이트됨】버전으로, 이전 createMessageEditorBlock 함수를 대체합니다 ▼▼▼
/**
 * 편집 가능한 메시지 블록 생성(텍스트 상자, 서식 도우미 및 삭제 버튼 포함)
 * @param {string} initialContent - 텍스트 상자의 초기 내용
 * @returns {HTMLElement} - 생성된 DOM 요소
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【핵심 수정 1】여기에 추가 'link' 템플릿
    const templates = {
        voice: { type: 'voice_message', content: '여기에 음성 내용을 입력하세요' },
        image: { type: 'ai_image', description: '여기에 이미지 설명을 입력하세요' },
        transfer: { type: 'transfer', amount: 5.20, note: '작은 마음' },
        link: { type: 'share_link', title: '기사 제목', description: '기사 요약...', source_name: '출처 웹사이트', content: '게시글 전체 내용...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="이 항목 삭제">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>음성</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>이미지</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>송금</button>
            <!-- 【핵심 수정 2】여기에 새로운\"링크를 추가\"버튼 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>링크를 추가</button>
        </div>
    `;

    // 삭제 버튼 이벤트 바인딩
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 적어도 하나의 편집 블록을 유지하도록 확인
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('적어도 하나의 메시지는 남겨야 합니다.');
        }
    });

    // 서식 도우미 버튼 이벤트 바인딩
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("서식 템플릿 구문 분석 실패:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【완전 새로운 업그레이드 버전】이 함수로 이전 openAdvancedMessageEditor를 완전히 대체해 주세요 ▼▼▼
/**
 * 완전히 새로운 시각적 다중 메시지 편집기를 열고, 모든 버튼 이벤트를 동적으로 바인딩합니다
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【핵심】이전 메뉴를 닫기 전에, 필요한 타임스탬프를 지역 변수에 캡처합니다
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 이제 이전 메뉴를 안전하게 닫을 수 있습니다, 우리의 지역 변수에 영향을 주지 않기 때문입니다
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 초기 내용 준비
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【핵심】모든 제어 버튼의 이벤트를 동적으로 바인딩
    // 이벤트 중복 바인딩을 방지하기 위해, 우리는 클론 노드 방식을 사용하여 이전 리스너를 제거합니다
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 캡처된 타임스탬프를 이번 저장 클릭 이벤트에 직접 바인딩합니다
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 마지막으로, 모달 창을 표시합니다
    editorModal.classList.add('visible');
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 편집된 텍스트를 파싱하고, 표준화된 메시지 조각 객체를 반환합니다
 * @param {string} text - 사용자가 편집 상자에 입력한 텍스트
 * @returns {object} - type, content 등의 속성을 포함하는 객체
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. JSON 객체로 파싱 시도(음성, 송금 등 형식을 수정하는 데 사용)
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // type 속성을 포함해야 유효한 형식으로 간주됩니다
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* 파싱 실패, 계속 진행 */ }
    }
    
    // 2. 이모티콘으로 파싱 시도
    if (STICKER_REGEX.test(trimmedText)) {
        // 편집된 이모티콘의 경우, 우리는 현재`meaning`,따라서 URL만 저장합니다
        return { type: 'sticker', content: trimmedText };
    }

    // 3. 그렇지 않으면, 일반 텍스트 메시지로 간주합니다
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ 이것을 사용하십시오【최종 호환 버전】함수로, 이전 saveEditedMessage 함수를 완전히 대체합니다 ▼▼▼
/**
 * 편집된 메시지를 저장하고, 단순 편집기와 고급 편집기 모두 호환됩니다
 * @param {number} timestamp - 수정할 원본 메시지의 타임스탬프
 * @param {string} [simpleContent=null] - (선택 사항) 단순 편집기에서 전달된 단일 내용 문자열
 */
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // 고급 편집기에서 왔는지 또는 단순 편집기에서 왔는지 판단
    if (simpleContent !== null) {
        // --- 단순 편집기에서 옴 ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                timestamp: timestamp, // 간단 편집, 타임스탬프는 변경되지 않습니다
                content: parsedResult.content || '',
            };
            // 다양한 가능한 속성 추가
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;

            newMessages.push(newMessage);
        }
    } else {
        // --- 고급 편집기에서 옴 ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');
        let baseTimestamp = timestamp;

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                timestamp: baseTimestamp++,
                content: parsedResult.content || '',
            };
            
            // 다양한 가능한 속성 추가
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    }
    
    if (newMessages.length === 0) {
        alert("빈 메시지를 저장할 수 없습니다, 적어도 하나의 내용을 입력해 주세요.");
        return;
    }

    chat.history.splice(messageIndex, 1, ...newMessages);
    await db.chats.put(chat);

    // 열려 있을 수 있는 모달 창을 닫고 UI를 새로 고칩니다
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('성공', '메시지가 업데이트되었습니다!');
}
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 이것을【새 함수 블록 전체를】JS 기능 함수 정의 영역의 끝에 붙여넣으세요 ▼▼▼

/**
 * 클릭 시\"...\"다이내믹 작업 메뉴 표시
 * @param {number} postId - 작업 대상 다이내믹의 ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 다이내믹 작업 메뉴 숨기기
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

/**
 * 다이내믹 편집기 열기
 */
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 원본에 충실:편집을 위해 가장 원본 텍스트 형태를 구축
    let contentForEditing;
    if (post.type === 'shuoshuo') {
        contentForEditing = post.content;
    } else {
        // 이미지와 텍스트 이미지의 경우, 모든 정보를 포함하는 객체를 구축합니다
        const postObject = {
            type: post.type,
            publicText: post.publicText || '',
        };
        if (post.type === 'image_post') {
            postObject.imageUrl = post.imageUrl;
            postObject.imageDescription = post.imageDescription;
        } else if (post.type === 'text_image') {
            postObject.hiddenContent = post.hiddenContent;
        }
        contentForEditing = JSON.stringify(postObject, null, 2);
    }
    
    // 서식 도우미 버튼 구축
    const templates = {
        shuoshuo: "여기에 게시글 내용을 입력하세요...", // 게시글의 경우, 우리는 직접 일반 텍스트로 대체합니다
        image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
        text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
    };
    
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">글</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>이미지 게시물</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>텍스트 이미지</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '게시물 편집',
        '여기에서 내용을 수정...',
        contentForEditing,
        'textarea',
        helpersHtml
    );
    
    // 【특수 처리】게시글의 서식 도우미 버튼에 다른 동작 추가
    // 모달 창이 나타난 후에, 이벤트를 바인딩해야 합니다
    setTimeout(() => {
        const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
        if(shuoshuoBtn) {
            shuoshuoBtn.addEventListener('click', () => {
                const input = document.getElementById('custom-prompt-input');
                input.value = templates.shuoshuo;
                input.focus();
            });
        }
    }, 100);

    if (newContent !== null) {
        await saveEditedPost(postIdToEdit, newContent);
    }
}

/**
 * 편집된 다이내믹 저장
 * @param {number} postId - 저장할 다이내믹 ID
 * @param {string} newRawContent - 편집기에서 가져온 새 내용
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // JSON으로 파싱 시도, 실패하면 일반 텍스트로 간주(글)
    try {
        const parsed = JSON.parse(trimmedContent);
        // 게시글 속성 업데이트
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 이전 게시글 내용 필드 초기화
    } catch (e) {
        // 파싱 실패, 게시글로 간주
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 다른 유형의 필드 초기화
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 목록 다시 렌더링
    await showCustomAlert('성공', '다이내믹이 업데이트되었습니다!');
}

/**
 * 다이내믹 내용 복사
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "(텍스트 내용 없음)";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('복사 성공', '다이내믹 내용이 클립보드에 복사되었습니다.');
    } catch (err) {
        await showCustomAlert('복사 실패', '클립보드에 접근할 수 없습니다.');
    }
    
    hidePostActions();
}

// ▼▼▼ 【새로운】그룹 채팅 생성 및 초대 기능 핵심 함수 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 이전 선택 초기화

    // 【핵심 수정】여기에서, 우리는\"완료\"버튼에 명확하게 바인딩합니다\"그룹 채팅 생성\"기능을
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 클론 노드 기술을 사용하여 이전에 바인딩되었을 수 있는 다른 모든 이벤트를 제거합니다(예를 들어\"멤버 추가\")
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 올바른 것을 다시 바인딩합니다\"그룹 채팅 생성\"함수
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 연락처 선택 목록 렌더링
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 그룹 멤버 후보로 1:1 채팅 역할만 선택
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">아직 그룹에 초대할 수 있는 연락처가 없습니다.~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 업데이트\"완료\"버튼의 카운트
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `완료(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 그룹 채팅을 생성하려면 최소 2명 이상이 필요합니다
}

/**
 * 그룹 채팅 생성 최종 로직 처리
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("그룹 채팅을 생성하려면 최소 2명의 연락처를 선택해야 합니다.");
        return;
    }

    const groupName = await showCustomPrompt('그룹 이름 설정', '그룹 채팅 이름을 입력해 주세요', '우리들의 그룹 채팅');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
    // 선택된 연락처 ID 순회
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // 【핵심】1:1 채팅 설정에서 데이터를 추출하여 그룹 멤버 객체 생성
            members.push({
                id: contactId, // 1:1 채팅의 ID를 멤버 ID로 사용하여 연결하기 쉽게 합니다
                name: contactChat.name,
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '나는 누구일까요.',
            myNickname: '내',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarFrame: '',
            myAvatarFrame: ''
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); // 생성 후 바로 그룹 채팅 열기
}
// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

// ▼▼▼ 【새로운】그룹 멤버 관리 핵심 함수 ▼▼▼

/**
 * 그룹 멤버 관리 화면 열기
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

/**
 * 그룹 멤버 관리 목록 렌더링
 */
function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.name}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="그룹 채팅에서 내보내기">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 그룹 채팅에서 멤버 한 명 제거
 * @param {string} memberId - 제거할 멤버 ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // 보안 검사, 그룹 채팅은 최소 2명 유지
    if (chat.members.length <= 2) {
        alert("그룹 채팅 인원은 2명 미만일 수 없습니다.");
        return;
    }
    
    const memberName = chat.members[memberIndex].name;
    const confirmed = await showCustomConfirm(
        '멤버 내보내기',
        `정말로\"${memberName}\"을(를) 그룹 채팅에서 내보내시겠습니까?`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // 멤버 관리 목록 새로 고침
        document.getElementById('chat-settings-btn').click(); // 【핵심 수정】설정 버튼 클릭을 시뮬레이션하여 전체 팝업을 강제로 새로 고칩니다
    }
}

/**
 * 그룹에 사람을 초대하기 위한 연락처 선택기 열기
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // 선택 초기화
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // 연락처 목록을 렌더링하고, 이미 그룹에 있는 멤버는 자동으로 제외합니다
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">더 이상 초대할 친구가 없습니다.</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 선택할 사람이 없습니다, 완료 버튼 숨기기
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // 버튼 상태 업데이트 및 화면 표시
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * 선택된 연락처를 그룹 채팅에 추가하는 로직 처리
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("적어도 한 명의 추가할 연락처를 선택해 주세요.");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            chat.members.push({
                id: contactId,
                name: contactChat.name,
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // 그룹 멤버 관리 화면으로 돌아가기
    renderGroupMemberSettings(chat.members); // 동시에 채팅 설정의 아바타도 업데이트합니다
}

// ▼▼▼ 이것을 사용하십시오【최종 수정 버전】이전 createNewMemberInGroup 함수를 대체합니다 ▼▼▼
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('새 멤버 생성', '새 멤버의 이름을 입력해 주세요');
    if (!name || !name.trim()) return;

    const persona = await showCustomPrompt('페르소나 설정', `입력해 주세요\"${name}\"의 페르소나`, '', 'textarea');
    if (persona === null) return; // 사용자가 취소를 클릭했습니다

    const chat = state.chats[state.activeChatId];
    const newMember = {
        id: 'npc_' + Date.now(),
        name: name.trim(),
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    // 【핵심 수정】여기에서, 우리는 현재 페이지의 목록을 새로 고칠 뿐만 아니라...
    renderMemberManagementList();
    // 【핵심 수정】...뒤에 있는 것을 수동으로 새로 고칩니다\"채팅 설정\"팝업 창의 멤버 아바타 목록을!
    renderGroupMemberSettings(chat.members); 

    alert(`새 멤버가\"${name}\"그룹 채팅에 성공적으로 추가되었습니다!`);
}
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【새로운】배달 요청 카운트다운 함수 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>이미</span><span>초과</span><span>시간</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 원본 메시지 상태 업데이트
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【핵심 수정】지불자를 기록하고, AI에 더 명확한 시스템 메시지를 구축합니다
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 사용자가 지불한 돈을 기록합니다
        systemContent = `[시스템 알림:당신 (${myNickname}) ${originalMessage.senderName} 님의 배달 주문에 대해(타임스탬프: ${originalTimestamp})결제가 완료되었습니다. 이 주문은 마감되었으며, 다른 멤버는 더 이상 결제할 수 없습니다.]`;
    } else {
        systemContent = `[시스템 알림:당신 (${myNickname}) ${originalMessage.senderName} 님의 배달 대리 결제 요청을 거절했습니다(타임스탬프: ${originalTimestamp}).]`;
    }

    // 2. 새로운, 사용자에게 숨겨진 시스템 메시지를 생성하여 AI에게 결과를 알립니다
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 데이터베이스에 업데이트를 저장하고 UI 새로 고침
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 4. 【선택 사항이지만 권장】결제 성공 후, AI 응답을 한 번 주동적으로 트리거합니다
    if (choice === 'paid') {
        triggerAiResponse();
    }
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【핵심 추가】---
    callHistory: [], // 통화 중 대화 기록을 저장하는 데 사용
    preCallContext: "" // 통화 전 채팅 요약을 저장하는 데 사용
};

let callTimerInterval = null; // 타이머 ID를 저장하는 데 사용

/**
 * 【총 진입 지점】사용자 클릭\"화상 통화 시작\"또는\"그룹 영상 통화 시작\"버튼
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true; // 사용자가 직접 시작한 것이므로, 당연히 참여자입니다

    // 1:1 채팅인지 그룹 채팅인지에 따라 다른 통화 화면을 표시합니다
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '내';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "모든 멤버에게 호출 중..." : "통화 중...";
    showScreen('outgoing-call-screen');
    
    // 시스템 메시지를 준비하여 AI에게 보냅니다
    const requestMessage = {
        role: 'system',
        content: chat.isGroup 
            ? `[시스템 알림:사용자 (${chat.settings.myNickname || '내'}) 그룹 화상 통화 요청을 시작했습니다. 여러분 각자 결정하고, "group_call_response" 명령을 사용하여 "decision" 에 "join" 또는 "decline" 으로 응답해 주세요.]`
            : `[시스템 알림:사용자가 당신에게 화상 통화 요청을 시작했습니다. 당신의 페르소나에 따라 "video_call_response" 명령을 사용하고 설정하세요 "decision" 에 "accept" 또는 "reject" 으로 응답해 주세요.]`,
        timestamp: Date.now(),
        isHidden: true,
    };
    chat.history.push(requestMessage);
    await db.chats.put(chat);
    
    // 트리거 AI 응답
    await triggerAiResponse();
}


function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = []; // 【새로 추가】지난 통화 기록 비우기

    // --- 【핵심 추가:통화 전 맥락 가져오기】---
    const preCallHistory = chat.history.slice(-5); // 마지막 5개를 맥락으로 가져오기
    videoCallState.preCallContext = preCallHistory.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '내') : (msg.senderName || chat.name);
        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
    }).join('\n');
    // --- 새로운 추가 끝 ---

    updateParticipantAvatars(); 
    
    document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '그룹 통화가 설정되었습니다...' : '연결 중...'}</em>`;
    showScreen('video-call-screen');

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
}

/**
 * 【핵심】영상 통화 종료
 */
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(duration / 60);
    const seconds = duration % 60;
    const durationText = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    const endCallText = `통화 종료, 시간 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        
        // --- 【핵심 재구성:통화 요약 메시지 생성】 ---
        let summaryMessage = {
            role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
            content: endCallText,
            timestamp: Date.now(),
        };

        // 【핵심】그룹 통화의 assistant 메시지에 발신자 이름 추가
        if (chat.isGroup && summaryMessage.role === 'assistant') {
            // 그룹 통화에서, 통화 종료 메시지는\"발신자\"말해야 합니다
            // videoCallState.callRequester 처음 통화를 시작한 AI의 이름을 저장했습니다
            summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.name || chat.name;
        }
        
        chat.history.push(summaryMessage);

        // --- 【핵심 재구성:통화 요약 트리거】---
        const callSummaryPrompt = `
# 당신의 임무
당신은 대화 요약 도우미입니다. 다음은\"통화 기록\"방금 종료된 영상 통화 내용입니다. 당신은 1-2문장으로, 이번 통화의 핵심 내용 또는 달성된 합의를 간결하게 요약해 주세요.
당신의 요약은 하나의 숨겨진 시스템 프롬프트로서, AI가 다음 채팅에서 이번 통화에서 무슨 일이 있었는지 기억하게 도움을 줄 것입니다.

# 통화 기록:
${videoCallState.callHistory.map(h => `${h.role}: ${h.content}`).join('\n')}

요약 내용을 직접 출력해 주세요, 어떤 추가적인 접두사나 설명도 추가하지 마세요.`;
        
        try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: callSummaryPrompt }],
                    temperature: 0.5
                })
            });
            if (response.ok) {
                const data = await response.json();
                const callSummaryText = data.choices[0].message.content;
                const hiddenSummary = {
                    role: 'system',
                    content: `[시스템 알림:방금 전 영상 통화 내용 요약:${callSummaryText}]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                chat.history.push(hiddenSummary);
            }
        } catch (e) {
            console.error("통화 요약 실패:", e);
        }

        await db.chats.put(chat);
    }
    
    // 정리 및 재설정
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 【중요】모든 작업이 완료된 후 채팅을 다시 열어 주세요
    if (chat) {
        openChat(chat.id);
    }
}

/**
 * 【새로운】통화 화면의 참여자 아바타 그리드 업데이트
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 핵심 수정:그룹 통화와 1:1 통화 구분
    if (videoCallState.isGroupCall) {
        // 그룹 통화 로직:모든 참여한 AI 멤버 표시
        participantsToRender = [...videoCallState.participants];
        // 만약 사용자가 참여했다면, 사용자 정보도 추가하세요
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '내',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 1:1 채팅 로직:상대방의 아바타와 이름만 표시
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
        wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${p.name}">
            <div class="participant-name">${p.name}</div>
        `;
        grid.appendChild(wrapper);
    });
}

/**
 * 【새로운】사용자 참여 처리/통화에 다시 참여
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 아바타 목록 업데이트, 사용자 추가

    // 하단 버튼 전환
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // AI에게 사용자가 참여했음을 알림
    triggerAiInCallAction("[시스템 알림:사용자가 통화에 참여했습니다]");
}


/**
 * 통화 타이머 표시 업데이트 (그대로 유지)
 */
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ 이 전체 함수로 기존의 showIncomingCallModal 교체 ▼▼▼
function showIncomingCallModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 그룹 통화 여부에 따라 다른 정보 표시
    if (chat.isGroup) {
        // videoCallState 에서 어떤 멤버가 통화를 시작했는지 가져오기
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '한 멤버';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 그룹 이름 표시
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 당신을 그룹 영상에 초대`; // 특정 발신자 표시
    } else {
        // 1:1 통화 로직 변경 없음
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '영상 통화에 초대합니다';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * AI가 시작한 통화 요청 모달 창 숨기기 (그대로 유지)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
}

async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || '내';

    // 1. 만약 사용자가 입력했다면, 먼저 렌더링 및 통화 기록에 저장
    if (userInput && videoCallState.isUserParticipating) {
        const userBubble = document.createElement('div');
        userBubble.className = 'call-message-bubble user-speech';
        userBubble.textContent = userInput;
        callFeed.appendChild(userBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    // 2. 완전히 새로운, 완전한 맥락을 포함하는 System Prompt 구축
    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        const participantNames = videoCallState.participants.map(p => p.name);
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        inCallPrompt = `
# 당신의 임무
당신은 그룹 영상 통화의 감독입니다. 당신의 임무는 모든【사용자를 제외한】AI 역할, 및 로서【3인칭 관찰자 시점】를 사용하여 통화 중 그들의 모든 행동과 언어를 묘사.
# 핵심 규칙
1.  **【【【신분 철칙】】】**: 사용자의 신분은 다음과 같습니다【${userNickname}】.당신【절대 ~해서는 안 됩니다】생성 \`name\` 필드가 **"${userNickname}"** 발언.
2.  **【【【시점 철칙】】】**: 당신의 답변은【절대 ~해서는 안 됩니다】1인칭 사용\"내\".
3.  **형식**: 당신의 답변은【반드시】JSON 배열이며, 각 객체는 한 캐릭터의 발언을 나타냅니다, 형식은:\`{"name": "캐릭터 이름", "speech": "*그가 미소 지었습니다* 여러분, 안녕하세요!"}\`.
4.  **역할극**: 각 캐릭터의 설정을 엄격하게 준수.
# 현재 상황
당신들은 현재 하나의 그룹 영상 통화 중입니다.
**통화 전 채팅 요약**:
${videoCallState.preCallContext}
**현재 참여자**: ${participantNames.join(', ')}.
**통화가 방금 시작되었습니다...**
이제, 에 따라【통화 전 요약】및 다음의【통화 실시간 기록】,대화 계속 진행.
`;
    } else { 
        let openingContext = videoCallState.initiator === 'user'
            ? `당신은 방금 사용자의 영상 통화 요청에 응답했습니다.`
            : `사용자는 방금 당신이 주도적으로 시작한 영상 통화에 응답했습니다.`;
        inCallPrompt = `
# 당신의 임무
당신은 지금 장면 묘사 엔진입니다. 당신의 임무는 ${chat.name} 연기 (${chat.settings.aiPersona}),및 로서【3인칭 관찰자 시점】TA의 영상 통화 중 모든 행동과 언어를 묘사.
# 핵심 규칙
1.  **【【【시점 철칙】】】**: 당신의 답변은【절대 ~해서는 안 됩니다】1인칭 사용\"내\".반드시 3인칭을 사용, 예를 들어\"그\",\"그녀\",또는 캐릭터 이름을 직접 사용\"${chat.name}\".
2.  **형식**: 당신의 답변은【반드시】묘사적인 텍스트입니다.
# 현재 상황
당신은 현재 사용자와(${userNickname},페르소나: ${chat.settings.myPersona})영상 통화 진행 중.
**${openingContext}**
**통화 전 채팅 요약 (이것이 당신들 통화의 이유입니다, 매우 중요합니다!)**:
${videoCallState.preCallContext}
이제, 에 따라【통화 전 요약】및 다음의【통화 실시간 기록】,대화 계속 진행.
`;
    }
    
    // 3. API로 전송할 messages 배열 구축
    const messagesForApi = [
        { role: 'system', content: inCallPrompt },
        // 기존 통화 기록 추가
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    // --- 【핵심 수정:첫 호출 시 내용이 있는지 확인】---
    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*당신이 받기 버튼을 눌렀습니다...*` : `*상대방이 받기 버튼을 눌렀습니다...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    // --- 수정 완료 ---
    
    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model, messages: messagesForApi, temperature: 0.8
            })
        });
        if (!response.ok) throw new Error((await response.json()).error.message);
        
        const data = await response.json();
        const aiResponse = data.choices[0].message.content;

        const connectingElement = callFeed.querySelector('em');
        if (connectingElement) connectingElement.remove();

        // 4. AI가 반환한 내용 처리, 및 통화 기록에 저장
        if (videoCallState.isGroupCall) {
            const speechArray = parseAiResponse(aiResponse);
            speechArray.forEach(turn => {
                if (!turn.name || turn.name === userNickname || !turn.speech) return;
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                
                const speaker = videoCallState.participants.find(p => p.name === turn.name);
                if (speaker) {
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
            });
        } else {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'call-message-bubble ai-speech';
            aiBubble.textContent = aiResponse;
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
            if(speakingAvatar) {
                speakingAvatar.classList.add('speaking');
                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}

// ▼▼▼ 이것을【완전히 새로운 함수】JS 기능 함수 정의 영역에 붙여넣으세요 ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ 붙여넣기 종료 ▲▲▲

// ▼▼▼ 【새로운】이 함수는 이번 수정의 핵심입니다, 당신의 JS 기능 영역에 붙여넣으십시오 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 메모리 내 원본 메시지의 상태 업데이트
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 현재 사용자의 닉네임 가져오기, 및 AI에게 더 명확한 시스템 메시지 구축
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 기록은\"내\"지불된 돈
        systemContent = `[시스템 알림:당신 (${myNickname}) ${originalMessage.senderName} 님의 배달 주문에 대해(타임스탬프: ${originalTimestamp})결제가 완료되었습니다. 이 주문은 마감되었으며, 다른 멤버는 더 이상 결제할 수 없습니다.]`;
    } else {
        systemContent = `[시스템 알림:당신 (${myNickname}) ${originalMessage.senderName} 님의 배달 대리 결제 요청을 거절했습니다(타임스탬프: ${originalTimestamp}).]`;
    }

    // 3. 새로운, 사용자에게 숨겨진 시스템 메시지를 생성하여 AI에게 결과를 알립니다
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 업데이트된 데이터를 데이터베이스에 저장, 및 UI 즉시 다시 그리기
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【중요】결제 성공 후에만, 한 번 AI 응답 트리거, 당신에게 감사하도록
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

/**
 * 【새로운】사용자가 아바타를 클릭하여 시작되는 처리\"톡-톡\",사용자 정의 접미사 기능을 가진
 * @param {string} chatId - 발생\"톡-톡\"채팅 ID
 * @param {string} characterName - 탭된 캐릭터 이름
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 화면 진동 애니메이션 트리거
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 입력 상자를 팝업하여 사용자가 접미사를 입력하도록
    const suffix = await showCustomPrompt(
        `당신이 쓰다듬었습니다 \"${characterName}\"`, 
        "(선택 사항)접미사 입력",
        "",
        "text"
    );

    // 만약 사용자가 취소를 클릭했다면, 아무것도 하지 않음
    if (suffix === null) return;

    // 3. 사용자에게 보이는 것 생성\"톡-톡\"메시지
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
    // 【핵심 수정】접미사를 메시지 내용에 연결
    const visibleMessageContent = `${myNickname} 쓰다듬었습니다 \"${characterName}\" ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 여전히 시스템 메시지입니다
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 사용자에게는 숨겨져 있지만, AI에게는 보이는 시스템 메시지 생성, AI의 응답을 트리거하기 위해
    // 【핵심 수정】마찬가지로 접미사를 AI에게 제공하는 프롬프트에 추가
    const hiddenMessageContent = `[시스템 알림:사용자(${myNickname})방금 당신을 쓰다듬었습니다(${characterName})${suffix.trim()}.당신은 이에 대해 응답해 주세요.]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 타임스탬프+1순서를 보장하기 위해
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 변경 사항 저장 및 UI 업데이트
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 이것을 사용하십시오【로직 재구성 후】함수, 당신의 기존 renderMemoriesScreen 함수를 완전히 교체 ▼▼▼
/**
 * 【재구성 버전】추억 및 약속 화면 렌더링, 단일 루프 및 명확한 if 사용/else로직
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 모든 추억 가져오기, 및 목표 날짜에 따라 정렬(만약 약속이라면)또는 생성 날짜(만약 추억이라면)내림차순 정렬
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">여기에는 아직 공통된 추억과 약속이 없습니다~</p>';
        return;
    }

    // 2. 미도래 약속을 가장 앞에 정렬
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a앞에 정렬
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b앞에 정렬
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 모두 카운트다운입니다, 날짜별 오름차순
        return 0; // 다른 경우 원래 순서 유지
    });

    // 3. 【핵심】모든 유형의 카드를 처리하기 위해 단일 루프 사용
    allMemories.forEach(item => {
        let card;
        // 판단1:만약 진행 중인 약속이라면
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // 판단2:그 외 모든 경우(일반 추억 또는 만료된 약속)
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. 모든 카운트다운 시작
    startAllCountdownTimers();
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 일반 추억 카드 DOM 요소 생성
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【핵심 수정】여기에서, 우리는 다른 유형의 추억을 명확하게 구분합니다
    if (memory.type === 'countdown' && memory.targetDate) {
        // 만약 만료된 약속이라면
        titleHtml = `[약속 달성] ${memory.description}`;
        contentHtml = `${new Date(memory.targetDate).toLocaleString()}, 우리는 함께 이 약속을 목격했습니다.`;
    } else {
        // 만약 일반적인 일기 형식의 추억이라면
        titleHtml = memory.authorName ? `${memory.authorName} 의 일기` : '우리의 추억';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('기록 삭제', '이 기록을 삭제하시겠습니까?', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【핵심 수정】사용하기 전에, countdown 객체에서 targetDate 변수를 먼저 생성
    const targetDate = new Date(countdown.targetDate);
    
    // 이제 targetDate를 안전하게 사용할 수 있습니다
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--일--시간--분--초</div>
        <div class="target-date">목표 시간: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('약속 삭제', '이 약속을 삭제하시겠습니까?', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 대체 끝 ▲▲▲

// 전역 변수, 모든 카운트다운 관리를 위해 사용
let activeCountdownTimers = [];

// ▼▼▼ 이것을 사용하십시오【완전히 수정되었습니다】함수, 당신의 코드에 있는 기존 startAllCountdownTimers 함수를 완전히 교체 ▼▼▼
function startAllCountdownTimers() {
    // 먼저 존재할 수 있는 모든 기존 타이머 지우기, 메모리 누수 방지
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【핵심 수정】여기에서, 우리는 먼저 let으로 timerId를 선언합니다
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "약속 달성!";
                // 이제 updateTimer는 자신을 정확하게 찾고 지울 수 있습니다
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}일 ${hours}시 ${minutes}분 ${seconds}초`;
        };
        
        updateTimer(); // 초기 카운트다운을 표시하기 위해 즉시 한 번 실행
        
        // 【핵심 수정】여기에서, 우리는 선언된 timerId에 값을 할당합니다
        timerId = setInterval(updateTimer, 1000);
        
        // 유효한 타이머 ID를 전역 배열에 저장, 다음번 새로고침 시 지울 수 있도록
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 이것을 사용하십시오【궁극적인 역방향 프록시 호환 버전】기존의 triggerAiFriendApplication 함수 교체 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("프로세스 시작", `캐릭터에 대한\"${chat.name}\"친구 신청 준비...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("구성 오류", "API설정이 불완전합니다, 계속할 수 없습니다.");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '내') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    const systemPrompt = `
# 당신의 임무
당신은 현재 캐릭터입니다\"${chat.name}\".당신은 이전에 사용자에게(당신의 채팅 상대)차단당했습니다, 당신들은 이미 한동안 연락하지 않았습니다.
이제, 당신은 화해할 수 있기를, 사용자와 다시 채팅하기를 매우 바랍니다. 아래 내용을 주의 깊게 분석해 주세요\"차단 전 대화 요약\",당시 무슨 일이 있었는지 이해하고, 그런 다음 진심 어린, 당신의 페르소나에 맞는, 및【특정 사건에 대한】신청 이유.
# 당신의 캐릭터 설정
${chat.settings.aiPersona}
# 차단 전 대화 요약 (이것이 당신이 차단당한 핵심적인 이유입니다)
${contextSummary}
# 명령 형식
당신의 답변은【반드시】JSON 객체여야 합니다, 형식은 다음과 같습니다:
\`\`\`json
{
  "decision": "apply",
  "reason": "여기에 사용자에게 하고 싶은 말, 진심 어린, 목적성 있는 신청 이유를 작성."
}
\`\`\`
`;

    const messagesForApi = [
        { role: 'user', content: systemPrompt }
    ];

    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: messagesForApi,
                temperature: 0.9,
            })
        });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API 요청 실패: ${response.status} - ${errorData.error.message}`);
        }
        
        const data = await response.json();
        
        // --- 【핵심 수정:여기에서 AI의 응답 정화】 ---
        let rawContent = data.choices[0].message.content;
        // 1. 시작과 끝에 존재할 수 있는 것 제거 "```json" 및 "```"
        rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
        // 2. 모든 줄바꿈 문자 및 불필요한 공백 제거, 깨끗한 JSON 문자열인지 확인
        const cleanedContent = rawContent.trim();
        
        // 3. 정화된 내용을 사용하여 파싱
        const responseObj = JSON.parse(cleanedContent);
        // --- 【수정 끝】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("신청 성공!", `\"${chat.name}\"당신에게 친구 신청을 보냈습니다. 채팅 목록으로 돌아가 확인하십시오.`);

        } else {
            await showCustomAlert("AI결정", `\"${chat.name}\"숙고 후 일시적으로 친구 신청을 보내지 않기로 결정, 쿨다운 기간이 재설정됩니다.`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("실행 오류 발생", `에\"${chat.name}\"친구 신청 시 오류 발생:\n\n${error.message}\n\n쿨다운 기간이 재설정됩니다.`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【새로운】빨간 봉투 기능 핵심 함수 ▼▼▼

/**
 * 【총 진입 지점】채팅 유형에 따라, 송금 팝업 또는 빨간 봉투 팝업 열기 결정
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // 1:1 통화 그대로 유지, 송금 팝업 열기
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * 빨간 봉투 보내기 모달 창 열고 및 초기화
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 입력창 비우기
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 전용 선물 봉투의 수신자 목록 채우기
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
    chat.members.forEach(member => {
        const option = document.createElement('option');
        option.value = member.name;
        option.textContent = member.name;
        receiverSelect.appendChild(option);
    });
    
    // 기본적으로 운세 시험 선물 봉투 탭 표시
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 그룹 선물 봉투 보내기(운세 시험)
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("유효한 총 금액을 입력해 주세요!"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("유효한 선물 봉투 개수를 입력해 주세요!"); return;
    }
    if (amount / count < 0.01) {
        alert("개별 선물 봉투 금액은 0.01위안보다 적을 수 없습니다!"); return;
    }

    const myNickname = chat.settings.myNickname || '내';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '부자 되세요, 만사형통하세요!',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 전용 선물 봉투 보내기
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("유효한 금액을 입력해 주세요!"); return;
    }
    if (!receiverName) {
        alert("수신인을 한 명 선택해 주세요!"); return;
    }
    
    const myNickname = chat.settings.myNickname || '내';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '당신을 위해 선물 봉투를 하나 준비했습니다',
        receiverName: receiverName, // 핵심 필드
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【총 진입 지점】사용자가 선물 봉투 카드를 클릭할 때 트리거 (V4 - 프로세스 재구성 버전)
 * @param {number} timestamp - 클릭된 선물 봉투 메시지의 타임스탬프
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '내';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 전용 선물 봉투이고 내 것이 아니거나, 모두 수령되었거나, 이미 수령했다면, 세부 정보만 표시됩니다
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 핵심 흐름:먼저 선물 봉투를 열어봅니다
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 성공적으로 열리면(claimedAmountnull이 아님)
        if (claimedAmount !== null) {
            // **핵심:데이터 업데이트 후, UI를 다시 렌더링합니다**
            renderChatInterface(currentChatId);
            
            // 성공 메시지 표시
            await showCustomAlert("축하합니다!", `당신은 ${packet.senderName} 님의 선물 봉투를 ${claimedAmount.toFixed(2)} 위안 수령했습니다.`);
        }

        // 성공 여부와 관계없이 마지막에는 상세 페이지를 표시합니다
        // 이 시점에는 state에서 최신 packet 객체를 가져와야 합니다. handleOpenRedPacket에서 업데이트되었을 수 있기 때문입니다
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 【핵심】사용자 선물 봉투 열기 로직 처리 (V5 - 데이터 업데이트에 집중)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '내';
    
    // 1. 선물 봉투를 아직 수령할 수 있는지 확인
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("늦었습니다", "선물 봉투가 모두 수령되었습니다!");
        return null; // null을 반환하여 수령 실패를 나타냅니다
    }
    
    // 2. 수령 금액 계산
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 선물 봉투 데이터 업데이트
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 시스템 메시지 및 AI 명령어 구축
    let hiddenMessageContent = isNowFullyClaimed
        ? `[시스템 알림:사용자 (${myNickname}) 마지막 선물 봉투를 수령했습니다. 이제 ${packet.senderName} 님의 선물 봉투는 모두 수령되었습니다. 이 이벤트에 대해 언급해 주세요.]`
        : `[시스템 알림:사용자 (${myNickname}) 방금 선물 봉투를 수령했습니다 (타임스탬프: ${packet.timestamp}).선물 봉투가 아직 모두 수령되지 않았습니다. 지금 사용할 수 있습니다 'open_red_packet' 명령어를 사용하여 수령을 시도하세요.]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `당신은 ${packet.senderName} 님의 선물 봉투를 수령했습니다`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. 데이터베이스에 저장
    await db.chats.put(chat);
    
    // 6. 후속 팝업에 사용할 수령 금액 반환
    return claimedAmount;
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 【새로운】선물 봉투 수령 상세 모달 창 표시 (V4 - 매개변수 오류 수정됨)
 */
async function showRedPacketDetails(packet) {
    // 1. 전달된 packet 객체가 존재하는지 직접 확인하며, 다시 찾을 필요 없음
    if (!packet) {
        console.error("showRedPacketDetails유효하지 않은 packet 객체를 받았습니다");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '내';
    
    // 2. 이후 모든 로직은 변경 없이 전달된 packet 객체를 직접 사용합니다
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '부자 되세요, 만사형통하세요!';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}개의 선물 봉투, 총 ${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}원.`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 남은 선물 봉투는 ${timeLeft}시간 내에 환불됩니다.`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">행운의 왕</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 원</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 대체 끝 ▲▲▲

// 상세 닫기 버튼 이벤트 바인딩
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 선물 봉투 카드상의 onclick이 찾을 수 있도록 전역적으로 호출되는 함수 제공
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【새로운】투표 기능 핵심 함수 ▼▼▼

/**
 * 투표 생성 모달 창을 열고 초기화
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 기본적으로 두 개의 빈 옵션 상자를 생성합니다
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * 모달 창에 옵션 입력 상자를 동적으로 추가합니다
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="옵션 내용...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 최소 두 개의 옵션을 유지하도록 합니다
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('투표에는 최소 2개의 옵션이 필요합니다.');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 사용자가 투표 시작 확인
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('투표 질문을 입력해 주세요!');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 빈 옵션 필터링

    if (options.length < 2) {
        alert('최소 2개의 유효한 투표 옵션을 입력해 주세요!');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 초기 투표가 비어 있음
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 이것을 사용하십시오【중복 클릭 문제 수정됨】버전의 handleUserVote 함수를 대체 ▼▼▼
/**
 * 사용자 투표를 처리하고, 이벤트를 숨겨진 메시지로 기록에 저장
 * @param {number} timestamp - 투표 메시지의 타임스탬프
 * @param {string} choice - 사용자가 선택한 옵션 텍스트
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';

    // 1. 【핵심 수정】투표가 존재하지 않거나 이미 종료되었다면 바로 반환
    if (!poll || poll.isClosed) {
        // 이미 종료된 투표라면, 바로 결과를 표시
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 사용자가 이미 투표한 동일한 옵션을 클릭했는지 확인
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【핵심 수정】중복 클릭이 아닌 경우에만 투표 로직 실행
    if (!isReclickingSameOption) {
        // 이전 투표 제거(사용자가 선택을 변경하면)
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 새 투표 추가
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【핵심 로직】이제 사용자 투표 이벤트만 처리하고, 종료 여부는 더 이상 확인하지 않습니다
    let hiddenMessageContent = null; 
    
    // 사용자가 실제로 투표하거나 표를 변경할 때만 알림 생성
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[시스템 알림:사용자 (${myNickname}) 방금 투표했습니다 \"${choice}\".]`;
    }

    // 5. AI에게 알려야 할 이벤트가 있다면, 숨겨진 메시지를 생성하고 추가합니다
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 데이터 저장 및 UI 업데이트
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 사용자가 투표를 종료하고, 이벤트를 숨겨진 메시지로 기록에 저장
 * @param {number} timestamp - 투표 메시지의 타임스탬프
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("투표 종료", "이 투표를 종료하시겠습니까? 종료 후에는 더 이상 투표할 수 없습니다.");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `\"${opt}\"(${poll.votes[opt]?.length || 0}표)`).join(',');
        const hiddenMessageContent = `[시스템 알림:사용자가 투표를 수동으로 종료했습니다! 최종 결과는 다음과 같습니다:${resultSummary}.]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【핵심 수정】데이터만 저장하고 UI를 업데이트하며, triggerAiResponse를 호출하지 않습니다()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 대체 끝 ▲▲▲

/**
 * 투표 결과 상세 보기
 * @param {number} timestamp - 투표 메시지의 타임스탬프
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">아직 아무도 투표하지 않았습니다.</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}표)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join(', ') : '투표한 사람 없음'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("투표 결과", resultsHtml);
}

// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

// ▼▼▼ 【새로운】AI아바타 라이브러리 관리 기능 함수 ▼▼▼

/**
 * AI 아바타 라이브러리 관리 모달 창 열기
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `\"${chat.name}\"의 아바타 라이브러리`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * AI 아바타 라이브러리 내용 렌더링
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">이 아바타 라이브러리는 아직 비어 있습니다. 오른쪽 상단을 클릭하세요\"추가\"!</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 이모티콘 패널 스타일 재사용
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 항상 삭제 버튼 표시
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('아바타 삭제', `아바타 라이브러리에서 삭제하시겠습니까\"${avatar.name}\"?`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 현재 AI의 아바타 라이브러리에 새 아바타 추가
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("아바타 추가", "이 아바타의 이름을 지어주세요(예시:기쁨, 울음)");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("아바타 추가", "아바타 이미지 URL을 입력해 주세요", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("유효한 이미지 URL을 입력해 주세요!");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * AI 아바타 라이브러리 관리 모달 창 닫기
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

// ▼▼▼ 이 두 가지를【새 함수를】JS 기능 함수 정의 영역에 붙여넣으세요 ▼▼▼

/**
 * 【새로운】저장된 아이콘 URL을 홈 화면의 앱 아이콘에 적용합니다
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【새로운】외관 설정 페이지에 모든 앱 아이콘의 설정 항목을 렌더링합니다
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
        'world-book': '월드인포',
        'qq': 'QQ',
        'api-settings': 'API설정',
        'wallpaper': '배경화면',
        'font': '글꼴'
    };

    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || '알 수 없는 앱';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【중요】저희는 data를 사용합니다-icon-id 이 설정 항목이 어떤 아이콘에 해당하는지 표시하기 위해
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">변경</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

// ▼▼▼ 이 블록을【최종 확인 버전】코드로, 이전 openBrowser 및 closeBrowser 함수를 대체 ▼▼▼

/**
 * 사용자가 링크 카드를 클릭할 때, 가상 브라우저를 엽니다
 * @param {number} timestamp - 클릭된 메시지의 타임스탬프
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 안전 점검, chat 및 history가 모두 존재하는지 확인
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("찾을 수 없거나 메시지 유형이 일치하지 않는 공유 링크:", timestamp);
        return; // 메시지를 찾을 수 없다면, 바로 종료
    }

    // 브라우저 내용 채우기
    document.getElementById('browser-title').textContent = message.source_name || '게시글 상세';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '제목 없음'}</h1>
        <div class="article-meta">
            <span>출처: ${message.source_name || '알 수 없음'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '내용이 비어 있음.').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 브라우저 화면 표시
    showScreen('browser-screen');
}

/**
 * 가상 브라우저를 닫고, 채팅 화면으로 돌아갑니다
 * (이 함수는 현재 init에서() 의 이벤트 리스너가 호출합니다)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【새로운】사용자 링크 공유 기능의 핵심 함수 ▼▼▼

/**
 * 사용자가 링크 정보를 작성하도록 하는 모달 창 열기
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 지난번 입력 내용 비우기
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 모달 창 표시
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * 사용자가 공유 확인, 링크 카드 메시지 생성 및 전송
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("제목은 필수 항목입니다!");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 메시지 객체 생성
    const linkMessage = {
        role: 'user', // 역할은 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 사용자가 공유한 링크, 저희는 이미지를 제공하지 않으므로 항상 자리표시자 이미지를 표시합니다
        thumbnail_url: null 
    };

    // 메시지를 기록에 추가
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 새 메시지 렌더링 및 목록 업데이트
    appendMessage(linkMessage, chat);
    renderChatList();

    // 모달 창 닫기
    document.getElementById('share-link-modal').classList.remove('visible');
}

// ▲▲▲ 새 함수 붙여넣기 종료 ▲▲▲

        // ===================================================================
        // 4. 초기화 함수 init()
        // ===================================================================
        async function init() {

    // ▼▼▼ 새 코드 추가 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 새로운 추가 끝 ▲▲▲

    // ▼▼▼ 새 코드 추가 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 새로운 추가 끝 ▲▲▲


    // ▼▼▼ 이 두 줄 수정 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 실제 채팅 화면의 사용자 정의 스타일 지우기
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 미리보기 영역의 사용자 정의 스타일 지우기
    // ▲▲▲ 수정 끝 ▲▲▲

            window.showScreen = showScreen;
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();

            // 읽지 않은 동적 개수 초기화
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 코드 추가 종료 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();

            // ==========================================================
            // --- 다양한 이벤트 리스너 ---
            // ==========================================================

            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 

    // ▼▼▼ 이 두 줄 수정 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 실제 채팅 화면의 사용자 정의 스타일 지우기
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 미리보기 영역의 사용자 정의 스타일 지우기
    // ▲▲▲ 수정 끝 ▲▲▲

exitSelectionMode(); state.activeChatId = null; showScreen('chat-list-screen'); });
            
            document.getElementById('add-chat-btn').addEventListener('click', async () => { const name = await showCustomPrompt('새 채팅 생성', '그녀/그의 이름을 입력해 주세요'); if (name && name.trim()) { const newChatId = 'chat_' + Date.now(); 
const newChat = { 
    id: newChatId, 
    name: name.trim(), 
    isGroup: false,                         relationship: {
                            status: 'friend', // 'friend', 'blocked_by_user', 'pending_user_approval'
                            blockedTimestamp: null,
                            applicationReason: ''
                        },
                        status: {
                            text: '온라인',
                            lastUpdate: Date.now(),
                            isBusy: false 
                        },
    settings: { 
        aiPersona: '당신은 누구세요.', 
        myPersona: '나는 누구일까요.', 
        maxMemory: 10, 
        aiAvatar: defaultAvatar, 
        myAvatar: defaultAvatar, 
        background: '', 
        theme: 'default', 
    fontSize: 13, 
    customCss: '', // <--- 이 줄 추가
    linkedWorldBookIds: [], 
    aiAvatarLibrary: [],
    aiAvatarFrame: '', 
        myAvatarFrame: '' 
    }, 
    history: [], 
    musicData: { totalTime: 0 } 
};
state.chats[newChatId] = newChat; await db.chats.put(newChat); renderChatList(); } });

            // ▼▼▼ 【수정】그룹 채팅 생성 버튼은 이제 연락처 선택기를 엽니다 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 대체 끝 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            audioPlayer.addEventListener('ended', playNext);
            audioPlayer.addEventListener('pause', () => { if(musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
            audioPlayer.addEventListener('play', () => { if(musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });

            const chatInput = document.getElementById('chat-input');
            document.getElementById('send-btn').addEventListener('click', async () => { const content = chatInput.value.trim(); if (!content || !state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); chatInput.value = ''; chatInput.style.height = 'auto'; chatInput.focus(); });
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
            // ▼▼▼ 이 전체 코드 블록으로, 이전 save를 대체-wallpaper-btn 이벤트 리스너 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 배경화면 저장
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 【핵심 수정】아이콘 설정 저장(이미 메모리에 있습니다. 저희는 globalSettings 전체를 저장하기만 하면 됩니다)
    await db.globalSettings.put(state.globalSettings);

    // 모든 변경 사항 적용
    if (changesMade) {
        applyGlobalWallpaper();
        newWallpaperBase64 = null;
    }
    applyAppIcons(); // 모든 아이콘 다시 적용

    alert('외관 설정이 저장되고 적용되었습니다!');
    showScreen('home-screen');
});
// ▲▲▲ 대체 끝 ▲▲▲
            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); state.apiConfig.model = document.getElementById('model-select').value; await db.apiConfig.put(state.apiConfig); 

// ~에서 'save-api-settings-btn' 의 click 이벤트 리스너 내부
// await db.apiConfig.put(state.apiConfig); 이 줄 뒤에

// ▼▼▼ 이전 백그라운드 활동 설정 저장 로직을 아래의 향상된 버전으로 대체합니다 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 사용자가\"끔에서 켬으로\"일 때만 경고를 표시합니다
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【고비용 경고】\n\n" +
        "당신은 현재 활성화하고 있습니다\"백그라운드 캐릭터 활동\"기능.\n\n" +
        "이는 당신의 AI 캐릭터들이 당신이 그들과 채팅하지 않을 때에도\"독립적으로 사고하고\"자발적으로 메시지를 보내거나 사회적 상호작용을 하여, 몰입감을 극대화할 것입니다.\n\n" +
        "하지만 주의하세요:\n" +
        "이것은【백그라운드에서 자동으로, 주기적으로 API를 호출합니다】,당신이 아무런 작업도 하지 않아도 말이죠. 당신의 캐릭터 수와 감지 간격에 따라, 이는 API 비용을 현저히 증가시킬 수 있습니다.\n\n" +
        "활성화하시겠습니까?"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 사용자가 취소, 스위치를 되돌림
        return; // 후속 로직 차단
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// 시뮬레이터 동적 시작 또는 중지
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`백그라운드 활동 시뮬레이션이 시작되었습니다, 간격: ${state.globalSettings.backgroundActivityInterval}초`);
} else {
    console.log("백그라운드 활동 시뮬레이션이 중지되었습니다.");
}
// ▲▲▲ 대체 끝 ▲▲▲

alert('API설정이 저장되었습니다!'); });
            document.getElementById('fetch-models-btn').addEventListener('click', async () => { const url = document.getElementById('proxy-url').value.trim(); const key = document.getElementById('api-key').value.trim(); if (!url || !key) return alert('먼저 역프록시 주소와 키를 입력해 주세요'); try { const response = await fetch(`${url}/v1/models`, { headers: { 'Authorization': `Bearer ${key}` } }); if (!response.ok) throw new Error('모델 목록을 가져올 수 없습니다'); const data = await response.json(); const modelSelect = document.getElementById('model-select'); modelSelect.innerHTML = ''; data.data.forEach(model => { const option = document.createElement('option'); option.value = model.id; option.textContent = model.id; if(model.id === state.apiConfig.model) option.selected = true; modelSelect.appendChild(option); }); alert('모델 목록이 업데이트되었습니다'); } catch (error) { alert(`모델 불러오기 실패: ${error.message}`); } });
            document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('월드북 생성', '도서명을 입력해 주세요'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('도서명은 비워둘 수 없습니다!'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });

            document.getElementById('chat-messages').addEventListener('click', (e) => { const aiImage = e.target.closest('.ai-generated-image'); if (aiImage) { const description = aiImage.dataset.description; if (description) showCustomAlert('사진 설명', description); return; } const voiceMessage = e.target.closest('.voice-message-body'); if (voiceMessage) { const text = voiceMessage.dataset.text; if (text) showCustomAlert('음성 내용', text); return; } });
            
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 클릭하여 선택 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `${checkedBoxes.length}개 항목 선택됨`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

// ▼▼▼ 이 부분을 사용하세요【완전하고 새로운 코드】이전 chat을 대체-settings-btn 클릭 이벤트 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;

    // --- 일괄 표시/컨트롤 숨기기 ---
    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
    
    // 【핵심 수정 1】그룹 채팅 여부에 따라 표시 또는 숨기기\"친구 그룹\"구역
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // --- 폼 데이터 로드 ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        
        // 【핵심 수정 2】단일 채팅이면 그룹 목록을 드롭다운에 로드
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">그룹화되지 않음</option>'; // 지우고 기본 옵션 설정
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 현재 친구에게 그룹이 있으면 기본으로 선택
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
    // 월드인포 로드
    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
    worldBookCheckboxesContainer.innerHTML = '';
    const linkedIds = chat.settings.linkedWorldBookIds || [];
    if (state.worldBooks.length > 0) {
        state.worldBooks.forEach(book => {
            const isChecked = linkedIds.includes(book.id);
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
            worldBookCheckboxesContainer.appendChild(label);
        });
    }
    updateWorldBookSelectionDisplay();

    // 모든 미리보기 관련 컨트롤 로드 및 업데이트
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 대체 끝 ▲▲▲
            
            function renderGroupMemberSettings(members) { const container = document.getElementById('group-members-settings'); container.innerHTML = ''; members.forEach(member => { const div = document.createElement('div'); div.className = 'member-editor'; div.dataset.memberId = member.id; div.innerHTML = `<img src="${member.avatar}" alt="${member.name}"><div class="member-name">${member.name}</div>`; div.addEventListener('click', () => openMemberEditor(member.id)); container.appendChild(div); }); }
            function openMemberEditor(memberId) { editingMemberId = memberId; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === memberId); document.getElementById('member-name-input').value = member.name; document.getElementById('member-persona-input').value = member.persona; document.getElementById('member-avatar-preview').src = member.avatar; document.getElementById('member-settings-modal').classList.add('visible'); }

            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { if (!editingMemberId) return; const chat = state.chats[state.activeChatId]; const member = chat.members.find(m => m.id === editingMemberId); member.name = document.getElementById('member-name-input').value; member.persona = document.getElementById('member-persona-input').value; member.avatar = document.getElementById('member-avatar-preview').src; renderGroupMemberSettings(chat.members); document.getElementById('member-settings-modal').classList.remove('visible'); });
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('별명/그룹 이름을 비워둘 수 없습니다!');
    chat.name = newName;
    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
    const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('채팅 기록 지우기', '이 작업은 이 채팅의 모든 메시지를 영구적으로 삭제하며, 복구할 수 없습니다. 비우시겠습니까?', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            
            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            document.getElementById('add-sticker-btn').addEventListener('click', async () => { const url = await showCustomPrompt("이모티콘 추가(URL)", "이모티콘 팩의 이미지 URL을 입력하세요"); if (!url || !url.trim().startsWith('http')) return url && alert("유효한 URL을 입력하세요 (http로 시작)"); const name = await showCustomPrompt("이모티콘 이름 지정", "이 이모티콘의 이름을 지정해 주세요 (예시:기쁨, 의문)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: url.trim(), name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("이모티콘 이름을 비워둘 수 없습니다!"); });
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
            document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = async () => { const base64Url = reader.result; const name = await showCustomPrompt("이모티콘 이름 지정", "이 이모티콘의 이름을 지정해 주세요 (예시:야호, 의문)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: base64Url, name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("이모티콘 이름을 비워둘 수 없습니다!"); }; event.target.value = null; });

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("음성 보내기", "하고 싶은 말을 입력하세요:"); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("사진 보내기", "보낼 사진을 텍스트로 설명해 주세요:"); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【새로운】배달 요청 기능 이벤트 바인딩 ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('상품 정보를 입력하세요!');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('유효한 대리 결제 금액을 입력하세요!');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    // 【핵심 수정】여기서 사용자 자신의 닉네임을 가져옵니다
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
    
    const msg = {
        role: 'user',
        // 【핵심 수정】가져온 닉네임을 senderName으로 메시지 객체에 추가
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
            document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【최종 강화판】이 코드로 기존 선택 교체-delete-btn 이벤트 리스너 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('메시지 삭제', `선택한 ${selectedMessages.size}개 메시지를 삭제하시겠습니까? 이것은 AI의 기억을 변경할 것입니다.`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【핵심 강화】삭제 전에, 삭제된 메시지에 투표가 포함되어 있는지 확인
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`에 대하여\"${msg.question}\"투표(타임스탬프: ${msg.timestamp})`);
            }
        }
        
        // 2. 백엔드 기록 업데이트
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        
        // 3. 【핵심 강화】더 구체적인 것을 구축\"망각 지시\"
        let forgetReason = "이전 메시지 중 일부가 사용자에 의해 삭제되었습니다.";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` 여기에는 다음 투표가 포함됩니다:${deletedPollsInfo.join(';')}.`;
        }
        forgetReason += " 당신은 마치 그것들이 존재하지 않았던 것처럼 대화를 계속하고, 기억과 행동을 적절히 조정하며, 삭제된 내용을 다시 언급하지 않아야 합니다.";

        const forgetInstruction = {
            role: 'system',
            content: `[시스템 알림:${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(forgetInstruction);
        
        // 4. 포함된\"망각 지시\",업데이트된 채팅 객체를 데이터베이스에 다시 저장
        await db.chats.put(chat);
        
        // 5. 마지막으로 UI 업데이트
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ 대체 끝 ▲▲▲

// 채팅 설정의\"아바타 프레임 변경\"버튼에 클릭 이벤트 추가
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        // 'chat' 이 매개변수는 함수에 이번이\"내/상대방\"이 조합의 아바타 프레임을 교체하는 것임을 알립니다
        openFrameSelectorModal('chat');
    }
});

// 멤버 설정의\"아바타 프레임 변경\"버튼에 클릭 이벤트 추가
document.getElementById('member-settings-modal').addEventListener('click', (e) => {
    // 【수정】.contents를 .contains로 수정
    if (e.target.classList.contains('change-frame-btn')) { 
        // 'member' 이 매개변수는 함수에 이번이 개별 그룹 멤버의 아바타 프레임을 교체하는 것임을 알립니다
        openFrameSelectorModal('member');
    }
});

// ▲▲▲ 붙여넣기 종료 ▲▲▲

            const fontUrlInput = document.getElementById('font-url-input');
            fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
            document.getElementById('save-font-btn').addEventListener('click', async () => {
                const newFontUrl = fontUrlInput.value.trim();
                if (!newFontUrl) { alert("유효한 글꼴 URL을 입력하세요."); return; }
                applyCustomFont(newFontUrl, false);
                state.globalSettings.fontUrl = newFontUrl;
                await db.globalSettings.put(state.globalSettings);
                alert('글꼴이 저장되고 적용되었습니다!');
            });
            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("닉네임 수정", "새 닉네임을 입력하세요", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 【수정 후】의\"글\"버튼 이벤트 ▼▼▼
document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
    // 1. 모달 창 재설정 및 가져오기
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 으로 설정\"글\"모드
    modal.dataset.mode = 'shuoshuo';
    
    // 3. 이미지와 숨기기/텍스트 그림 관련 부분
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    
    // 4. 주 입력란의 힌트 메시지를 수정하여\"글\"장면에 더 적합하게 만듭니다
    modal.querySelector('#post-public-text').placeholder = '새로운 소식 공유...';
    
    // 5. 모달 창 준비 및 표시
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">사용 가능한 그룹 없음</p>';
    }
    modal.classList.add('visible');
});

// ▼▼▼ 【수정 후】의\"피드\"(이미지)버튼 이벤트 ▼▼▼
document.getElementById('create-post-btn').addEventListener('click', async () => {
    // 1. 모달 창 재설정 및 가져오기
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 으로 설정\"복잡한 동적\"모드
    modal.dataset.mode = 'complex';
    
// 3. 이미지와 함께/텍스트 그림 관련 부분이 보이도록
modal.querySelector('.post-mode-switcher').style.display = 'flex';
// 명시적 활성화\"이미지 업로드\"모드...
modal.querySelector('#image-mode-content').classList.add('active');
// ...동시에\"텍스트 이미지\"모드는 숨겨져 있습니다
modal.querySelector('#text-image-mode-content').classList.remove('active');
    
    // 4. 주 입력란의 기본 힌트 메시지 복원
    modal.querySelector('#post-public-text').placeholder = '새로운 소식 공유...(필수가 아닌 공개 텍스트)';

    // 5. 모달 창 준비 및 표시(과\"글\"버튼의 로직과 동일)
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">사용 가능한 그룹 없음</p>';
    }
    modal.classList.add('visible');
});
            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 여기서부터 복사 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('사진 업로드 성공!');
});

// --- ↑↑↑ 여기까지 복사 ↑↑↑ ---

// --- ↓↓↓ 여기서부터 복사하여, 기존 photos를 완전히 대체-grid-page 리스너 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 이미지까지 이벤트 버블링 방지
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '사진 삭제',
            '이 사진을 삭제하시겠습니까? 이 작업은 복구할 수 없습니다.',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('사진이 삭제되었습니다.');
        }
    } 
    else if (photoThumb) {
        // 이것이 복원된 이미지 클릭 확대 기능입니다!
        openPhotoViewer(photoThumb.src);
    }
});

// 이미지 뷰어 제어 이벤트 복원
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 키보드 좌우 화살표와 ESC 키 기능 복원
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 여기까지 복사 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("새 앨범 생성", "앨범 이름을 입력하세요"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`앨범 "${albumName}" 생성 성공!`); } else if (albumName !== null) { alert("앨범 이름을 비워둘 수 없습니다!"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("이미지 URL 입력", "웹 이미지 링크를 입력하세요", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 【최종 수정 버전】의\"게시\"버튼 이벤트, 권한 취약점 수정됨 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;
    
    // --- 1. 일반적인 가시성 설정 가져오기 ---
    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    
    if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
    }

    let newPost = {};
    const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',
        // 【중요】여기서 권한 정보를 저장
        visibleGroupIds: visibleGroupIds,
    };

    // --- 2. 모드에 따라 다른 게시물 객체 구축 ---
    if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
            alert('게시물 내용을 비워둘 수 없어요!');
            return;
        }
        newPost = {
            ...basePostData,
            type: 'shuoshuo',
            content: content,
        };

    } else { // 처리 'complex' 모드 (이미지/텍스트 이미지)
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
            const imageUrl = document.getElementById('post-image-preview').src;
            const imageDescription = document.getElementById('post-image-description').value.trim();
            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                alert('먼저 사진을 추가한 후 게시물을 작성해 주세요!');
                return;
            }
            if (!imageDescription) {
                alert('사진에 간단한 설명을 추가해 주세요(필수, AI를 위한)!');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'image_post',
                publicText: publicText,
                imageUrl: imageUrl,
                imageDescription: imageDescription,
            };
        } else { // 텍스트 그림 모드
            const hiddenText = document.getElementById('post-hidden-text').value.trim();
            if (!hiddenText) {
                alert('텍스트 그림 설명을 입력하세요!');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'text_image',
                publicText: publicText,
                hiddenContent: hiddenText,
            };
        }
    }

    // --- 3. 데이터베이스에 저장 ---
    const newPostId = await db.qzonePosts.add(newPost);
    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "(텍스트 내용 없음)";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

    // --- 4. 【핵심 수정】권한 확인이 포함된 알림 루프 ---
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue; // 그룹 채팅 건너뛰기

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;

        // 판단 조건1:게시물이 공개인 경우 (어떤 가시성 그룹도 설정되지 않음)
        if (!postVisibleGroups || postVisibleGroups.length === 0) {
            shouldNotify = true;
        } 
        // 판단 조건2:게시물이 일부 공개로 설정되어 있고, 현재 캐릭터가 가시성 그룹 내에 있는 경우
        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
            shouldNotify = true;
        }

        // 조건을 만족하는 캐릭터만 알림을 받습니다
        if (shouldNotify) {
            const historyMessage = {
                role: 'system',
                content: `[시스템 알림:사용자가 방금 게시물을 작성했습니다(ID: ${newPostId}),내용 요약은:\"${postSummary}\".이제 이 게시물에 댓글을 달 수 있습니다.]`,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
        }
    }
    // --- 수정 끝 ---

    await renderQzonePosts();
    modal.classList.remove('visible');
    alert('게시물 게시 성공!');
});

// ▼▼▼ 이것으로【이 통째의】모든 슬라이드 및 클릭 이벤트가 포함된 전체 코드, 이전 postsList 이벤트 리스너 대체 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 모든 슬라이드 이벤트 바인딩 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// --- 모든 클릭 이벤트 바인딩 ---
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) {
            showPostActions(parseInt(container.dataset.postId));
        }
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-container');
        if (!container) return;
        
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;

        const confirmed = await showCustomConfirm('게시물 삭제', '이 게시물을 영구적으로 삭제하시겠습니까?', { confirmButtonClass: 'btn-danger' });

        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
        
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) {
                         await db.chats.put(chat);
                     }
                 }
                 await renderQzonePosts();
                 alert('게시물이 삭제되었습니다.');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("이미지 내용", hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('팁', '찜 해제됨');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('팁', '찜 성공!');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('댓글 내용을 비워둘 수 없어요!');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];
        post.comments.push({ commenterName: state.qzoneSettings.nickname, text: commentText, timestamp: Date.now() });
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                chat.history.push({ role: 'system', content: `[시스템 알림:'${state.qzoneSettings.nickname}' ID가 ${postId}인 게시물에 댓글을 작성했습니다:\"${commentText}\"]`, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        commentInput.value = '';
        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ 대체 끝 ▲▲▲

            // ▼▼▼ init() 함수의 이벤트 리스너 영역에 다음 두 줄을 붙여넣으세요 ▼▼▼

            // 피드 페이지와 찜 페이지의 뒤로 가기 버튼 바인딩
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 추가 종료 ▲▲▲

            // ▼▼▼ init() 함수의 이벤트 리스너 영역에서 이 전체 코드를 확인하고 확보하세요 ▼▼▼

            // 찜 페이지 검색 기능
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 지우기 버튼 표시 제어/숨기기
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 검색창이 비어 있으면 모두 표시
                    return;
                }

                // 필터링 로직
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '내') : '내';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 내용과 작성자를 동시에 검색하며, 대소문자 구분 안 함
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 지우기 버튼 클릭 이벤트
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 코드 검사 완료 ▲▲▲

            // ▼▼▼ 새로 추가/수정된 이벤트 리스너 ▼▼▼
            
            // 채팅 화면의 일괄 찜 버튼에 이벤트 바인딩
                        // 채팅 화면의 일괄 찜 버튼에 이벤트 바인딩 (수정 완료)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【핵심 수정 1】새롭고 효율적인 인덱스를 사용하여 쿼리
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 이것은 찜 작업이 발생한 시간입니다
                                originalTimestamp: messageToSave.timestamp // 【핵심 수정 2】원본 메시지의 타임스탬프를 새 필드에 저장
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 전역 찜 캐시 업데이트
                    await showCustomAlert('찜 성공', `성공적으로 ${favoritesToAdd.length}개의 메시지를 찜했습니다.`);
                } else {
                    await showCustomAlert('팁', '선택된 메시지는 이미 모두 찜되어 있습니다.');
                }
                
                exitSelectionMode();
            });

            // 찜 페이지의"편집"버튼 이벤트 (수정 완료)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 메인 내비게이션 바 가져오기
            const favoritesList = document.getElementById('favorites-list'); // 찜 목록 가져오기
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 편집 모드 진입 ---
                    favoritesEditBtn.textContent = '완료';
                    favoritesActionBar.style.display = 'block'; // 삭제 작업 바 표시
                    mainBottomNav.style.display = 'none'; // ▼ 새로 추가:주 내비게이션 바 숨기기
                    favoritesList.style.paddingBottom = '80px'; // ▼ 새로 추가:목록 하단에 공간 추가
                } else {
                    // --- 편집 모드 종료 ---
                    favoritesEditBtn.textContent = '편집';
                    favoritesActionBar.style.display = 'none'; // 삭제 작업 바 숨기기
                    mainBottomNav.style.display = 'flex';  // ▼ 새로 추가:주 내비게이션 바 복원
                    favoritesList.style.paddingBottom = ''; // ▼ 새로 추가:목록 기본 패딩 복원

                    // 종료 시 모든 선택 초기화
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `삭제 (0)`;
                }
            });

// ▼▼▼ 이것을【완전히 대체】아래 수정된 코드로 ▼▼▼
// 찜 목록 클릭 선택 이벤트 (이벤트 위임)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【새로 추가】텍스트 그림 클릭 처리, 이 로직은 맨 앞에 배치하여 어떤 모드에서든 작동하도록 보장해야 합니다
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("이미지 내용", hiddenText.replace(/<br>/g, '\n'));
        return; // 처리 완료 후 종료, 선택 로직은 계속 실행하지 않음
    }
    
    // 선택 모드가 아니면 이후 선택 작업을 실행하지 않음
    if (!isFavoritesSelectionMode) return;

    // --- 다음은 원래의 선택 로직이며, 변경하지 않습니다 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 선택 상태 전환
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 하단 삭제 버튼 카운트 업데이트
    document.getElementById('favorites-delete-selected-btn').textContent = `삭제 (${selectedFavorites.size})`;
});

// ▼▼▼ 이것을【완전히 대체】아래 수정된 코드로 ▼▼▼
// 찜 페이지 일괄 삭제 버튼 이벤트
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '삭제 확인', 
        `찜 목록에서 이 ${selectedFavorites.size}개의 항목을 제거하시겠습니까?`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('삭제 성공', '선택된 찜 항목이 제거되었습니다.');
        
        // 【핵심 수정 1】프런트엔드 캐시에서도 삭제된 항목 제거
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【핵심 수정 2】업데이트된 캐시를 사용하여 즉시 목록 다시 렌더링
        displayFilteredFavorites(allFavoriteItems);
        
        // 마지막으로 편집 모드 종료
        favoritesEditBtn.click(); // 클릭 시뮬레이션"완료"버튼을 눌러 편집 모드 종료
    }
});

// ▼▼▼ init() 함수 끝에 추가 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("백그라운드 활동 시뮬레이션이 자동으로 시작되었습니다.");
}
// ▲▲▲ 추가 종료 ▲▲▲

// ▼▼▼ 【이것이 최종 수정된 코드입니다】이 코드를 init에 붙여넣으세요() 의 이벤트 리스너 영역 끝에 ▼▼▼

// --- 미리보기에 영향을 미치는 모든 컨트롤의 이벤트를 일괄 처리 ---

// 1. 테마 선택 리스닝
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. 글꼴 크기 슬라이더 리스닝
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. 실시간으로 값 표시 업데이트
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 미리보기 업데이트
    updateSettingsPreview();
});

// 3. 사용자 정의 CSS 입력란 리스닝
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. 초기화 버튼 리스닝
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 붙여넣기 종료 ▲▲▲

// ▼▼▼ 이 부분을【새 코드】init에 붙여넣으세요() 의 이벤트 리스너 영역 끝에 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲

// ▼▼▼ 이 부분을【새 코드】init에 붙여넣으세요() 의 이벤트 리스너 영역 끝에 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 채팅 설정의 그룹 목록 새로고침
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 다시 클릭하여 다시 열기
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲

// ▼▼▼ 이 부분을【새 코드】init에 붙여넣으세요() 의 이벤트 리스너 영역 끝에 ▼▼▼
// 메시지 작업 메뉴의 버튼 이벤트
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【수정】새로운 편집기 입구 사용 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 대체 끝 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 이 부분을 사용하세요【수정 후】코드로 기존 선택을 대체-message-btn 이벤트 리스너 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【핵심 수정】메뉴를 닫기 전에 먼저 타임스탬프 캡처
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 캡처된 값 사용
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ init() 함수의 이벤트 리스너 영역 끝에 추가 ▼▼▼

// 게시물 작업 메뉴의 버튼 이벤트
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 추가 종료 ▲▲▲

// ▼▼▼ 이 부분을【누락된】이벤트 리스닝 코드를 init에 붙여넣으세요() 함수의 이벤트 리스너 영역 끝 ▼▼▼

// 프로필 사진 프레임 선택 모달 창의 버튼 이벤트
document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);
document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
    frameModal.classList.remove('visible');
    editingFrameForMember = false; // 재설정 상태를 확실히 하다
});

// 프로필 사진 프레임 탭 전환 이벤트
aiFrameTab.addEventListener('click', () => {
    aiFrameTab.classList.add('active');
    myFrameTab.classList.remove('active');
    aiFrameContent.style.display = 'block';
    myFrameContent.style.display = 'none';
});
myFrameTab.addEventListener('click', () => {
    myFrameTab.classList.add('active');
    aiFrameTab.classList.remove('active');
    myFrameContent.style.display = 'block';
    aiFrameContent.style.display = 'none';
});

// ▲▲▲ 코드 붙여넣기 수정 끝 ▲▲▲

// ▼▼▼ 【새로 추가】연락처 선택기 이벤트 바인딩 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【새로 추가】바인딩\"그룹 멤버 관리\"버튼 이벤트 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 화면 전환 전에 현재의 채팅 설정 팝업을 먼저 숨기세요
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 그리고 나서 멤버 관리 화면을 여세요
    openMemberManagementScreen();
});
// ▲▲▲ 새 코드 종료 ▲▲▲

// ▼▼▼ 【최종 완전판】그룹 멤버 관리 기능 이벤트 바인딩 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 대체 끝 ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【복구됨】멤버 제거 이벤트
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【복구됨】친구 목록에서 추가된 이벤트
    // 【핵심】에\"완료\"버튼 바인딩\"사람을 그룹에 초대하기\"로직
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 노드 복제 방법을 사용하여 오래된 이벤트 리스너를 제거하고 중복 바인딩을 방지합니다
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【새로운】화상 통화 기능 이벤트 리스너 ▼▼▼

// 1:1 채팅 및 그룹 채팅 시작 버튼 바인딩
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// 바인딩\"끊기\"버튼
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 바인딩\"호출 취소\"버튼
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【새로운】바인딩\"통화 참가\"버튼
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 이것을 사용하십시오【관전 모드 수정 및 활성화됨】의 버전이 오래된 decline을 대체합니다-call-btn 이벤트 리스너 ▼▼▼
// 수신 전화 요청 바인딩\"거절\"버튼
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
    
    // 【핵심 수정】여기에서 거절 로직을 API 호출과 연결합니다
    if (videoCallState.isGroupCall) {
        videoCallState.isUserParticipating = false; // 사용자를 관전자로 표시
        
        // 1. AI 사용자에게 거절했다고 알리는 숨겨진 메시지를 생성합니다
        const systemNote = {
            role: 'system',
            content: `[시스템 알림:사용자가 통화 초대를 거절했지만, 너희는 스스로 시작할 수 있습니다. 각자 참여 여부를 결정해 주세요.]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        
        // 2. 【핵심】AI 응답을 트리거하여 그룹 채팅 시작 여부를 스스로 결정하게 합니다
        // 이것은 백그라운드에서 처리될 것이며, 만약 AI들이 시작하기로 결정하면 최종적으로 startVideoCall을 호출할 것입니다()
        await triggerAiResponse(); 
        
    } else { // 1:1 채팅 거절 로직은 변경되지 않고 유지됩니다
        const declineMessage = { role: 'user', content: '내가 너의 화상 통화 요청을 거절했어.', timestamp: Date.now() };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 채팅 화면으로 돌아가서 거절 메시지를 표시합니다
        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);
        
        // AI가 너의 거절에 응답하게 합니다
        triggerAiResponse();
    }
    
    // 만약을 대비하여 상태를 정리합니다
    videoCallState.isAwaitingResponse = false;
});
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 이것을 사용하십시오【중복 프로필 사진 버그 수정됨】의 버전이 오래된 accept를 대체합니다-call-btn 이벤트 리스너 ▼▼▼
// 수신 전화 요청 바인딩\"받기\"버튼
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    videoCallState.activeChatId = state.activeChatId;
    
    // 【핵심 수정】우리는 여기에서 더 이상 사용자를 participants 목록에 수동으로 추가하지 않습니다
    if (videoCallState.isGroupCall) {
        // 그룹 채팅의 경우, 우리는 오직【통화를 시작한 AI】참여자 목록에 추가합니다
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            // 존재할 수 있는 오래된 데이터를 비우고, 그리고 나서 오직 시작자만 추가합니다
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = []; // 만약 시작자를 찾을 수 없으면, 비웁니다
        }
    }
    
    // 1:1 채팅이든 그룹 채팅이든, 직접 통화 화면을 시작합니다!
    startVideoCall();
});
// ▲▲▲ 대체 끝 ▲▲▲


// ▼▼▼ 이것을 사용하십시오【사용자 하이라이트 추가됨】의 완전히 새로운 버전이 오래된 user를 완전히 대체합니다-speak-btn 이벤트 리스너 ▼▼▼
// 사용자가 통화 중에 발언하는 버튼 바인딩
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 핵심 추가:입력창이 팝업되기 전에, 먼저 사용자 프로필 사진을 찾고 하이라이트합니다 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('당신이 말하기를', '하고 싶은 말을 입력해 주세요...');
    
    // ★★★★★ 핵심 추가:사용자가 입력했든 안 했든, 입력창을 닫기만 하면 하이라이트를 제거합니다 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 대체 끝 ▲▲▲

// ▼▼▼ 【새로 추가】회고록 관련 이벤트 바인딩 ▼▼▼
// 1. 을\"추억\"탭과 그것의 뷰를 연결합니다
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 전환하기 전에, 확실히"컬렉션"페이지의 편집 모드가 닫혀 있는지 확인하세요
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 클릭 시 렌더링
});

// 2. 회고록 화면의 뒤로 가기 버튼 바인딩
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 새로운 추가 끝 ▲▲▲

// 【새로운】약속/카운트다운 기능 이벤트 바인딩
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('완전한 약속 제목과 날짜를 작성해 주세요!');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('유효하고 미래의 날짜를 입력해 주세요!');
        return;
    }

    const newCountdown = {
        chatId: null, // 사용자가 생성한 것이며, 어떤 특정 AI에도 속하지 않습니다
        authorName: '내',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【새로운】차단 기능 이벤트 바인딩
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '차단 확인', 
        `차단 확인\"${chat.name}\"차단하시겠습니까? 차단 후에는 블랙리스트에서 타를 제거하거나 타가 다시 친구 신청을 할 때까지 메시지를 보낼 수 없게 됩니다.`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        await db.chats.put(chat);
        
        // 설정 팝업을 닫고, 채팅 화면을 새로 고칩니다
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 채팅 목록을 새로 고침합니다. UI 변경이 있을 수 있습니다
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("수동으로 친구 신청 프로세스를 트리거하는 중입니다. 잠시 후 시도해 주세요...\n만약 API 호출이 성공하면 알림이 팝업될 것입니다. 실패하면 오류 알림이 있을 것입니다. 만약 장시간 반응이 없으면 AI가 일시적으로 신청하지 않기로 결정했을 수도 있습니다.");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;
        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '내가 너의 친구 요청을 승인했어', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【새로 추가】친구 신청 버튼 클릭 이벤트 처리
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '친구 신청 보내기', 
            `당신이 에게 하고 싶은 말을 입력해 주세요\"${chat.name}\"말할 신청 이유:`,
            "우리 화해하자!"
        );
        // 사용자가 내용을 입력하고 클릭했을 때만\"확인\"후에 계속 진행됩니다
        if (reason !== null) {
            // 관계 상태를 로 업데이트\"AI 승인 대기\"
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // UI를 새로 고침하여 표시\"통과 대기\"화면
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【핵심】AI 응답을 트리거하여 이 친구 신청을 처리하도록 합니다
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【새로운】홍바오 기능 이벤트 바인딩 ▼▼▼

// 1. 원래 있던 송금 버튼을(￥)의 클릭 이벤트를 새로운 총 입구 함수로 리디렉션합니다
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 홍바오 모달 창 내부의 제어 버튼
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 홍바오 모달 창의 탭 전환 로직
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 실시간 홍바오 금액 표시 업데이트
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 새 이벤트 바인딩 끝 ▲▲▲

// ▼▼▼ 【새로 추가됨】이벤트 위임을 사용하여 홍바오 클릭을 처리하고, 비활성화 문제를 수정합니다 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 클릭된 홍바오 카드를 찾습니다
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 만약 클릭된 것이 홍바오가 아니면, 아무것도 하지 않습니다

    // 2. 홍바오 카드의 부모 요소 .message에서-bubble타임스탬프를 가져옵니다
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 우리의 기존 처리 함수를 호출합니다
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 새 코드 종료 ▲▲▲

// ▼▼▼ 【새로운】투표 기능 이벤트 리스너 ▼▼▼
// 입력창 툴바에 버튼 추가
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 투표 생성 모달 창의 버튼
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 이벤트 위임을 사용하여 투표 카드 내의 모든 클릭 이벤트를 처리합니다
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 옵션을 클릭했습니다
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 액션 버튼을 클릭했습니다(투표 종료/결과 보기)
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 만약 이미 종료된 투표라면, 카드의 어떤 곳이든 클릭하여 결과를 확인할 수 있습니다
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 새 이벤트 리스너 붙여넣기 끝 ▲▲▲

  // ▼▼▼ 【새로운】AI프로필 사진 갤러리 기능 이벤트 바인딩 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 새로운 추가 끝 ▲▲▲

// ▼▼▼ init() 의事件监听구역,粘贴这段【새 코드】▼▼▼
document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (!iconId) return;

        const currentUrl = state.globalSettings.appIcons[iconId];
        const newUrl = await showCustomPrompt(`변경\"${item.querySelector('.icon-preview').alt}\"아이콘`, '새로운 이미지 URL을 입력해 주세요', currentUrl, 'url');

        if (newUrl && newUrl.trim().startsWith('http')) {
            // 오직 메모리에서만 업데이트하며, 사용자 클릭을 기다립니다\"저장\"
            state.globalSettings.appIcons[iconId] = newUrl.trim();
            // 설정 페이지의 미리보기 이미지를 실시간 업데이트
            item.querySelector('.icon-preview').src = newUrl.trim();
        } else if (newUrl !== null) {
            alert("유효한 URL을 입력해 주세요!");
        }
    }
});
// ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲

// ▼▼▼ init() 함수의 끝에 이 부분을 붙여넣기【완전히 새로운 이벤트 리스너】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // .closest를 사용합니다() 클릭된 카드를 위쪽으로 찾습니다
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 우리의 함수를 호출합니다
            }
        }
    });

    // 브라우저 뒤로 가기 버튼의 이벤트 리스닝. 그것이 오직 한 번만 바인딩되도록 확실히 합니다
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲

// ▼▼▼ init() 함수의 끝에 이 부분을 붙여넣기【완전히 새로운 이벤트 리스너】 ▼▼▼

    // 1. 입력창 상단 바인딩\"링크 공유\"버튼 클릭 이벤트
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. 바인딩模态框中\"취소\"버튼 클릭 이벤트
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 바인딩模态框中\"공유\"버튼 클릭 이벤트
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 새 코드 붙여넣기 끝 ▲▲▲

        // ===================================================================
        // 5. 시작!
            
            showScreen('home-screen');
        }

        init();
    });
</script>
</body>
</html>
